{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _omit2 = require('lodash/omit');\n\nvar _omit3 = _interopRequireDefault(_omit2);\n\nvar _isObject2 = require('lodash/isObject');\n\nvar _isObject3 = _interopRequireDefault(_isObject2);\n\nvar _cloneDeep2 = require('lodash/cloneDeep');\n\nvar _cloneDeep3 = _interopRequireDefault(_cloneDeep2);\n\nvar _util = require('util');\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _ampersandState = require('ampersand-state');\n\nvar _ampersandState2 = _interopRequireDefault(_ampersandState);\n\nvar _storage = require('./storage');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * @class\n */\n\n\nvar SparkPlugin = _ampersandState2.default.extend({\n  derived: {\n    boundedStorage: {\n      deps: [],\n      fn: function fn() {\n        return (0, _storage.makeSparkPluginStore)('bounded', this);\n      }\n    },\n    unboundedStorage: {\n      deps: [],\n      fn: function fn() {\n        return (0, _storage.makeSparkPluginStore)('unbounded', this);\n      }\n    },\n    config: {\n      // figure out why caching config breaks the refresh integration test\n      // but not the refresh automation test.\n      cache: false,\n      deps: ['spark', 'spark.config'],\n      fn: function fn() {\n        if (this.spark && this.spark.config) {\n          var namespace = this.getNamespace();\n\n          if (namespace) {\n            return this.spark.config[namespace.toLowerCase()];\n          }\n\n          return this.spark.config;\n        }\n\n        return {};\n      }\n    },\n    logger: {\n      deps: ['spark', 'spark.logger'],\n      fn: function fn() {\n        return this.spark.logger || console;\n      }\n    },\n    spark: {\n      deps: ['parent'],\n      fn: function fn() {\n        if (!this.parent && !this.collection) {\n          throw new Error('Cannot determine `this.spark` without `this.parent` or `this.collection`. Please initialize `this` via `children` or `collection` or set `this.parent` manually');\n        }\n        /* eslint consistent-this: [0] */\n\n\n        var parent = this;\n\n        while (parent.parent || parent.collection) {\n          parent = parent.parent || parent.collection;\n        }\n\n        return parent;\n      }\n    }\n  },\n  session: {\n    parent: {\n      type: 'any'\n    },\n\n    /**\n     * Indicates this plugin is ready to be used. Defaults to true but can be\n     * overridden by plugins as appropriate. Used by {@link SparkCore#read}\n     * @instance\n     * @memberof SparkPlugin\n     * @type {boolean}\n     */\n    ready: {\n      default: true,\n      type: 'boolean'\n    }\n  },\n\n  /**\n   * Overrides AmpersandState#clear to make sure we never unset `parent` and\n   * recursively visits children/collections.\n   * @instance\n   * @memberof SparkPlugin\n   * @param {Object} options\n   * @returns {SparkPlugin}\n   */\n  clear: function clear(options) {\n    var _this = this;\n\n    (0, _keys2.default)(this.attributes).forEach(function (key) {\n      if (key !== 'parent') {\n        _this.unset(key, options);\n      }\n    });\n    (0, _keys2.default)(this._children).forEach(function (key) {\n      _this[key].clear();\n    });\n    (0, _keys2.default)(this._collections).forEach(function (key) {\n      _this[key].reset();\n    });\n    return this;\n  },\n\n  /**\n   * Initializer\n   * @private\n   * @param {Object} attrs\n   * @param {Object} options\n   * @returns {undefined}\n   */\n  initialize: function initialize() {\n    var _this2 = this;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    (0, _apply2.default)(_ampersandState2.default.prototype.initialize, this, args); // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure\n    // function.\n\n    this._dataTypes = (0, _cloneDeep3.default)(this._dataTypes);\n    (0, _keys2.default)(this._dataTypes).forEach(function (key) {\n      if (_this2._dataTypes[key].set) {\n        _this2._dataTypes[key].set = _this2._dataTypes[key].set.bind(_this2);\n      }\n    }); // END HACK\n    // Propagate change:[attribute] events from children\n\n    this.on('change', function (model, options) {\n      if (_this2.parent) {\n        _this2.parent.trigger('change:' + _this2.getNamespace().toLowerCase(), _this2.parent, _this2, options);\n      }\n    });\n  },\n\n  /**\n   * @instance\n   * @memberof SparkPlugin\n   * @param {number} depth\n   * @private\n   * @returns {Object}\n   */\n  inspect: function inspect(depth) {\n    return _util2.default.inspect((0, _omit3.default)(this.serialize({\n      props: true,\n      session: true,\n      derived: true\n    }), 'boundedStorage', 'unboundedStorage', 'config', 'logger', 'spark', 'parent'), {\n      depth: depth\n    });\n  },\n  request: function request() {\n    var _spark;\n\n    return (_spark = this.spark).request.apply(_spark, arguments);\n  },\n  upload: function upload() {\n    var _spark2;\n\n    return (_spark2 = this.spark).upload.apply(_spark2, arguments);\n  },\n  when: function when(eventName) {\n    var _this3 = this;\n\n    for (var _len2 = arguments.length, rest = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      rest[_key2 - 1] = arguments[_key2];\n    }\n\n    if (rest && rest.length > 0) {\n      throw new Error('#when() does not accept a callback, you must attach to its promise');\n    }\n\n    return new _promise2.default(function (resolve) {\n      _this3.once(eventName, function () {\n        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        return resolve(args);\n      });\n    });\n  },\n\n  /**\n   * Helper function for dealing with both forms of {@link AmpersandState#set()}\n   * @param {string} key\n   * @param {mixed} value\n   * @param {Object} options\n   * @private\n   * @returns {Array<Object, Object>}\n   */\n  _filterSetParameters: function _filterSetParameters(key, value, options) {\n    var attrs = void 0;\n\n    if ((0, _isObject3.default)(key) || key === null) {\n      attrs = key;\n      options = value;\n    } else {\n      attrs = {};\n      attrs[key] = value;\n    }\n\n    options = options || {};\n    return [attrs, options];\n  }\n});\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nexports.default = SparkPlugin;","map":null,"metadata":{},"sourceType":"script"}