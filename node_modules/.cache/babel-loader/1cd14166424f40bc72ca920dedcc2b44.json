{"ast":null,"code":"/*!\n * algorithms/ecdh.js - Elliptic Curve Diffie-Hellman algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar clone = require(\"lodash.clone\"),\n    merge = require(\"../util/merge\"),\n    omit = require(\"lodash.omit\"),\n    pick = require(\"lodash.pick\"),\n    util = require(\"../util\"),\n    ecUtil = require(\"./ec-util.js\"),\n    hkdf = require(\"./hkdf.js\"),\n    concat = require(\"./concat.js\"),\n    aesKw = require(\"./aes-kw.js\"),\n    helpers = require(\"./helpers.js\"),\n    CONSTANTS = require(\"./constants.js\");\n\nfunction idealHash(curve) {\n  switch (curve) {\n    case \"P-256\":\n      return \"SHA-256\";\n\n    case \"P-384\":\n      return \"SHA-384\";\n\n    case \"P-521\":\n      return \"SHA-512\";\n\n    default:\n      throw new Error(\"unsupported curve: \" + curve);\n  }\n} // ### Exported\n\n\nvar ecdh = module.exports = {}; // ### Derivation algorithms\n// ### \"raw\" ECDH\n\nfunction ecdhDeriveFn() {\n  var alg = {\n    name: \"ECDH\"\n  };\n\n  var validatePublic = function (pk, form) {\n    var pubKey = pk && ecUtil.convertToForge(pk, true);\n\n    if (!pubKey || !pubKey.isValid()) {\n      return Promise.reject(new Error(\"invalid EC public key\"));\n    }\n\n    switch (form) {\n      case \"jwk\":\n        pubKey = ecUtil.convertToJWK(pk, true);\n        break;\n\n      case \"buffer\":\n        pubKey = ecUtil.convertToBuffer(pk, true);\n        break;\n    }\n\n    return Promise.resolve(pubKey);\n  }; // ### fallback implementation -- uses ecc + forge\n\n\n  var fallback = function (key, props) {\n    props = props || {};\n    var keyLen = props.length || 0; // assume {key} is privateKey\n    // assume {props.public} is publicKey\n\n    var privKey = ecUtil.convertToForge(key, false);\n    var p = validatePublic(props.public, \"forge\");\n    p = p.then(function (pubKey) {\n      // {pubKey} is \"forge\"\n      var secret = privKey.computeSecret(pubKey);\n\n      if (keyLen) {\n        // truncate to requested key length\n        if (secret.length < keyLen) {\n          return Promise.reject(new Error(\"key length too large: \" + keyLen));\n        }\n\n        secret = secret.slice(0, keyLen);\n      }\n\n      return secret;\n    });\n    return p;\n  }; // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n\n\n  var webcrypto = function (key, props) {\n    key = key || {};\n    props = props || {};\n    var keyLen = props.length || 0,\n        algParams = merge(clone(alg), {\n      namedCurve: key.crv\n    }); // assume {key} is privateKey\n\n    if (!keyLen) {\n      // calculate key length from private key size\n      keyLen = key.d.length;\n    }\n\n    var privKey = ecUtil.convertToJWK(key, false);\n    privKey = helpers.subtleCrypto.importKey(\"jwk\", privKey, algParams, false, [\"deriveBits\"]); // assume {props.public} is publicKey\n\n    var pubKey = validatePublic(props.public, \"jwk\");\n    pubKey = pubKey.then(function (pubKey) {\n      // {pubKey} is \"jwk\"\n      return helpers.subtleCrypto.importKey(\"jwk\", pubKey, algParams, false, []);\n    });\n    var p = Promise.all([privKey, pubKey]);\n    p = p.then(function (keypair) {\n      var privKey = keypair[0],\n          pubKey = keypair[1];\n      var algParams = merge(clone(alg), {\n        public: pubKey\n      });\n      return helpers.subtleCrypto.deriveBits(algParams, privKey, keyLen * 8);\n    });\n    p = p.then(function (result) {\n      result = new Buffer(result);\n      return result;\n    });\n    return p;\n  };\n\n  var nodejs = function (key, props) {\n    if (\"function\" !== typeof helpers.nodeCrypto.createECDH) {\n      throw new Error(\"unsupported algorithm: ECDH\");\n    }\n\n    props = props || {};\n    var keyLen = props.length || 0;\n    var curve;\n\n    switch (key.crv) {\n      case \"P-256\":\n        curve = \"prime256v1\";\n        break;\n\n      case \"P-384\":\n        curve = \"secp384r1\";\n        break;\n\n      case \"P-521\":\n        curve = \"secp521r1\";\n        break;\n\n      default:\n        return Promise.reject(new Error(\"invalid curve: \" + curve));\n    } // assume {key} is privateKey\n    // assume {props.public} is publicKey\n\n\n    var privKey = ecUtil.convertToBuffer(key, false);\n    var p = validatePublic(props.public, \"buffer\");\n    p = p.then(function (pubKey) {\n      // {pubKey} is \"buffer\"\n      var ecdh = helpers.nodeCrypto.createECDH(curve); // dummy call so computeSecret doesn't fail\n      // ecdh.generateKeys();\n\n      ecdh.setPrivateKey(privKey);\n      var secret = ecdh.computeSecret(pubKey);\n\n      if (keyLen) {\n        if (secret.length < keyLen) {\n          return Promise.reject(new Error(\"key length too large: \" + keyLen));\n        }\n\n        secret = secret.slice(0, keyLen);\n      }\n\n      return secret;\n    });\n    return p;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction ecdhConcatDeriveFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function (key, props) {\n    props = props || {};\n    var hash;\n\n    try {\n      hash = props.hash || idealHash(key.crv);\n\n      if (!hash) {\n        throw new Error(\"invalid hash: \" + hash);\n      }\n\n      hash.toUpperCase();\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n\n    var params = [\"public\"]; // derive shared secret\n    // NOTE: whitelist items from {props} for ECDH\n\n    var promise = ecdh.ECDH.derive(key, pick(props, params)); // expand\n\n    promise = promise.then(function (shared) {\n      // NOTE: blacklist items from {props} for ECDH\n      return concat[\"CONCAT-\" + hash].derive(shared, omit(props, params));\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\nfunction ecdhHkdfDeriveFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function (key, props) {\n    props = props || {};\n    var hash;\n\n    try {\n      hash = props.hash || idealHash(key.crv);\n\n      if (!hash) {\n        throw new Error(\"invalid hash: \" + hash);\n      }\n\n      hash.toUpperCase();\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n\n    var params = [\"public\"]; // derive shared secret\n    // NOTE: whitelist items from {props} for ECDH\n\n    var promise = ecdh.ECDH.derive(key, pick(props, params)); // extract-and-expand\n\n    promise = promise.then(function (shared) {\n      // NOTE: blacklist items from {props} for ECDH\n      return hkdf[\"HKDF-\" + hash].derive(shared, omit(props, params));\n    });\n    return promise;\n  };\n\n  return fn;\n} // ### Wrap/Unwrap algorithms\n\n\nfunction doEcdhesCommonDerive(privKey, pubKey, props) {\n  function prependLen(input) {\n    return Buffer.concat([helpers.int32ToBuffer(input.length), input]);\n  }\n\n  var algId = props.algorithm || \"\",\n      keyLen = CONSTANTS.KEYLENGTH[algId],\n      apu = util.asBuffer(props.apu || \"\", \"base64url\"),\n      apv = util.asBuffer(props.apv || \"\", \"base64url\");\n  var otherInfo = Buffer.concat([prependLen(new Buffer(algId, \"utf8\")), prependLen(apu), prependLen(apv), helpers.int32ToBuffer(keyLen)]);\n  var params = {\n    public: pubKey,\n    length: keyLen / 8,\n    hash: \"SHA-256\",\n    otherInfo: otherInfo\n  };\n  return ecdh[\"ECDH-CONCAT\"].derive(privKey, params);\n}\n\nfunction ecdhesDirEncryptFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function (key, pdata, props) {\n    props = props || {}; // {props.epk} is private\n\n    if (!props.epk || !props.epk.d) {\n      return Promise.reject(new Error(\"missing ephemeral private key\"));\n    }\n\n    var epk = ecUtil.convertToObj(props.epk, false); // {key} is public\n\n    if (!key || !key.x || !key.y) {\n      return Promise.reject(new Error(\"missing static public key\"));\n    }\n\n    var spk = ecUtil.convertToObj(key, true); // derive ECDH shared\n\n    var promise = doEcdhesCommonDerive(epk, spk, {\n      algorithm: props.enc,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function (shared) {\n      return {\n        data: shared,\n        once: true,\n        direct: true\n      };\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\nfunction ecdhesDirDecryptFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function (key, cdata, props) {\n    props = props || {}; // {props.epk} is public\n\n    if (!props.epk || !props.epk.x || !props.epk.y) {\n      return Promise.reject(new Error(\"missing ephemeral public key\"));\n    }\n\n    var epk = ecUtil.convertToObj(props.epk, true); // {key} is private\n\n    if (!key || !key.d) {\n      return Promise.reject(new Error(\"missing static private key\"));\n    }\n\n    var spk = ecUtil.convertToObj(key, false); // derive ECDH shared\n\n    var promise = doEcdhesCommonDerive(spk, epk, {\n      algorithm: props.enc,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function (shared) {\n      return shared;\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\nfunction ecdhesKwEncryptFn(wrap) {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function (key, pdata, props) {\n    props = props || {}; // {props.epk} is private\n\n    if (!props.epk || !props.epk.d) {\n      return Promise.reject(new Error(\"missing ephemeral private key\"));\n    }\n\n    var epk = ecUtil.convertToObj(props.epk, false); // {key} is public\n\n    if (!key || !key.x || !key.y) {\n      return Promise.reject(new Error(\"missing static public key\"));\n    }\n\n    var spk = ecUtil.convertToObj(key, true); // derive ECDH shared\n\n    var promise = doEcdhesCommonDerive(epk, spk, {\n      algorithm: props.alg,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function (shared) {\n      // wrap provided key with ECDH shared\n      return wrap(shared, pdata);\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\nfunction ecdhesKwDecryptFn(unwrap) {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function (key, cdata, props) {\n    props = props || {}; // {props.epk} is public\n\n    if (!props.epk || !props.epk.x || !props.epk.y) {\n      return Promise.reject(new Error(\"missing ephemeral public key\"));\n    }\n\n    var epk = ecUtil.convertToObj(props.epk, true); // {key} is private\n\n    if (!key || !key.d) {\n      return Promise.reject(new Error(\"missing static private key\"));\n    }\n\n    var spk = ecUtil.convertToObj(key, false); // derive ECDH shared\n\n    var promise = doEcdhesCommonDerive(spk, epk, {\n      algorithm: props.alg,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function (shared) {\n      // unwrap provided key with ECDH shared\n      return unwrap(shared, cdata);\n    });\n    return promise;\n  };\n\n  return fn;\n} // ### Public API\n// * [name].derive\n\n\n[\"ECDH\", \"ECDH-HKDF\", \"ECDH-CONCAT\"].forEach(function (name) {\n  var kdf = /^ECDH(?:-(\\w+))?$/g.exec(name || \"\")[1];\n  var op = ecdh[name] = ecdh[name] || {};\n\n  switch (kdf || \"\") {\n    case \"CONCAT\":\n      op.derive = ecdhConcatDeriveFn();\n      break;\n\n    case \"HKDF\":\n      op.derive = ecdhHkdfDeriveFn();\n      break;\n\n    case \"\":\n      op.derive = ecdhDeriveFn();\n      break;\n\n    default:\n      op.derive = null;\n  }\n}); // * [name].encrypt\n// * [name].decrypt\n\n[\"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A192KW\", \"ECDH-ES+A256KW\"].forEach(function (name) {\n  var kw = /^ECDH-ES(?:\\+(.+))?/g.exec(name || \"\")[1];\n  var op = ecdh[name] = ecdh[name] || {};\n\n  if (!kw) {\n    op.encrypt = ecdhesDirEncryptFn();\n    op.decrypt = ecdhesDirDecryptFn();\n  } else {\n    kw = aesKw[kw];\n\n    if (kw) {\n      op.encrypt = ecdhesKwEncryptFn(kw.encrypt);\n      op.decrypt = ecdhesKwDecryptFn(kw.decrypt);\n    } else {\n      op.ecrypt = op.decrypt = null;\n    }\n  }\n}); //*/","map":null,"metadata":{},"sourceType":"script"}