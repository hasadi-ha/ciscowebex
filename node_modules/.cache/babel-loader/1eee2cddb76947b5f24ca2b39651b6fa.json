{"ast":null,"code":"/*!\n * algorithms/aes-kw.js - AES-KW Key-Wrapping\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar helpers = require(\"./helpers.js\"),\n    forge = require(\"../deps/forge.js\"),\n    DataBuffer = require(\"../util/databuffer.js\");\n\nvar A0 = new Buffer(\"a6a6a6a6a6a6a6a6\", \"hex\"); // ### helpers\n\nfunction xor(a, b) {\n  var len = Math.max(a.length, b.length);\n  var result = new Buffer(len);\n\n  for (var idx = 0; len > idx; idx++) {\n    result[idx] = (a[idx] || 0) ^ (b[idx] || 0);\n  }\n\n  return result;\n}\n\nfunction split(input, size) {\n  var output = [];\n\n  for (var idx = 0; input.length > idx; idx += size) {\n    output.push(input.slice(idx, idx + size));\n  }\n\n  return output;\n}\n\nfunction longToBigEndian(input) {\n  var hi = Math.floor(input / 4294967296),\n      lo = input % 4294967296;\n  var output = new Buffer(8);\n  output[0] = 0xff & hi >>> 24;\n  output[1] = 0xff & hi >>> 16;\n  output[2] = 0xff & hi >>> 8;\n  output[3] = 0xff & hi >>> 0;\n  output[4] = 0xff & lo >>> 24;\n  output[5] = 0xff & lo >>> 16;\n  output[6] = 0xff & lo >>> 8;\n  output[7] = 0xff & lo >>> 0;\n  return output;\n}\n\nfunction kwEncryptFN(size) {\n  function commonChecks(key, data) {\n    if (size !== key.length << 3) {\n      throw new Error(\"invalid key size\");\n    }\n\n    if (0 < data.length && 0 !== data.length % 8) {\n      throw new Error(\"invalid data length\");\n    }\n  } // ### 'fallback' implementation -- uses forge\n\n\n  var fallback = function (key, pdata) {\n    try {\n      commonChecks(key, pdata);\n    } catch (err) {\n      return Promise.reject(err);\n    } // setup cipher\n\n\n    var cipher = forge.cipher.createCipher(\"AES\", new DataBuffer(key)); // split input into chunks\n\n    var R = split(pdata, 8);\n    var A, B, count;\n    A = A0;\n\n    for (var jdx = 0; 6 > jdx; jdx++) {\n      for (var idx = 0; R.length > idx; idx++) {\n        count = R.length * jdx + idx + 1;\n        B = Buffer.concat([A, R[idx]]);\n        cipher.start();\n        cipher.update(new DataBuffer(B));\n        cipher.finish();\n        B = cipher.output.native();\n        A = xor(B.slice(0, 8), longToBigEndian(count));\n        R[idx] = B.slice(8, 16);\n      }\n    }\n\n    R = [A].concat(R);\n    var cdata = Buffer.concat(R);\n    return Promise.resolve({\n      data: cdata\n    });\n  }; // ### WebCryptoAPI implementation\n\n\n  var webcrypto = function (key, pdata) {\n    try {\n      commonChecks(key, pdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = {\n      name: \"AES-KW\"\n    };\n    var promise = [helpers.subtleCrypto.importKey(\"raw\", pdata, {\n      name: \"HMAC\",\n      hash: \"SHA-256\"\n    }, true, [\"sign\"]), helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"wrapKey\"])];\n    promise = Promise.all(promise);\n    promise = promise.then(function (keys) {\n      return helpers.subtleCrypto.wrapKey(\"raw\", keys[0], // key\n      keys[1], // wrappingKey\n      alg);\n    });\n    promise = promise.then(function (result) {\n      result = new Buffer(result);\n      return {\n        data: result\n      };\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(null, webcrypto, fallback);\n}\n\nfunction kwDecryptFN(size) {\n  function commonChecks(key, data) {\n    if (size !== key.length << 3) {\n      throw new Error(\"invalid key size\");\n    }\n\n    if (0 < data.length - 8 && 0 !== data.length % 8) {\n      throw new Error(\"invalid data length\");\n    }\n  } // ### 'fallback' implementation -- uses forge\n\n\n  var fallback = function (key, cdata) {\n    try {\n      commonChecks(key, cdata);\n    } catch (err) {\n      return Promise.reject(err);\n    } // setup cipher\n\n\n    var cipher = forge.cipher.createDecipher(\"AES\", new DataBuffer(key)); // prepare inputs\n\n    var R = split(cdata, 8),\n        A,\n        B,\n        count;\n    A = R[0];\n    R = R.slice(1);\n\n    for (var jdx = 5; 0 <= jdx; --jdx) {\n      for (var idx = R.length - 1; 0 <= idx; --idx) {\n        count = R.length * jdx + idx + 1;\n        B = xor(A, longToBigEndian(count));\n        B = Buffer.concat([B, R[idx]]);\n        cipher.start();\n        cipher.update(new DataBuffer(B));\n        cipher.finish();\n        B = cipher.output.native();\n        A = B.slice(0, 8);\n        R[idx] = B.slice(8, 16);\n      }\n    }\n\n    if (A.toString() !== A0.toString()) {\n      return Promise.reject(new Error(\"decryption failed\"));\n    }\n\n    var pdata = Buffer.concat(R);\n    return Promise.resolve(pdata);\n  }; // ### WebCryptoAPI implementation\n\n\n  var webcrypto = function (key, cdata) {\n    try {\n      commonChecks(key, cdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = {\n      name: \"AES-KW\"\n    };\n    var promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"unwrapKey\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.unwrapKey(\"raw\", cdata, key, alg, {\n        name: \"HMAC\",\n        hash: \"SHA-256\"\n      }, true, [\"sign\"]);\n    });\n    promise = promise.then(function (result) {\n      // unwrapped CryptoKey -- extract raw\n      return helpers.subtleCrypto.exportKey(\"raw\", result);\n    });\n    promise = promise.then(function (result) {\n      result = new Buffer(result);\n      return result;\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(null, webcrypto, fallback);\n} // ### Public API\n// * [name].encrypt\n// * [name].decrypt\n\n\nvar aesKw = {};\n[\"A128KW\", \"A192KW\", \"A256KW\"].forEach(function (alg) {\n  var size = parseInt(/A(\\d+)KW/g.exec(alg)[1]);\n  aesKw[alg] = {\n    encrypt: kwEncryptFN(size),\n    decrypt: kwDecryptFN(size)\n  };\n});\nmodule.exports = aesKw;","map":null,"metadata":{},"sourceType":"script"}