{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _dec, _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _common = require('@webex/common');\n\nvar _batcher = require('./batcher');\n\nvar _batcher2 = _interopRequireDefault(_batcher);\n\nvar _clientMetricsBatcher = require('./client-metrics-batcher');\n\nvar _clientMetricsBatcher2 = _interopRequireDefault(_clientMetricsBatcher);\n\nvar _callDiagnosticEventsBatcher = require('./call-diagnostic-events-batcher');\n\nvar _callDiagnosticEventsBatcher2 = _interopRequireDefault(_callDiagnosticEventsBatcher);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nvar Metrics = _webexCore.SparkPlugin.extend((_dec = (0, _common.deprecated)('Metrics#sendUnstructured() is deprecated; please use Metrics#submit()'), (_obj = {\n  children: {\n    batcher: _batcher2.default,\n    clientMetricsBatcher: _clientMetricsBatcher2.default,\n    callDiagnosticEventsBatcher: _callDiagnosticEventsBatcher2.default\n  },\n  namespace: 'Metrics',\n  sendUnstructured: function sendUnstructured(key, value) {\n    return this.submit(key, value);\n  },\n  submit: function submit(key, value) {\n    return this.batcher.request((0, _assign2.default)({\n      key: key\n    }, value));\n  },\n\n  /**\n   * This corresponds to #sendSemiStructured() in the deprecated metrics handler\n   * @param {string} eventName\n   * @param {Object} props\n   * @param {string} preLoginId\n   * @returns {Object} HttpResponse object\n   */\n  submitClientMetrics: function submitClientMetrics(eventName, props, preLoginId) {\n    var payload = {\n      metricName: eventName\n    };\n\n    if (props.tags) {\n      payload.tags = props.tags;\n    }\n\n    if (props.fields) {\n      payload.fields = props.fields;\n    }\n\n    if (props.type) {\n      payload.type = props.type;\n    }\n\n    if (props.context) {\n      payload.context = props.context;\n    }\n\n    payload.timestamp = Date.now();\n\n    if (preLoginId) {\n      var _payload = {\n        metrics: [payload]\n      }; // Do not batch these because pre-login events occur during onboarding, so we will be partially blind\n      // to users' progress through the reg flow if we wait to persist pre-login metrics for people who drop off because\n      // their metrics will not post from a queue flush in time\n\n      return this.postPreLoginMetric(_payload, preLoginId);\n    }\n\n    return this.clientMetricsBatcher.request(payload);\n  },\n\n  /**\n   * Issue request to alias a user's pre-login ID with their CI UUID\n   * @param {string} preLoginId\n   * @returns {Object} HttpResponse object\n   */\n  aliasUser: function aliasUser(preLoginId) {\n    return this.request({\n      method: 'POST',\n      api: 'metrics',\n      resource: 'clientmetrics',\n      headers: {\n        'x-prelogin-userid': preLoginId\n      },\n      body: {},\n      qs: {\n        alias: true\n      }\n    });\n  },\n  postPreLoginMetric: function postPreLoginMetric(payload, preLoginId) {\n    var _this = this;\n\n    return this.spark.credentials.getClientToken().then(function (token) {\n      return _this.request({\n        method: 'POST',\n        api: 'metrics',\n        resource: 'clientmetrics-prelogin',\n        headers: {\n          authorization: token.toString(),\n          'x-prelogin-userid': preLoginId\n        },\n        body: payload\n      });\n    });\n  },\n  submitCallDiagnosticEvents: function submitCallDiagnosticEvents(payload) {\n    var event = {\n      type: 'diagnostic-event',\n      eventPayload: payload\n    };\n    return this.callDiagnosticEventsBatcher.request(event);\n  },\n  version: '1.59.0'\n}, _applyDecoratedDescriptor(_obj, 'sendUnstructured', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'sendUnstructured'), _obj), _obj)));\n\nexports.default = Metrics;","map":null,"metadata":{},"sourceType":"script"}