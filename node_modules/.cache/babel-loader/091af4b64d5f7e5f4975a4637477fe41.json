{"ast":null,"code":"/**\n * deps/ecc/index.js - Elliptic Curve Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar forge = require(\"../../deps/forge\"),\n    BigInteger = forge.jsbn.BigInteger,\n    ec = require(\"./math.js\"),\n    CURVES = require(\"./curves.js\"); // ### Helpers\n\n\nfunction hex2bn(s) {\n  return new BigInteger(s, 16);\n}\n\nfunction bn2bin(bn, len) {\n  if (!len) {\n    len = Math.ceil(bn.bitLength() / 8);\n  }\n\n  len = len * 2;\n  var hex = bn.toString(16); // truncate-left if too large\n\n  hex = hex.substring(Math.max(hex.length - len, 0)); // pad-left if too small\n\n  while (len > hex.length) {\n    hex = \"0\" + hex;\n  }\n\n  return new Buffer(hex, \"hex\");\n}\n\nfunction bin2bn(s) {\n  if (\"string\" === typeof s) {\n    s = new Buffer(s, \"binary\");\n  }\n\n  return hex2bn(s.toString(\"hex\"));\n}\n\nfunction keySizeBytes(params) {\n  return Math.ceil(params.getN().bitLength() / 8);\n}\n\nfunction namedCurve(curve) {\n  var params = CURVES[curve];\n\n  if (!params) {\n    throw new TypeError(\"unsupported named curve: \" + curve);\n  }\n\n  return params;\n}\n\nfunction normalizeEcdsa(params, md) {\n  var log2n = params.getN().bitLength(),\n      mdLen = md.length * 8;\n  var e = bin2bn(md);\n\n  if (log2n < mdLen) {\n    e = e.shiftRight(mdLen - log2n);\n  }\n\n  return e;\n} // ### EC Public Key\n\n/**\n *\n * @param {String} curve The named curve\n * @param {BigInteger} x The X coordinate\n * @param {BigInteger} y The Y coordinate\n */\n\n\nfunction ECPublicKey(curve, x, y) {\n  var params = namedCurve(curve),\n      c = params.getCurve();\n  var key = new ec.ECPointFp(c, c.fromBigInteger(x), c.fromBigInteger(y));\n  this.curve = curve;\n  this.params = params;\n  this.point = key;\n  var size = keySizeBytes(params);\n  this.x = bn2bin(x, size);\n  this.y = bn2bin(y, size);\n} // basics\n\n\nECPublicKey.prototype.isValid = function () {\n  return this.params.curve.contains(this.point);\n}; // ECDSA\n\n\nECPublicKey.prototype.verify = function (md, sig) {\n  var N = this.params.getN(),\n      G = this.params.getG(); // prepare and validate (r, s)\n\n  var r = bin2bn(sig.r),\n      s = bin2bn(sig.s);\n\n  if (r.compareTo(BigInteger.ONE) < 0 || r.compareTo(N) >= 0) {\n    return false;\n  }\n\n  if (s.compareTo(BigInteger.ONE) < 0 || r.compareTo(N) >= 0) {\n    return false;\n  } // normalize input\n\n\n  var e = normalizeEcdsa(this.params, md); // verify (r, s)\n\n  var w = s.modInverse(N),\n      u1 = e.multiply(w).mod(N),\n      u2 = r.multiply(w).mod(N);\n  var v = G.multiplyTwo(u1, this.point, u2).getX().toBigInteger();\n  v = v.mod(N);\n  return v.equals(r);\n}; // ### EC Private Key\n\n/**\n * @param {String} curve The named curve\n * @param {Buffer} key The private key value\n */\n\n\nfunction ECPrivateKey(curve, key) {\n  var params = namedCurve(curve);\n  this.curve = curve;\n  this.params = params;\n  var size = keySizeBytes(params);\n  this.d = bn2bin(key, size);\n}\n\nECPrivateKey.prototype.toPublicKey = function () {\n  var d = bin2bn(this.d);\n  var P = this.params.getG().multiply(d);\n  return new ECPublicKey(this.curve, P.getX().toBigInteger(), P.getY().toBigInteger());\n}; // ECDSA\n\n\nECPrivateKey.prototype.sign = function (md) {\n  var keysize = keySizeBytes(this.params),\n      N = this.params.getN(),\n      G = this.params.getG(),\n      e = normalizeEcdsa(this.params, md),\n      d = bin2bn(this.d);\n  var r, s;\n  var k, x1, z;\n\n  do {\n    do {\n      // determine random nonce\n      do {\n        k = bin2bn(forge.random.getBytes(keysize));\n      } while (k.equals(BigInteger.ZERO) || k.compareTo(N) >= 0); // (x1, y1) = k * G\n\n\n      x1 = G.multiply(k).getX().toBigInteger(); // r = x1 mod N\n\n      r = x1.mod(N);\n    } while (r.equals(BigInteger.ZERO)); // s = (k^-1 * (e + r * d)) mod N\n\n\n    z = d.multiply(r);\n    z = e.add(z);\n    s = k.modInverse(N).multiply(z).mod(N);\n  } while (s.equals(BigInteger.ONE)); // convert (r, s) to bytes\n\n\n  var len = keySizeBytes(this.params);\n  r = bn2bin(r, len);\n  s = bn2bin(s, len);\n  return {\n    r: r,\n    s: s\n  };\n}; // basics\n\n\nECPrivateKey.prototype.isValid = function () {\n  var d = bin2bn(this.d),\n      n1 = params.getN().subtract(BigIneger.ONE);\n  return d.compareTo(BigInteger.ONE) >= 0 && d.compareTo(n1) < 0;\n}; // ECDH\n\n\nECPrivateKey.prototype.computeSecret = function (pubkey) {\n  var d = bin2bn(this.d);\n  var S = pubkey.point.multiply(d).getX().toBigInteger();\n  S = bn2bin(S, keySizeBytes(this.params));\n  return S;\n}; // ### Public API\n\n\nexports.generateKeyPair = function (curve) {\n  var params = namedCurve(curve),\n      n = params.getN(); // generate random within range [1, N-1)\n\n  var r = forge.random.getBytes(keySizeBytes(params));\n  r = bin2bn(r);\n  var n1 = n.subtract(BigInteger.ONE);\n  var d = r.mod(n1).add(BigInteger.ONE);\n  var privkey = new ECPrivateKey(curve, d),\n      pubkey = privkey.toPublicKey();\n  return {\n    \"private\": privkey,\n    \"public\": pubkey\n  };\n};\n\nexports.asPublicKey = function (curve, x, y) {\n  if (\"string\" === typeof x) {\n    x = hex2bn(x);\n  } else if (Buffer.isBuffer(x)) {\n    x = bin2bn(x);\n  }\n\n  if (\"string\" === typeof y) {\n    y = hex2bn(y);\n  } else if (Buffer.isBuffer(y)) {\n    y = bin2bn(y);\n  }\n\n  var pubkey = new ECPublicKey(curve, x, y);\n  return pubkey;\n};\n\nexports.asPrivateKey = function (curve, d) {\n  // Elaborate way to get to a Buffer from a (String|Buffer|BigInteger)\n  if (\"string\" === typeof d) {\n    d = hex2bn(d);\n  } else if (Buffer.isBuffer(d)) {\n    d = bin2bn(d);\n  }\n\n  var privkey = new ECPrivateKey(curve, d);\n  return privkey;\n};","map":null,"metadata":{},"sourceType":"script"}