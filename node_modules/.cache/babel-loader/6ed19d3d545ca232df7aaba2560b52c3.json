{"ast":null,"code":"/*$AMPERSAND_VERSION*/\nvar runOnce = require('lodash/once');\n\nvar keys = require('lodash/keys');\n\nvar isEmpty = require('lodash/isEmpty');\n\nvar assign = require('lodash/assign');\n\nvar forEach = require('lodash/forEach');\n\nvar slice = Array.prototype.slice;\n\nvar utils = require('./libs/utils');\n\nvar Events = {\n  // Bind an event to a `callback` function. Passing `\"all\"` will bind\n  // the callback to all events fired.\n  on: function (name, callback, context) {\n    if (!utils.eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n    this._events || (this._events = {});\n    var events = this._events[name] || (this._events[name] = []);\n    events.push({\n      callback: callback,\n      context: context,\n      ctx: context || this\n    });\n    return this;\n  },\n  // Bind an event to only be triggered a single time. After the first time\n  // the callback is invoked, it will be removed.\n  once: function (name, callback, context) {\n    if (!utils.eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n    var self = this;\n    var once = runOnce(function () {\n      self.off(name, once);\n      callback.apply(this, arguments);\n    });\n    once._callback = callback;\n    return this.on(name, once, context);\n  },\n  // Remove one or many callbacks. If `context` is null, removes all\n  // callbacks with that function. If `callback` is null, removes all\n  // callbacks for the event. If `name` is null, removes all bound\n  // callbacks for all events.\n  off: function (name, callback, context) {\n    var retain, ev, events, names, i, l, j, k;\n    if (!this._events || !utils.eventsApi(this, 'off', name, [callback, context])) return this;\n\n    if (!name && !callback && !context) {\n      this._events = void 0;\n      return this;\n    }\n\n    names = name ? [name] : keys(this._events);\n\n    for (i = 0, l = names.length; i < l; i++) {\n      name = names[i];\n\n      if (events = this._events[name]) {\n        this._events[name] = retain = [];\n\n        if (callback || context) {\n          for (j = 0, k = events.length; j < k; j++) {\n            ev = events[j];\n\n            if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {\n              retain.push(ev);\n            }\n          }\n        }\n\n        if (!retain.length) delete this._events[name];\n      }\n    }\n\n    return this;\n  },\n  // Trigger one or many events, firing all bound callbacks. Callbacks are\n  // passed the same arguments as `trigger` is, apart from the event name\n  // (unless you're listening on `\"all\"`, which will cause your callback to\n  // receive the true name of the event as the first argument).\n  trigger: function (name) {\n    if (!this._events) return this;\n    var args = slice.call(arguments, 1);\n    if (!utils.eventsApi(this, 'trigger', name, args)) return this;\n    var events = this._events[name];\n    var allEvents = this._events.all;\n    if (events) utils.triggerEvents(events, args);\n    if (allEvents) utils.triggerEvents(allEvents, arguments);\n    return this;\n  },\n  // Tell this object to stop listening to either specific events ... or\n  // to every object it's currently listening to.\n  stopListening: function (obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo) return this;\n    var remove = !name && !callback;\n    if (!callback && typeof name === 'object') callback = this;\n    if (obj) (listeningTo = {})[obj._listenId] = obj;\n    var self = this;\n    forEach(listeningTo, function (item, id) {\n      item.off(name, callback, self);\n      if (remove || isEmpty(item._events)) delete self._listeningTo[id];\n    });\n    return this;\n  },\n  // extend an object with event capabilities if passed\n  // or just return a new one.\n  createEmitter: function (obj) {\n    return assign(obj || {}, Events);\n  },\n  listenTo: utils.createListenMethod('on'),\n  listenToOnce: utils.createListenMethod('once'),\n  listenToAndRun: function (obj, name, callback) {\n    this.listenTo.apply(this, arguments);\n    if (!callback && typeof name === 'object') callback = this;\n    callback.apply(this);\n    return this;\n  }\n}; // setup aliases\n\nEvents.bind = Events.on;\nEvents.unbind = Events.off;\nEvents.removeListener = Events.off;\nEvents.removeAllListeners = Events.off;\nEvents.emit = Events.trigger;\nmodule.exports = Events;","map":null,"metadata":{},"sourceType":"script"}