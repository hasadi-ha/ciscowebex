{"ast":null,"code":"/*!\n * jwe/encrypt.js - Encrypt to a JWE\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar assign = require(\"lodash.assign\"),\n    clone = require(\"lodash.clone\"),\n    util = require(\"../util\"),\n    generateCEK = require(\"./helpers\").generateCEK,\n    JWK = require(\"../jwk\"),\n    slice = require(\"./helpers\").slice,\n    zlib = require(\"zlib\"),\n    CONSTANTS = require(\"../algorithms/constants\");\n\nvar DEFAULTS = require(\"./defaults\");\n/**\n * @class JWE.Encrypter\n * @classdesc\n * Generator of encrypted data.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call {@link\n * JWE.createEncrypt}.\n */\n\n\nfunction JWEEncrypter(cfg, fields, recipients) {\n  var finalized = false,\n      format = cfg.format || \"general\",\n      protectAll = !!cfg.protectAll,\n      content = new Buffer(0);\n  /**\n   * @member {String} JWE.Encrypter#zip\n   * @readonly\n   * @description\n   * Indicates the compression algorithm applied to the plaintext\n   * before it is encrypted.  The possible values are:\n   *\n   * + **`\"DEF\"`**: Compress the plaintext using the DEFLATE algorithm.\n   * + **`\"\"`**: Do not compress the plaintext.\n   */\n\n  Object.defineProperty(this, \"zip\", {\n    get: function () {\n      return fields.zip || \"\";\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Boolean} JWE.Encrypter#compact\n   * @readonly\n   * @description\n   * Indicates whether the output of this encryption generator is\n   * using the Compact serialization (`true`) or the JSON\n   * serialization (`false`).\n   */\n\n  Object.defineProperty(this, \"compact\", {\n    get: function () {\n      return \"compact\" === format;\n    },\n    enumerable: true\n  });\n  /**\n   * @member {String} JWE.Encrypter#format\n   * @readonly\n   * @description\n   * Indicates the format the output of this encryption generator takes.\n   */\n\n  Object.defineProperty(this, \"format\", {\n    get: function () {\n      return format;\n    },\n    enumerable: true\n  });\n  /**\n   * @member {String[]} JWE.Encrypter#protected\n   * @readonly\n   * @description\n   * The header parameter names that are protected. Protected header fields\n   * are first serialized to UTF-8 then encoded as util.base64url, then used as\n   * the additional authenticated data in the encryption operation.\n   */\n\n  Object.defineProperty(this, \"protected\", {\n    get: function () {\n      return clone(cfg.protect);\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Object} JWE.Encrypter#header\n   * @readonly\n   * @description\n   * The global header parameters, both protected and unprotected. Call\n   * {@link JWE.Encrypter#protected} to determine which parameters will\n   * be protected.\n   */\n\n  Object.defineProperty(this, \"header\", {\n    get: function () {\n      return clone(fields);\n    },\n    enumerable: true\n  });\n  /**\n   * @method JWE.Encrypter#update\n   * @description\n   * Updates the plaintext data for the encryption generator. The plaintext\n   * is appended to the end of any other plaintext already applied.\n   *\n   * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n   * converted to a Buffer internally to {encoding}.\n   *\n   * @param {Buffer|String} [data] The plaintext to apply.\n   * @param {String} [encoding] The encoding of the plaintext.\n   * @returns {JWE.Encrypter} This encryption generator.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n\n  Object.defineProperty(this, \"update\", {\n    value: function (data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n\n        if (content.length) {\n          content = Buffer.concat([content, data], content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n   * @method JWE.Encrypter#final\n   * @description\n   * Finishes the encryption operation.\n   *\n   * The returned Promise, when fulfilled, is the JSON Web Encryption (JWE)\n   * object, either in the Compact (if {@link JWE.Encrypter#compact} is\n   * `true`) or the JSON serialization.\n   *\n   * @param {Buffer|String} [data] The final plaintext data to apply.\n   * @param {String} [encoding] The encoding of the final plaintext data\n   *        (if any).\n   * @returns {Promise} A promise for the encryption operation.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n\n  Object.defineProperty(this, \"final\", {\n    value: function (data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      } // last-minute data\n\n\n      this.update(data, encoding); // mark as done...ish\n\n      finalized = true;\n      var promise = Promise.resolve({}); // determine CEK and IV\n\n      var encAlg = fields.enc;\n      var encKey;\n      promise = promise.then(function (jwe) {\n        if (cfg.cek) {\n          encKey = JWK.asKey(cfg.cek);\n        }\n\n        return jwe;\n      }); // process recipients\n\n      promise = promise.then(function (jwe) {\n        var procR = function (r, one) {\n          var props = {};\n          props = assign(props, fields);\n          props = assign(props, r.header);\n          var algKey = r.key,\n              algAlg = props.alg; // generate Ephemeral EC Key\n\n          var tks, rpromise;\n\n          if (props.alg.indexOf(\"ECDH-ES\") === 0) {\n            tks = algKey.keystore.temp();\n\n            if (r.epk) {\n              rpromise = Promise.resolve(r.epk).then(function (epk) {\n                r.header.epk = epk.toJSON(false, [\"kid\"]);\n                props.epk = epk.toObject(true, [\"kid\"]);\n              });\n            } else {\n              rpromise = tks.generate(\"EC\", algKey.get(\"crv\")).then(function (epk) {\n                r.header.epk = epk.toJSON(false, [\"kid\"]);\n                props.epk = epk.toObject(true, [\"kid\"]);\n              });\n            }\n          } else {\n            rpromise = Promise.resolve();\n          } // encrypt the CEK\n\n\n          rpromise = rpromise.then(function () {\n            var cek, p; // special case 'alg=dir'\n\n            if (\"dir\" === algAlg && one) {\n              encKey = Promise.resolve(algKey);\n              p = encKey.then(function (jwk) {\n                // fixup encAlg\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = jwk.algorithms(JWK.MODE_ENCRYPT)[0];\n                }\n\n                return {\n                  once: true,\n                  direct: true\n                };\n              });\n            } else {\n              if (!encKey) {\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = cfg.contentAlg;\n                }\n\n                encKey = generateCEK(encAlg);\n              }\n\n              p = encKey.then(function (jwk) {\n                cek = jwk.get(\"k\", true); // algKey may or may not be a promise\n\n                return algKey;\n              });\n              p = p.then(function (algKey) {\n                return algKey.wrap(algAlg, cek, props);\n              });\n            }\n\n            return p;\n          });\n          rpromise = rpromise.then(function (wrapped) {\n            if (wrapped.once && !one) {\n              return Promise.reject(new Error(\"cannot use 'alg':'\" + algAlg + \"' with multiple recipients\"));\n            }\n\n            var rjwe = {},\n                cek;\n\n            if (wrapped.data) {\n              cek = wrapped.data;\n              cek = util.base64url.encode(cek);\n            }\n\n            if (wrapped.direct && cek) {\n              // replace content key\n              encKey = JWK.asKey({\n                kty: \"oct\",\n                k: cek\n              });\n            } else if (cek) {\n              /* eslint camelcase: [0] */\n              rjwe.encrypted_key = cek;\n            }\n\n            if (r.header && Object.keys(r.header).length) {\n              rjwe.header = clone(r.header || {});\n            }\n\n            if (wrapped.header) {\n              rjwe.header = assign(rjwe.header || {}, wrapped.header);\n            }\n\n            return rjwe;\n          });\n          return rpromise;\n        };\n\n        var p = Promise.all(recipients);\n        p = p.then(function (rcpts) {\n          var single = 1 === rcpts.length;\n          rcpts = rcpts.map(function (r) {\n            return procR(r, single);\n          });\n          return Promise.all(rcpts);\n        });\n        p = p.then(function (rcpts) {\n          jwe.recipients = rcpts.filter(function (r) {\n            return !!r;\n          });\n          return jwe;\n        });\n        return p;\n      }); // normalize headers\n\n      var props = {};\n      promise = promise.then(function (jwe) {\n        var protect, lenProtect, unprotect, lenUnprotect;\n        unprotect = clone(fields);\n\n        if (protectAll && jwe.recipients.length === 1 || \"compact\" === format) {\n          // merge single recipient into fields\n          protect = assign(jwe.recipients[0].header || {}, unprotect);\n          lenProtect = Object.keys(protect).length;\n          unprotect = undefined;\n          lenUnprotect = 0;\n          delete jwe.recipients[0].header;\n\n          if (Object.keys(jwe.recipients[0]).length === 0) {\n            jwe.recipients.splice(0, 1);\n          }\n        } else {\n          protect = {};\n          lenProtect = 0;\n          lenUnprotect = Object.keys(unprotect).length;\n          cfg.protect.forEach(function (f) {\n            if (!(f in unprotect)) {\n              return;\n            }\n\n            protect[f] = unprotect[f];\n            lenProtect++;\n            delete unprotect[f];\n            lenUnprotect--;\n          });\n        }\n\n        if (!jwe.recipients || jwe.recipients.length === 0) {\n          delete jwe.recipients;\n        } // \"serialize\" (and setup merged props)\n\n\n        if (unprotect && lenUnprotect > 0) {\n          props = assign(props, unprotect);\n          jwe.unprotected = unprotect;\n        }\n\n        if (protect && lenProtect > 0) {\n          props = assign(props, protect);\n          protect = JSON.stringify(protect);\n          jwe.protected = util.base64url.encode(protect, \"utf8\");\n        }\n\n        return jwe;\n      }); // (OPTIONAL) compress plaintext\n\n      promise = promise.then(function (jwe) {\n        var pdata = content;\n\n        if (!props.zip) {\n          jwe.plaintext = pdata;\n          return jwe;\n        } else if (props.zip === \"DEF\") {\n          return new Promise(function (resolve, reject) {\n            zlib.deflateRaw(new Buffer(pdata, \"binary\"), function (err, data) {\n              if (err) {\n                reject(err);\n              } else {\n                jwe.plaintext = data;\n                resolve(jwe);\n              }\n            });\n          });\n        }\n\n        return Promise.reject(new Error(\"unsupported 'zip' mode\"));\n      }); // encrypt plaintext\n\n      promise = promise.then(function (jwe) {\n        props.adata = jwe.protected;\n\n        if (\"aad\" in cfg && cfg.aad != null) {\n          props.adata += \".\" + cfg.aad;\n          props.adata = new Buffer(props.adata, \"utf8\");\n        } // calculate IV\n\n\n        var iv = cfg.iv || util.randomBytes(CONSTANTS.NONCELENGTH[encAlg] / 8);\n\n        if (\"string\" === typeof iv) {\n          iv = util.base64url.decode(iv);\n        }\n\n        props.iv = iv;\n\n        if (\"recipients\" in jwe && jwe.recipients.length === 1) {\n          props.kdata = jwe.recipients[0].encrypted_key;\n        }\n\n        if (\"epu\" in cfg && cfg.epu != null) {\n          props.epu = cfg.epu;\n        }\n\n        if (\"epv\" in cfg && cfg.epv != null) {\n          props.epv = cfg.epv;\n        }\n\n        var pdata = jwe.plaintext;\n        delete jwe.plaintext;\n        return encKey.then(function (encKey) {\n          var p = encKey.encrypt(encAlg, pdata, props);\n          p = p.then(function (result) {\n            jwe.iv = util.base64url.encode(iv, \"binary\");\n\n            if (\"aad\" in cfg && cfg.aad != null) {\n              jwe.aad = cfg.aad;\n            }\n\n            jwe.ciphertext = util.base64url.encode(result.data, \"binary\");\n            jwe.tag = util.base64url.encode(result.tag, \"binary\");\n            return jwe;\n          });\n          return p;\n        });\n      }); // (OPTIONAL) compact/flattened results\n\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function (jwe) {\n            var compact = new Array(5);\n            compact[0] = jwe.protected;\n\n            if (jwe.recipients && jwe.recipients[0]) {\n              compact[1] = jwe.recipients[0].encrypted_key;\n            }\n\n            compact[2] = jwe.iv;\n            compact[3] = jwe.ciphertext;\n            compact[4] = jwe.tag;\n            compact = compact.join(\".\");\n            return compact;\n          });\n          break;\n\n        case \"flattened\":\n          promise = promise.then(function (jwe) {\n            var flattened = {},\n                rcpt = jwe.recipients && jwe.recipients[0];\n\n            if (jwe.protected) {\n              flattened.protected = jwe.protected;\n            }\n\n            if (jwe.unprotected) {\n              flattened.unprotected = jwe.unprotected;\n            }\n\n            [\"header\", \"encrypted_key\"].forEach(function (f) {\n              if (!rcpt) {\n                return;\n              }\n\n              if (!(f in rcpt)) {\n                return;\n              }\n\n              flattened[f] = rcpt[f];\n            });\n\n            if (jwe.aad) {\n              flattened.aad = jwe.aad;\n            }\n\n            flattened.iv = jwe.iv;\n            flattened.ciphertext = jwe.ciphertext;\n            flattened.tag = jwe.tag;\n            return flattened;\n          });\n          break;\n      }\n\n      return promise;\n    }\n  });\n}\n\nfunction createEncrypt(opts, rcpts) {\n  // fixup recipients\n  var options = opts,\n      rcptStart = 1,\n      rcptList = rcpts;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one recipient must be provided\");\n  }\n\n  if (arguments.length === 1) {\n    // assume opts is the recipient list\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) || opts && \"kty\" in opts || opts && \"key\" in opts && (JWK.isKey(opts.key) || \"kty\" in opts.key)) {\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n\n  if (!Array.isArray(rcptList)) {\n    rcptList = slice(arguments, rcptStart);\n  } // fixup options\n\n\n  options = assign(clone(DEFAULTS), options); // setup header fields\n\n  var fields = clone(options.fields || {});\n\n  if (options.zip) {\n    fields.zip = typeof options.zip === \"boolean\" ? options.zip ? \"DEF\" : false : options.zip;\n  }\n\n  options.format = (options.compact ? \"compact\" : options.format) || \"general\";\n\n  switch (options.format) {\n    case \"compact\":\n      if (\"aad\" in opts) {\n        throw new Error(\"additional authenticated data cannot be used for compact serialization\");\n      }\n\n    /* eslint no-fallthrough: [0] */\n\n    case \"flattened\":\n      if (rcptList.length > 1) {\n        throw new Error(\"too many recipients for compact serialization\");\n      }\n\n      break;\n  } // note protected fields (globally)\n  // protected fields are global only\n\n\n  var protectAll = false;\n\n  if (\"compact\" === options.format || \"*\" === options.protect) {\n    protectAll = true;\n    options.protect = Object.keys(fields).concat(\"enc\");\n  } else if (typeof options.protect === \"string\") {\n    options.protect = [options.protect];\n  } else if (Array.isArray(options.protect)) {\n    options.protect = options.protect.concat();\n  } else if (!options.protect) {\n    options.protect = [];\n  } else {\n    throw new Error(\"protect must be a list of fields\");\n  }\n\n  if (protectAll && 1 < rcptList.length) {\n    throw new Error(\"too many recipients to protect all header parameters\");\n  }\n\n  rcptList = rcptList.map(function (r, idx) {\n    var p; // resolve a key\n\n    if (r && \"kty\" in r) {\n      p = JWK.asKey(r);\n      p = p.then(function (k) {\n        return {\n          key: k\n        };\n      });\n    } else if (r) {\n      p = JWK.asKey(r.key);\n      p = p.then(function (k) {\n        return {\n          header: r.header,\n          reference: r.reference,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for recipient \" + idx));\n    } // convert ephemeral key (if present)\n\n\n    if (r.epk) {\n      p = p.then(function (recipient) {\n        return JWK.asKey(r.epk).then(function (epk) {\n          recipient.epk = epk;\n          return recipient;\n        });\n      });\n    } // resolve the complete recipient\n\n\n    p = p.then(function (recipient) {\n      var key = recipient.key; // prepare the recipient header\n\n      var header = recipient.header || {};\n      recipient.header = header;\n      var props = {};\n      props = assign(props, fields);\n      props = assign(props, recipient.header); // ensure key protection algorithm is set\n\n      if (!props.alg) {\n        props.alg = key.algorithms(JWK.MODE_WRAP)[0];\n      }\n\n      header.alg = props.alg; // determine the key reference\n\n      var ref = recipient.reference;\n      delete recipient.reference;\n\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function (k) {\n          return k in header;\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n\n      var jwk;\n\n      if (ref) {\n        jwk = key.toJSON();\n\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      } // freeze recipient\n\n\n      recipient = Object.freeze(recipient);\n      return recipient;\n    });\n    return p;\n  }); // create and configure encryption\n\n  var cfg = {\n    aad: \"aad\" in options ? util.base64url.encode(options.aad || \"\") : null,\n    contentAlg: options.contentAlg,\n    format: options.format,\n    protect: options.protect,\n    cek: options.cek,\n    iv: options.iv,\n    protectAll: protectAll\n  };\n  var enc = new JWEEncrypter(cfg, fields, rcptList);\n  return enc;\n}\n\nmodule.exports = {\n  encrypter: JWEEncrypter,\n  createEncrypt: createEncrypt\n};","map":null,"metadata":{},"sourceType":"script"}