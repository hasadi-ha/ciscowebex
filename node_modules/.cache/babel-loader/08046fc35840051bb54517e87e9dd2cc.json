{"ast":null,"code":"/*$AMPERSAND_VERSION*/\nvar isFunction = require('lodash/isFunction');\n\nvar _ = {\n  countBy: require('lodash/countBy'),\n  difference: require('lodash/difference'),\n  drop: require('lodash/drop'),\n  each: require('lodash/forEach'),\n  every: require('lodash/every'),\n  filter: require('lodash/filter'),\n  find: require('lodash/find'),\n  forEach: require('lodash/forEach'),\n  groupBy: require('lodash/groupBy'),\n  includes: require('lodash/includes'),\n  keyBy: require('lodash/keyBy'),\n  indexOf: require('lodash/indexOf'),\n  initial: require('lodash/initial'),\n  invoke: require('lodash/invoke'),\n  invokeMap: require('lodash/invokeMap'),\n  isEmpty: require('lodash/isEmpty'),\n  lastIndexOf: require('lodash/lastIndexOf'),\n  map: require('lodash/map'),\n  max: require('lodash/max'),\n  min: require('lodash/min'),\n  partition: require('lodash/partition'),\n  reduce: require('lodash/reduce'),\n  reduceRight: require('lodash/reduceRight'),\n  reject: require('lodash/reject'),\n  sample: require('lodash/sample'),\n  shuffle: require('lodash/shuffle'),\n  some: require('lodash/some'),\n  sortBy: require('lodash/sortBy'),\n  tail: require('lodash/tail'),\n  take: require('lodash/take'),\n  without: require('lodash/without')\n};\nvar slice = [].slice;\nvar mixins = {}; // lodash methods that we want to implement on the Collection.\n\nvar methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find', 'filter', 'reject', 'every', 'some', 'includes', 'invoke', 'invokeMap', 'max', 'min', 'take', 'initial', 'tail', 'drop', 'without', 'difference', 'indexOf', 'shuffle', 'lastIndexOf', 'isEmpty', 'sample', 'partition']; // Mix in each lodash method as a proxy to `Collection#models`.\n\n_.each(methods, function (method) {\n  if (!_[method]) return;\n\n  mixins[method] = function () {\n    var args = slice.call(arguments);\n    args.unshift(this.models);\n    return _[method].apply(_, args);\n  };\n}); // lodash methods that take a property name as an argument.\n\n\nvar attributeMethods = ['groupBy', 'countBy', 'sortBy', 'keyBy']; // Use attributes instead of properties.\n\n_.each(attributeMethods, function (method) {\n  if (!_[method]) return;\n\n  mixins[method] = function (value, context) {\n    var iterator = isFunction(value) ? value : function (model) {\n      return model.get ? model.get(value) : model[value];\n    };\n    return _[method](this.models, iterator, context);\n  };\n}); // Return models with matching attributes. Useful for simple cases of\n// `filter`.\n\n\nmixins.where = function (attrs, first) {\n  if (_.isEmpty(attrs)) return first ? void 0 : [];\n  return this[first ? 'find' : 'filter'](function (model) {\n    var value;\n\n    for (var key in attrs) {\n      value = model.get ? model.get(key) : model[key];\n      if (attrs[key] !== value) return false;\n    }\n\n    return true;\n  });\n}; // Return the first model with matching attributes. Useful for simple cases\n// of `find`.\n\n\nmixins.findWhere = function (attrs) {\n  return this.where(attrs, true);\n}; // Plucks an attribute from each model in the collection.\n\n\nmixins.pluck = function (attr) {\n  return _.invokeMap(this.models, 'get', attr);\n}; // We implement the following trivial methods ourselves.\n// Gets first model\n\n\nmixins.first = function () {\n  return this.models[0];\n}; // Gets last model\n\n\nmixins.last = function () {\n  return this.models[this.models.length - 1];\n}; // Gets size of collection\n\n\nmixins.size = function () {\n  return this.models.length;\n};\n\nmodule.exports = mixins;","map":null,"metadata":{},"sourceType":"script"}