{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ensureH264 = undefined;\n\nvar _filter2 = require('lodash/filter');\n\nvar _filter3 = _interopRequireDefault(_filter2);\n\nvar _find2 = require('lodash/find');\n\nvar _find3 = _interopRequireDefault(_find2);\n\nvar _curry2 = require('lodash/curry');\n\nvar _curry3 = _interopRequireDefault(_curry2);\n\nexports.getMediaDirectionFromSDP = getMediaDirectionFromSDP;\nexports.getMediaFromSDP = getMediaFromSDP;\nexports.reverseMediaDirection = reverseMediaDirection;\nexports.limitBandwith = limitBandwith;\nexports.kindToPropertyFragment = kindToPropertyFragment;\nexports.getMediaDirectionFromSDPForAnswer = getMediaDirectionFromSDPForAnswer;\nexports.boolToDirection = boolToDirection;\nexports.getMediaDirectionFromTracks = getMediaDirectionFromTracks;\nexports.removeExtmap = removeExtmap;\n\nrequire('./webrtc-adapter-adapter');\n\nvar _sdpTransform = require('sdp-transform');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Pulls the direction line for the specified media kind from an sdp\n * @param {string} kind\n * @param {string} sdp\n * @protected\n * @returns {string}\n */\n// we need to import the webrtc adapter before anything else happens\n\n/* eslint-disable import/first */\n\n\nfunction getMediaDirectionFromSDP(kind, sdp) {\n  var query = kind === 'screen' ? {\n    content: 'slides',\n    type: 'video'\n  } : {\n    type: kind\n  };\n  var media = (0, _find3.default)((0, _sdpTransform.parse)(sdp).media, query);\n\n  if (!media) {\n    return 'inactive';\n  }\n\n  return media.direction;\n}\n/**\n *\n * @param {string} kind\n * @param {string} sdp\n * @param {string} direction\n * @protected\n * @returns {object}\n */\n\n\nfunction getMediaFromSDP(kind, sdp, direction) {\n  var query = kind === 'screen' ? {\n    content: 'slides',\n    type: 'video'\n  } : {\n    type: kind\n  };\n  var media = (0, _filter3.default)((0, _sdpTransform.parse)(sdp).media, query);\n  var mediaTypes = {};\n\n  if (direction) {\n    if (direction === 'sendrecv') {\n      media.forEach(function (m) {\n        mediaTypes[m.direction] = m;\n      }); // This adds support for when Firefox splits a sendrecv media connection into\n      // separate sendonly and recvonly connections. This is ok as long as both\n      // connections exist and are in the correct direction. Possibly a FF bug that\n      // will be resolved in the future.\n\n      if (mediaTypes.sendrecv && !mediaTypes.recvonly && !mediaTypes.sendonly) {\n        media = mediaTypes.sendrecv;\n      } else if (!mediaTypes.sendrecv && mediaTypes.recvonly && mediaTypes.sendonly) {\n        media = [mediaTypes.recvonly, mediaTypes.sendonly];\n      }\n    } else {\n      media = media.filter(function (m) {\n        return m.direction === direction;\n      });\n    }\n  }\n\n  return media;\n}\n/**\n * Reverses a media direction from offer to answer (e.g. sendonly -> recvonly)\n * @param {string} direction\n * @protected\n * @returns {string}\n */\n\n\nfunction reverseMediaDirection(direction) {\n  switch (direction) {\n    case 'inactive':\n    case 'sendrecv':\n      return direction;\n\n    case 'sendonly':\n      return 'recvonly';\n\n    case 'recvonly':\n      return 'sendonly';\n\n    default:\n      throw new Error('direction \"' + direction + '\" is not valid');\n  }\n}\n/**\n * Checks a given sdp to ensure it contains an offer for the h264 codec\n * @param {boolean} wantsVideo\n * @param {string} offer\n * @protected\n * @returns {string} returns the offer to simplify use in promise chains\n */\n\n\nvar ensureH264 = exports.ensureH264 = (0, _curry3.default)(function (wantsVideo, offer) {\n  if (wantsVideo) {\n    if (!offer.includes('m=video')) {\n      throw new Error('No video section found in offer');\n    }\n\n    if (!/[hH]264/.test(offer)) {\n      throw new Error('Offer does not include h264 codec');\n    }\n  }\n\n  return offer;\n});\n/**\n * Adds a bandwith limit line to the sdp; without this line, calling fails\n * @param {Object} bandwidthLimit\n * @param {string} sdp SDP\n * @protected\n * @returns {string} The modified SDP\n */\n\nfunction limitBandwith(_ref, sdp) {\n  var audioBandwidthLimit = _ref.audioBandwidthLimit,\n      videoBandwidthLimit = _ref.videoBandwidthLimit;\n  return sdp.split('\\r\\n').reduce(function (lines, line) {\n    lines.push(line);\n\n    if (line.startsWith('m=')) {\n      lines.push('b=TIAS:' + (line.includes('audio') ? audioBandwidthLimit : videoBandwidthLimit));\n    }\n\n    return lines;\n  }, []).join('\\r\\n');\n}\n/**\n * Helper for dealing wait capitalization\n * @param {string} kind audio|video\n * @protected\n * @returns {string} Audio|Video\n */\n\n\nfunction kindToPropertyFragment(kind) {\n  return kind === 'audio' ? 'Audio' : 'Video';\n}\n/**\n * Like get getMediaDirectionFromSDP, but reverses the the result\n * @param {string} kind\n * @param {string} offerSdp\n * @protected\n * @returns {string}\n */\n\n\nfunction getMediaDirectionFromSDPForAnswer(kind, offerSdp) {\n  return reverseMediaDirection(getMediaDirectionFromSDP(kind, offerSdp));\n}\n/**\n * Converts a pair of booleans to a SDP direction string\n * @param {boolean} send\n * @param {boolean} recv\n * @protected\n * @returns {string}\n */\n\n\nfunction boolToDirection(send, recv) {\n  if (send && recv) {\n    return 'sendrecv';\n  }\n\n  if (send) {\n    return 'sendonly';\n  }\n\n  if (recv) {\n    return 'recvonly';\n  }\n\n  return 'inactive';\n}\n/**\n * Determines the flow of media for a given kind of media on a peer connection\n * @param {string} kind\n * @param {RTCPeerConnection} pc\n * @protected\n * @returns {string}\n */\n\n\nfunction getMediaDirectionFromTracks(kind, pc) {\n  if (pc.signalingState === 'closed') {\n    return 'inactive';\n  }\n\n  var senders = pc.getSenders().filter(function (s) {\n    return s.track && s.track.kind === kind;\n  });\n  var send = senders.length > 0 && senders.reduce(function (acc, s) {\n    return acc || s.track.enabled;\n  }, false);\n  var receivers = pc.getReceivers().filter(function (r) {\n    return r.track && r.track.kind === kind;\n  });\n  var recv = receivers.length > 0 && receivers.reduce(function (acc, r) {\n    return acc || r.track.enabled;\n  }, false);\n  return boolToDirection(send, recv);\n}\n/**\n * Our services don't support extmap lines in sdps, so we need to remove them\n * @param {string} sdp\n * @returns {string}\n */\n\n\nfunction removeExtmap(sdp) {\n  return sdp.replace(/a=extmap.*\\r\\n/g, '');\n}","map":null,"metadata":{},"sourceType":"script"}