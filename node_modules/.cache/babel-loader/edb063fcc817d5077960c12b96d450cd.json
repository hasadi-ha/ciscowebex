{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.events = undefined;\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _get2 = require('lodash/get');\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _defaults2 = require('lodash/defaults');\n\nvar _defaults3 = _interopRequireDefault(_defaults2);\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _mediaEngineWebrtc = require('@webex/media-engine-webrtc');\n\nvar _mediaEngineWebrtc2 = _interopRequireDefault(_mediaEngineWebrtc);\n\nvar _call = require('./call');\n\nvar _call2 = _interopRequireDefault(_call);\n\nvar _stateParsers = require('./state-parsers');\n\nvar _calls = require('./calls');\n\nvar _calls2 = _interopRequireDefault(_calls);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar events = exports.events = {\n  CALL_CREATED: 'call:created',\n  CALL_INCOMING: 'call:incoming'\n};\n/**\n * Call Created Event\n *\n * Emitted when a call begins outside of the sdk\n *\n * @event call:created\n * @instance\n * @memberof Phone\n * @type {Object}\n * @property {Call} call The created call\n */\n\n/**\n * Incoming Call Event\n *\n * Emitted when a call begins and when {@link Phone#register} is invoked and\n * there are active calls.\n *\n * @event call:incoming\n * @instance\n * @memberof Phone\n * @type {Object}\n * @property {Call} call The incoming call\n */\n\n/**\n * @class\n */\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nvar Phone = _webexCore.WebexPlugin.extend({\n  collections: {\n    emittedCalls: _calls2.default\n  },\n  session: {\n    /**\n     * Indicates whether or not the WebSocket is connected\n     * @instance\n     * @memberof Phone\n     * @member {Boolean}\n     * @readonly\n     */\n    connected: {\n      default: false,\n      type: 'boolean'\n    },\n\n    /**\n     * Specifies the facingMode to be used by {@link Phone#dial} and\n     * {@link Call#answer} when no constraint is specified. Does not apply if\n     * - a {@link MediaStream} is passed to {@link Phone#dial} or\n     * {@link Call#answer}\n     * - constraints are passed to {@link Phone#dial} or  {@link Call#answer}\n     * The only valid values are `user` and `environment`. For any other values,\n     * you must provide your own constrains or {@link MediaStream}\n     * @default `user`\n     * @instance\n     * @memberof Phone\n     * @type {string}\n     */\n    defaultFacingMode: {\n      default: 'user',\n      type: 'string',\n      values: ['user', 'environment']\n    },\n\n    /**\n     * indicates whether or not the client is registered with the Webex Teams\n     * cloud\n     * @instance\n     * @memberof Phone\n     * @member {Boolean}\n     * @readonly\n     */\n    registered: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n  namespace: 'phone',\n\n  /**\n   * Indicates if the current browser appears to support webrtc calling. Note:\n   * at this time, there's no way to determine if the current browser supports\n   * h264 without asking for camera permissions\n   * @instance\n   * @memberof Phone\n   * @returns {Promise<Boolean>}\n   */\n  isCallingSupported: function isCallingSupported() {\n    return new _promise2.default(function (resolve) {\n      // I'm not thrilled by this, but detectrtc breaks the global namespace in\n      // a way that screws up the browserOnly/nodeOnly test helpers.\n      // eslint-disable-next-line global-require\n      var DetectRTC = require('detectrtc');\n\n      resolve(DetectRTC.isWebRTCSupported);\n    });\n  },\n\n  /**\n   * Registers the client with the Webex Teams cloud and starts listening for\n   * WebSocket events.\n   *\n   * Subsequent calls refresh the device registration.\n   * @instance\n   * @memberof Phone\n   * @returns {Promise}\n   */\n  register: function register() {\n    var _this = this; // Ideally, we could call webex.refresh via webex-core, but it doesn't know\n    // about the wdm plugin, and all of the leaky abstractions I can think of\n    // seem risky.\n\n\n    return this.webex.internal.device.refresh().then(function () {\n      if (_this.connected) {\n        return _promise2.default.resolve();\n      }\n\n      return _promise2.default.all([_this.emittedCalls.reset(), _this.webex.internal.mercury.when('event:mercury.buffer_state').then(function (_ref) {\n        var _ref2 = (0, _slicedToArray3.default)(_ref, 1),\n            message = _ref2[0];\n\n        if (message.data.bufferState.locus === 'UNKNOWN') {\n          return _this.listActiveCalls();\n        }\n\n        return _promise2.default.resolve();\n      }), _this.webex.internal.mercury.connect()]);\n    });\n  },\n\n  /**\n   * Disconnects from WebSocket and unregisters from the Webex Teams cloud.\n   *\n   * Subsequent calls will be a noop.\n   * @instance\n   * @memberof Phone\n   * @returns {Promise}\n   */\n  deregister: function deregister() {\n    var _this2 = this;\n\n    return this.webex.internal.mercury.disconnect().then(function () {\n      return _this2.webex.internal.device.unregister();\n    });\n  },\n\n  /**\n   * Create a MediaStream to be used for video preview.\n   *\n   * Note: You must explicitly pass the resultant stream to {@link Call#answer()}\n   * or {@link Phone#dial()}\n   * @instance\n   * @memberof Phone\n   * @param {Object|MediaStreamConstraints} options\n   * @param {MediaStreamConstraints} options.constraints\n   * @returns {Promise<MediaStream>}\n   */\n  createLocalMediaStream: function createLocalMediaStream() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var constraints = options.constraints || options;\n    (0, _defaults3.default)(constraints, {\n      audio: true,\n      video: true\n    });\n    return _mediaEngineWebrtc2.default.getUserMedia(constraints);\n  },\n\n  /**\n   * Fetches a list of all of the current user's active calls\n   * @instance\n   * @memberOf Phone\n   * @returns {Promise<Call[]>}\n   */\n  listActiveCalls: function listActiveCalls() {\n    var _this3 = this;\n\n    return this.webex.internal.locus.list().then(function (loci) {\n      // emittedCalls is a collection, convert to array\n      var calls = _this3.emittedCalls.map(function (e) {\n        return e;\n      });\n\n      if (!loci) {\n        return calls;\n      }\n\n      loci.forEach(function (locus) {\n        if (!_this3.emittedCalls.has(locus)) {\n          var callItem = _call2.default.make({\n            locus: locus,\n            parent: _this3.webex\n          });\n\n          calls.push(callItem);\n\n          _this3.emittedCalls.add(callItem);\n\n          _this3._triggerCallEvents(callItem, locus);\n        }\n      });\n      return calls;\n    });\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Phone\n   * @param {Object} attrs\n   * @param {Object} options\n   * @private\n   * @returns {undefined}\n   */\n  initialize: function initialize() {\n    var _this4 = this;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    (0, _apply2.default)(_webexCore.WebexPlugin.prototype.initialize, this, args);\n    this.listenTo(this.webex.internal.mercury, 'event:locus', function (event) {\n      return _this4.onLocusEvent(event);\n    }); // Note: we need to manually wire up change:connected because derived props\n    // can't read through this.parent\n\n    this.listenTo(this.webex.internal.mercury, 'change:connected', function () {\n      _this4.connected = _this4.webex.internal.mercury.connected;\n      _this4.registered = !!_this4.webex.internal.device.url && _this4.connected;\n    }); // Note: we need to manually wire up change:url because derived props\n    // can't read through this.parent\n\n    this.listenTo(this.webex.internal.device, 'change:url', function () {\n      _this4.registered = !!_this4.webex.internal.device.url && _this4.connected;\n    });\n  },\n\n  /**\n   * Determines if the {@link call:incoming} event should be emitted for the\n   * specified {@link Types~MercuryEvent}\n   * @emits call:incoming\n   * @instance\n   * @memberof Phone\n   * @param {Types~MercuryEvent} event\n   * @private\n   * @returns {undefined}\n   */\n  onLocusEvent: function onLocusEvent(event) {\n    var locus = event.data.locus; // We only want to handle calls we are not aware of in an active state\n\n    if (this.emittedCalls.has(locus) || locus.fullState.state.toLowerCase() === 'inactive') {\n      return;\n    } // Create call object and store in emittedCalls\n\n\n    var call = _call2.default.make({\n      locus: locus\n    }, {\n      parent: this.webex\n    });\n\n    this.emittedCalls.add(call); // Trigger events as necessary\n\n    this._triggerCallEvents(call, event.data.locus);\n  },\n\n  /**\n   * Place a call to the specified dialString. A dial string may be an email\n   * address or sip uri.\n   * If you set {@link config.phone.enableExperimentalGroupCallingSupport} to\n   * `true`, the dialString may also be a room id.\n   * @instance\n   * @memberof Phone\n   * @param {string} dialString\n   * @param {Object} options\n   * @param {MediaStreamConstraints} options.constraints\n   * @param {MediaStream} options.localMediaStream if no stream is specified, a\n   * new one will be created based on options.constraints\n   * @returns {Call}\n   */\n  dial: function dial(dialString, options) {\n    var call = _call2.default.make({}, {\n      parent: this.webex\n    });\n\n    call.dial(dialString, options);\n    this.emittedCalls.add(call);\n    return call;\n  },\n\n  /**\n   * Triggers call events for a given call/locus\n   * @param {Call} call\n   * @param {Types~Locus} locus\n   * @returns {undefined}\n   */\n  _triggerCallEvents: function _triggerCallEvents(call, locus) {\n    this.trigger(events.CALL_CREATED, call);\n\n    if ((0, _stateParsers.shouldRing)(locus)) {\n      if ((0, _stateParsers.isCall)(locus) || !(0, _stateParsers.isCall)(locus) && (0, _get3.default)(this, 'config.enableExperimentalGroupCallingSupport')) {\n        this.trigger(events.CALL_INCOMING, call);\n      }\n    }\n  },\n  version: '1.69.1'\n});\n\nexports.default = Phone;","map":null,"metadata":{},"sourceType":"script"}