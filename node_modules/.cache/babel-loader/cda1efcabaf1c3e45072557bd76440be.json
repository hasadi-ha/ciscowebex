{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _defineProperty = require('babel-runtime/core-js/reflect/define-property');\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _weakMap = require('babel-runtime/core-js/weak-map');\n\nvar _weakMap2 = _interopRequireDefault(_weakMap);\n\nvar _isObject2 = require('lodash/isObject');\n\nvar _isObject3 = _interopRequireDefault(_isObject2);\n\nvar _has2 = require('lodash/has');\n\nvar _has3 = _interopRequireDefault(_has2);\n\nvar _defaults2 = require('lodash/defaults');\n\nvar _defaults3 = _interopRequireDefault(_defaults2);\n\nvar _events = require('events');\n\nvar _errors = require('../errors');\n\nvar _common = require('@webex/common');\n\nvar _commonTimers = require('@webex/common-timers');\n\nvar _uuid = require('uuid');\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar sockets = new _weakMap2.default();\n/**\n * Generalized socket abstraction\n */\n\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\nvar Socket = function (_EventEmitter) {\n  (0, _inherits3.default)(Socket, _EventEmitter);\n  /**\n   * constructor\n   * @returns {Socket}\n   */\n\n  function Socket() {\n    (0, _classCallCheck3.default)(this, Socket);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Socket.__proto__ || (0, _getPrototypeOf2.default)(Socket)).call(this));\n\n    _this.onmessage = _this.onmessage.bind(_this);\n    _this.onclose = _this.onclose.bind(_this);\n    return _this;\n  }\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n   * @returns {string}\n   */\n\n\n  (0, _createClass3.default)(Socket, [{\n    key: 'close',\n\n    /**\n     * Closes the socket\n     * @param {Object} options\n     * @param {string} options.reason\n     * @param {number} options.code\n     * @returns {Promise}\n     */\n    value: function close(options) {\n      var _this2 = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        _this2.logger.info('socket: closing');\n\n        var socket = sockets.get(_this2);\n\n        if (socket.readyState === 2 || socket.readyState === 3) {\n          _this2.logger.info('socket: already closed');\n\n          resolve();\n          return;\n        }\n\n        options = options || {};\n\n        if (options.code && options.code !== 1000 && (options.code < 3000 || options.code > 4999)) {\n          reject(new Error('`options.code` must be 1000 or between 3000 and 4999 (inclusive)'));\n          return;\n        }\n\n        options = (0, _defaults3.default)(options, {\n          code: 1000,\n          reason: 'Done'\n        });\n        var closeTimer = (0, _commonTimers.safeSetTimeout)(function () {\n          try {\n            _this2.logger.info('socket: no close event received, forcing closure');\n\n            resolve(_this2.onclose({\n              code: 1000,\n              reason: 'Done (forced)'\n            }));\n          } catch (error) {\n            _this2.logger.warn('socket: force-close failed', error);\n          }\n        }, _this2.forceCloseDelay);\n\n        socket.onclose = function (event) {\n          _this2.logger.info('socket: close event fired', event.code, event.reason);\n\n          clearTimeout(closeTimer);\n\n          _this2.onclose(event);\n\n          resolve(event);\n        };\n\n        socket.close(options.code, options.reason);\n      });\n    }\n    /**\n     * Opens a WebSocket\n     * @param {string} url\n     * @param {options} options\n     * @param {number} options.forceCloseDelay (required)\n     * @param {number} options.pingInterval (required)\n     * @param {number} options.pongTimeout (required)\n     * @param {string} options.token (required)\n     * @param {string} options.trackingId (required)\n     * @param {Logger} options.logger (required)\n     * @param {string} options.logLevelToken\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'open',\n    value: function open(url, options) {\n      var _this3 = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        /* eslint complexity: [0] */\n        if (!url) {\n          reject(new Error('`url` is required'));\n          return;\n        }\n\n        if (sockets.get(_this3)) {\n          reject(new Error('Socket#open() can only be called once per instance'));\n          return;\n        }\n\n        options = options || {};\n        (0, _common.checkRequired)(['forceCloseDelay', 'pingInterval', 'pongTimeout', 'token', 'trackingId', 'logger'], options);\n        (0, _keys2.default)(options).forEach(function (key) {\n          (0, _defineProperty2.default)(_this3, key, {\n            enumerable: false,\n            value: options[key]\n          });\n        });\n        var WebSocket = Socket.getWebSocketConstructor();\n\n        _this3.logger.info('socket: creating WebSocket');\n\n        var socket = new WebSocket(url);\n        socket.binaryType = 'arraybuffer';\n        socket.onmessage = _this3.onmessage;\n\n        socket.onclose = function (event) {\n          event = _this3._fixCloseCode(event);\n\n          switch (event.code) {\n            case 1005:\n              // IE 11 doesn't seem to allow 4XXX codes, so if we get a 1005, assume\n              // it's a bad websocket url. That'll trigger a device refresh; if it\n              // turns out we had a bad token, the device refresh should 401 and\n              // trigger a token refresh.\n              return reject(new _errors.UnknownResponse(event));\n\n            case 4400:\n              return reject(new _errors.BadRequest(event));\n\n            case 4401:\n              return reject(new _errors.NotAuthorized(event));\n\n            case 4403:\n              return reject(new _errors.Forbidden(event));\n            // case 4404:\n            //   return reject(new NotFound(event));\n\n            default:\n              return reject(new _errors.ConnectionError(event));\n          }\n        };\n\n        socket.onopen = function () {\n          _this3.logger.info('socket: connected');\n\n          _this3._authorize().then(function () {\n            _this3.logger.info('socket: authorized');\n\n            socket.onclose = _this3.onclose;\n            resolve();\n          }).catch(reject);\n        };\n\n        socket.onerror = function (event) {\n          _this3.logger.warn('socket: error event fired', event);\n        };\n\n        sockets.set(_this3, socket);\n\n        _this3.logger.info('socket: waiting for server');\n      });\n    }\n    /**\n     * Handles incoming CloseEvents\n     * @param {CloseEvent} event\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'onclose',\n    value: function onclose(event) {\n      this.logger.info('socket: closed', event.code, event.reason);\n      clearTimeout(this.pongTimer);\n      clearTimeout(this.pingTimer);\n      event = this._fixCloseCode(event);\n      this.emit('close', event); // Remove all listeners to (a) avoid reacting to late pongs and (b) ensure\n      // we don't have a retain cycle.\n\n      this.removeAllListeners();\n    }\n    /**\n     * Handles incoming message events\n     * @param {MessageEvent} event\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'onmessage',\n    value: function onmessage(event) {\n      try {\n        var data = JSON.parse(event.data);\n        var sequenceNumber = parseInt(data.sequenceNumber, 10);\n        this.logger.debug('socket: sequence number: ', sequenceNumber);\n\n        if (this.expectedSequenceNumber && sequenceNumber !== this.expectedSequenceNumber) {\n          this.logger.debug('socket: sequence number mismatch indicates lost mercury message. expected: ' + this.expectedSequenceNumber + ', actual: ' + sequenceNumber);\n          this.emit('sequence-mismatch', sequenceNumber, this.expectedSequenceNumber);\n        }\n\n        this.expectedSequenceNumber = sequenceNumber + 1; // Yes, it's a little weird looking; we want to emit message events that\n        // look like normal socket message events, but event.data cannot be\n        // modified and we don't actually care about anything but the data property\n\n        var processedEvent = {\n          data: data\n        };\n\n        this._acknowledge(processedEvent);\n\n        if (data.type === 'pong') {\n          this.emit('pong', processedEvent);\n        } else {\n          this.emit('message', processedEvent);\n        }\n      } catch (error) {\n        // The above code should only be able to throw if we receive an unparsable\n        // message from Mercury. At this time, the only action we have is to\n        // ignore it and move on.\n\n        /* istanbul ignore next */\n        this.logger.warn('socket: error while receiving WebSocket message', error);\n      }\n    }\n    /**\n     * Sends a message up the socket\n     * @param {mixed} data\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'send',\n    value: function send(data) {\n      var _this4 = this;\n\n      return new _promise2.default(function (resolve, reject) {\n        if (_this4.readyState !== 1) {\n          return reject(new Error('INVALID_STATE_ERROR'));\n        }\n\n        if ((0, _isObject3.default)(data)) {\n          data = (0, _stringify2.default)(data);\n        }\n\n        var socket = sockets.get(_this4);\n        socket.send(data);\n        return resolve();\n      });\n    }\n    /**\n     * Sends an acknowledgment for a specific event\n     * @param {MessageEvent} event\n     * @returns {Promise}\n     */\n\n  }, {\n    key: '_acknowledge',\n    value: function _acknowledge(event) {\n      if (!event) {\n        return _promise2.default.reject(new Error('`event` is required'));\n      }\n\n      if (!(0, _has3.default)(event, 'data.id')) {\n        return _promise2.default.reject(new Error('`event.data.id` is required'));\n      }\n\n      return this.send({\n        messageId: event.data.id,\n        type: 'ack'\n      });\n    }\n    /**\n     * Sends an auth message up the socket\n     * @private\n     * @returns {Promise}\n     */\n\n  }, {\n    key: '_authorize',\n    value: function _authorize() {\n      var _this5 = this;\n\n      return new _promise2.default(function (resolve) {\n        _this5.logger.info('socket: authorizing');\n\n        _this5.send({\n          id: _uuid2.default.v4(),\n          type: 'authorization',\n          data: {\n            token: _this5.token\n          },\n          trackingId: _this5.trackingId,\n          logLevelToken: _this5.logLevelToken\n        });\n\n        var waitForBufferState = function waitForBufferState(event) {\n          if (!event.data.type && (event.data.data.eventType === 'mercury.buffer_state' || event.data.data.eventType === 'mercury.registration_status')) {\n            _this5.removeListener('message', waitForBufferState);\n\n            _this5._ping();\n\n            resolve();\n          }\n        };\n\n        _this5.once('message', waitForBufferState);\n      });\n    }\n    /**\n     * Deals with the fact that some browsers drop some close codes (but not\n     * close reasons).\n     * @param {CloseEvent} event\n     * @private\n     * @returns {CloseEvent}\n     */\n\n  }, {\n    key: '_fixCloseCode',\n    value: function _fixCloseCode(event) {\n      if (event.code === 1005 && event.reason) {\n        switch (event.reason.toLowerCase()) {\n          case 'replaced':\n            this.logger.info('socket: fixing CloseEvent code for reason: ', event.reason);\n            event.code = 4000;\n            break;\n\n          case 'authentication failed':\n          case 'authentication did not happen within the timeout window of 30000 seconds.':\n            this.logger.info('socket: fixing CloseEvent code for reason: ', event.reason);\n            event.code = 1008;\n            break;\n\n          default: // do nothing\n\n        }\n      }\n\n      return event;\n    }\n    /**\n     * Sends a ping up the socket and confirms we get it back\n     * @param {[type]} id\n     * @private\n     * @returns {[type]}\n     */\n\n  }, {\n    key: '_ping',\n    value: function _ping(id) {\n      var _this6 = this;\n\n      var confirmPongId = function confirmPongId(event) {\n        try {\n          _this6.logger.debug('socket: pong', event.data.id);\n\n          if (event.data && event.data.id !== id) {\n            _this6.logger.info('socket: received pong for wrong ping id, closing socket');\n\n            _this6.logger.debug('socket: expected', id, 'received', event.data.id);\n\n            _this6.close({\n              code: 1000,\n              reason: 'Pong mismatch'\n            });\n          }\n        } catch (error) {\n          // This try/catch block was added as a debugging step; to the best of my\n          // knowledge, the above can never throw.\n\n          /* istanbul ignore next */\n          _this6.logger.error('socket: error occurred in confirmPongId', error);\n        }\n      };\n\n      var onPongNotReceived = function onPongNotReceived() {\n        try {\n          _this6.logger.info('socket: pong not receive in expected period, closing socket');\n\n          _this6.close({\n            code: 1000,\n            reason: 'Pong not received'\n          }).catch(function (reason) {\n            _this6.logger.warn('socket: failed to close socket after missed pong', reason);\n          });\n        } catch (error) {\n          // This try/catch block was added as a debugging step; to the best of my\n          // knowledge, the above can never throw.\n\n          /* istanbul ignore next */\n          _this6.logger.error('socket: error occurred in onPongNotReceived', error);\n        }\n      };\n\n      var scheduleNextPingAndCancelPongTimer = function scheduleNextPingAndCancelPongTimer() {\n        try {\n          clearTimeout(_this6.pongTimer);\n          _this6.pingTimer = (0, _commonTimers.safeSetTimeout)(function () {\n            return _this6._ping();\n          }, _this6.pingInterval);\n        } catch (error) {\n          // This try/catch block was added as a debugging step; to the best of my\n          // knowledge, the above can never throw.\n\n          /* istanbul ignore next */\n          _this6.logger.error('socket: error occurred in scheduleNextPingAndCancelPongTimer', error);\n        }\n      };\n\n      id = id || _uuid2.default.v4();\n      this.pongTimer = (0, _commonTimers.safeSetTimeout)(onPongNotReceived, this.pongTimeout);\n      this.once('pong', scheduleNextPingAndCancelPongTimer);\n      this.once('pong', confirmPongId);\n      this.logger.debug('socket: ping ' + id);\n      return this.send({\n        id: id,\n        type: 'ping'\n      });\n    }\n  }, {\n    key: 'binaryType',\n    get: function get() {\n      return sockets.get(this).binaryType;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {number}\n     */\n\n  }, {\n    key: 'bufferedAmount',\n    get: function get() {\n      return sockets.get(this).bufferedAmount;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {string}\n     */\n\n  }, {\n    key: 'extensions',\n    get: function get() {\n      return sockets.get(this).extensions;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {string}\n     */\n\n  }, {\n    key: 'protocol',\n    get: function get() {\n      return sockets.get(this).protocol;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {number}\n     */\n\n  }, {\n    key: 'readyState',\n    get: function get() {\n      return sockets.get(this).readyState;\n    }\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n     * @returns {string}\n     */\n\n  }, {\n    key: 'url',\n    get: function get() {\n      return sockets.get(this).url;\n    }\n    /**\n     * Provides the environmentally appropriate constructor (ws in NodeJS,\n     * WebSocket in browsers)\n     * @returns {WebSocket}\n     */\n\n  }], [{\n    key: 'getWebSocketConstructor',\n    value: function getWebSocketConstructor() {\n      throw new Error('Socket.getWebSocketConstructor() must be implemented in an environmentally appropriate way');\n    }\n  }]);\n  return Socket;\n}(_events.EventEmitter);\n\nexports.default = Socket;","map":null,"metadata":{},"sourceType":"script"}