{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _map = require('babel-runtime/core-js/map');\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _get2 = require('lodash/get');\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _filter2 = require('lodash/filter');\n\nvar _filter3 = _interopRequireDefault(_filter2);\n\nexports.activeParticipants = activeParticipants;\nexports.direction = direction;\nexports.waitForMediaShare = waitForMediaShare;\nexports.isActive = isActive;\nexports.isCall = isCall;\nexports.joined = joined;\nexports.joinedOnThisDevice = joinedOnThisDevice;\nexports.participantsToCallMemberships = participantsToCallMemberships;\nexports.participantToCallMembership = participantToCallMembership;\nexports.participantStateToCallMembershipState = participantStateToCallMembershipState;\nexports.makeInternalCallId = makeInternalCallId;\nexports.mediaDirection = mediaDirection;\nexports.participantIsJoined = participantIsJoined;\nexports.remoteParticipant = remoteParticipant;\nexports.remoteParticipants = remoteParticipants;\nexports.remoteAudioMuted = remoteAudioMuted;\nexports.remoteVideoMuted = remoteVideoMuted;\nexports.shouldRing = shouldRing;\nexports.getState = getState;\nexports.getStatus = getStatus;\nexports.getThisDevice = getThisDevice;\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Finds the Locus's active participants\n * @param {Types~Locus} locus\n * @private\n * @returns {Array<Types~LocusParticipant>}\n */\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nfunction activeParticipants(locus) {\n  return (0, _filter3.default)(locus.participants, {\n    state: 'JOINED'\n  });\n}\n/**\n * Indicates if the locus was activated form this device\n * @param {Types~Locus} locus\n * @private\n * @returns {string} unknown|in|out\n */\n\n\nfunction direction(locus) {\n  if (!locus || !locus.self) {\n    return 'unknown';\n  }\n\n  return locus.self.isCreator ? 'out' : 'in';\n}\n/**\n * Finds the media share share for the call, potentially setting up event\n * listeners to wait for a new Locus\n * @param {Call} call\n * @private\n * @returns {Promise<Types~MediaShare>}\n */\n\n\nfunction waitForMediaShare(call) {\n  return function curriedFindShare() {\n    var promise = new _promise2.default(function (resolve, reject) {\n      /**\n       * Searches the call's current locus for the screen share entry in media\n       * shares\n       *\n       * @returns {undefined}\n       */\n      function findShare() {\n        try {\n          call.logger.info('checking for media share');\n          var mediaShare = call.locus.mediaShares.find(function (share) {\n            return share.name === 'content';\n          });\n\n          if (!mediaShare) {\n            call.logger.info('did not find media share, waiting for next locus change');\n            call.once('change:locus', findShare);\n            return;\n          }\n\n          call.logger.info('found media share');\n          resolve(mediaShare);\n        } catch (err) {\n          call.logger.error('something unexpected happened');\n          call.logger.error(err);\n          reject(err);\n        }\n      }\n\n      findShare();\n    });\n    return _promise2.default.race([promise, new _promise2.default(function (resolve, reject) {\n      return setTimeout(reject(new Error('Could not find media share after 10000ms')), 10000);\n    })]);\n  };\n}\n/**\n * Indicates of the specified locus is active\n * @param {Types~Locus} locus\n * @private\n * @returns {Boolean}\n */\n\n\nfunction isActive(locus) {\n  return locus.fullState.state === 'ACTIVE';\n}\n/**\n * Indicates if the specified locus represents a call (in other words, has\n * exactly two participants)\n * @param {Types~Locus} locus\n * @private\n * @returns {Boolean}\n */\n\n\nfunction isCall(locus) {\n  return locus && locus.fullState && locus.fullState.type === 'CALL';\n}\n/**\n * Indicates if the current user has joined the Locus\n * @param {Types~Locus} locus\n * @private\n * @returns {Boolean}\n */\n\n\nfunction joined(locus) {\n  return Boolean(locus.self && participantIsJoined(locus.self));\n}\n/**\n * Indicates if this device has joined the locus\n * @param {ProxyWebex} webex\n * @param {Types~Locus} locus\n * @private\n * @returns {Boolean}\n */\n\n\nfunction joinedOnThisDevice(webex, locus) {\n  return joined(locus) && locus.self.devices.some(function (device) {\n    return webex.internal.device.url === device.url && device.state === 'JOINED';\n  });\n}\n/**\n * Converts a list of participants to a list of memberships\n * @param {WebexCore} webex\n * @param {Types~Locus} locus\n * @private\n * @returns {Array<CallMembership>}\n */\n\n\nfunction participantsToCallMemberships(webex, locus) {\n  var users = new _map2.default();\n  var devices = new _map2.default();\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = (0, _getIterator3.default)(locus.participants), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var participant = _step.value;\n\n      if (participant.type === 'USER') {\n        users.set(participant.url, participant);\n      } else if (participant.type === 'RESOURCE_ROOM') {\n        devices.set(participant.url, participant);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var memberships = [];\n  users.forEach(function (participant) {\n    var membership = participantToCallMembership(webex, locus, participant);\n\n    if (participant.devices) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = (0, _getIterator3.default)(participant.devices), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var device = _step2.value;\n\n          if (device.state === 'JOINED' && (0, _get3.default)(device, 'intent.type') === 'OBSERVE') {\n            var deviceParticipant = devices.get(device.url);\n            membership.audioMuted = remoteAudioMuted(deviceParticipant);\n            membership.videoMuted = remoteVideoMuted(deviceParticipant);\n          } // Remove associated device from devices map\n\n\n          devices.delete(device.url);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    memberships.push(membership);\n  }); // Remaining devices are not associated with a user\n\n  devices.forEach(function (device) {\n    var membership = participantToCallMembership(webex, locus, device);\n    memberships.push(membership);\n  });\n  return memberships;\n}\n/**\n * Converts a single participant to a membership\n * @param {WebexCore} webex\n * @param {Types~Locus} locus\n * @param {Object} participant\n * @private\n * @returns {CallMembership}\n */\n\n\nfunction participantToCallMembership(webex, locus, participant) {\n  var personId = void 0,\n      personUuid = void 0;\n\n  if (!participant.person.isExternal) {\n    personUuid = participant.person.id;\n    personId = webex.people.inferPersonIdFromUuid(participant.person.id);\n  }\n\n  return {\n    _id: participant.id,\n    isSelf: locus.self.url === participant.url,\n    isInitiator: participant.isCreator || false,\n    personUuid: personUuid,\n    personId: personId,\n    state: participantStateToCallMembershipState(participant),\n    audioMuted: remoteAudioMuted(participant),\n    videoMuted: remoteVideoMuted(participant)\n  };\n}\n/**\n *\n * Maps participant details to membership state enum\n * @param {LocusParticipant} participant\n * @private\n * @returns {string}\n */\n\n\nfunction participantStateToCallMembershipState(participant) {\n  var state = participant.state && participant.state.toLowerCase();\n\n  switch (state) {\n    case 'idle':\n      return 'notified';\n\n    case 'joined':\n      return 'connected';\n\n    case 'left':\n      return 'disconnected';\n\n    default:\n      return state;\n  }\n}\n/**\n * Creates a unique identifier for a call (but not necessarily the \"callId\" that\n * we'll someday expose as a first-class property)\n *\n * @param {Object} locus\n * @private\n * @returns {string}\n */\n\n\nfunction makeInternalCallId(locus) {\n  return locus.url + '_' + locus.fullState.lastActive;\n}\n/**\n * Indicates the direction of the specified media type for the specified\n * participant\n * @param {string} mediaType\n * @param {Types~LocusParticipant} participant\n * @private\n * @returns {string} One of `sendonly`, `recvonly`, `sendrecv`, or `inactive`\n */\n\n\nfunction mediaDirection(mediaType, participant) {\n  if (!participant) {\n    return 'inactive';\n  }\n\n  if (!participant.status) {\n    return 'inactive';\n  }\n\n  return (participant.status[mediaType + 'Status'] || 'inactive').toLowerCase();\n}\n/**\n * Indicates if the specified participant has joined the Locus\n * @param {Types~LocusParticipant} participant\n * @private\n * @returns {Boolean}\n */\n\n\nfunction participantIsJoined(participant) {\n  return participant && participant.state === 'JOINED';\n}\n/**\n * Finds the party in the call that is not the current user\n * @param {Types~Locus} locus\n * @private\n * @returns {Types~LocusParticipant}\n */\n\n\nfunction remoteParticipant(locus) {\n  return remoteParticipants(locus)[0];\n}\n/**\n * Finds all participants of the Locus that are not the current user\n * @param {Types~Locus} locus\n * @private\n * @returns {Types~LocusParticipant}\n */\n\n\nfunction remoteParticipants(locus) {\n  return locus.participants.filter(function (participant) {\n    return participant.type === 'USER' && participant.url !== locus.self.url;\n  });\n}\n/**\n * Indicates if the remote party is sending audio\n * @param {Types~LocusParticipant} participant\n * @private\n * @returns {Boolean}\n */\n\n\nfunction remoteAudioMuted(participant) {\n  return participantIsJoined(participant) && !participant.status.audioStatus.includes('SEND');\n}\n/**\n * Indicates if the remote party is sending video\n * @param {Types~LocusParticipant} participant\n * @private\n * @returns {Boolean}\n */\n\n\nfunction remoteVideoMuted(participant) {\n  return participantIsJoined(participant) && !participant.status.videoStatus.includes('SEND');\n}\n/**\n * Indicates if the `call:incoming` event should be fired for the specified Locus\n * @param {Types~Locus} locus Event which delivered the Locus\n * @param {ProxyWebex} webex\n * @private\n * @returns {Boolean}\n */\n\n\nfunction shouldRing(locus) {\n  return (0, _get3.default)(locus, 'self.alertType.action') !== 'NONE';\n}\n/**\n * Determines the call state from a locus object\n * @param {Types~Locus} locus\n * @private\n * @returns {string}\n */\n\n\nfunction getState(locus) {\n  return locus && locus.fullState && locus.fullState.state.toLowerCase();\n} // there's really no good way to split getStatus() up that won't make it less readable\n\n/* eslint-disable complexity */\n\n/**\n * Determines the call state from a locus object. avoids the caching caused by\n * amp state because that leads to out-of-order updates\n * @param {ProxyWebex} webex\n * @param {Types~Locus} locus\n * @param {Types~Locus} previousLocus\n * @private\n * @returns {string}\n */\n\n\nfunction getStatus(webex, locus, previousLocus) {\n  if (locus) {\n    var remote = remoteParticipant(locus);\n\n    if (remote) {\n      if (joinedOnThisDevice(webex, locus) && remote && participantIsJoined(remote)) {\n        return 'connected';\n      }\n\n      if (locus.replaces) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = (0, _getIterator3.default)(locus.replaces), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var replaced = _step3.value;\n\n            if (replaced.locusUrl === previousLocus.url && replaced.lastActive === (0, _get3.default)(previousLocus, 'fullState.lastActive')) {\n              return 'replaced';\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      var local = locus.self;\n\n      if (remote.state === 'LEFT' || local.state === 'LEFT') {\n        return 'disconnected';\n      }\n\n      if (remote.state === 'DECLINED') {\n        return 'disconnected';\n      }\n\n      if (remote.state === 'NOTIFIED') {\n        return 'ringing';\n      }\n    }\n  }\n\n  return 'initiated';\n}\n/**\n * Finds the `self` entry for the specified locus\n * @param {ProxyWebex} webex\n * @param {Types~Locus} locus\n * @returns {Object}\n */\n\n\nfunction getThisDevice(webex, locus) {\n  return locus && locus.self && locus.self.devices.find(function (item) {\n    return item.url === webex.internal.device.url;\n  });\n}","map":null,"metadata":{},"sourceType":"script"}