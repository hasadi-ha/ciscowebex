{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _map = require('babel-runtime/core-js/map');\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _weakMap = require('babel-runtime/core-js/weak-map');\n\nvar _weakMap2 = _interopRequireDefault(_weakMap);\n\nvar _httpCore = require('@webex/http-core');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // contains the system time in milliseconds at which the retry after associated with a 429 expires\n// mapped by the API name, e.g.: idbroker.webex.com/doStuff would be mapped as 'doStuff'\n\n\nvar rateLimitExpiryTime = new _weakMap2.default(); // extracts the common identity API being called\n\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\nvar idBrokerRegex = /.*(idbroker|identity)(bts)?.webex.com\\/([^/]+)/;\n/**\n * @class\n */\n\nvar RateLimitInterceptor = function (_Interceptor) {\n  (0, _inherits3.default)(RateLimitInterceptor, _Interceptor);\n  (0, _createClass3.default)(RateLimitInterceptor, null, [{\n    key: 'create',\n\n    /**\n     * @returns {RateLimitInterceptor}\n     */\n    value: function create() {\n      return new RateLimitInterceptor({\n        spark: this\n      });\n    }\n    /**\n    * constructor\n    * @param {mixed} args\n    * @returns {Exception}\n    */\n\n  }]);\n\n  function RateLimitInterceptor() {\n    var _ref;\n\n    (0, _classCallCheck3.default)(this, RateLimitInterceptor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = RateLimitInterceptor.__proto__ || (0, _getPrototypeOf2.default)(RateLimitInterceptor)).call.apply(_ref, [this].concat(args)));\n\n    rateLimitExpiryTime.set(_this, new _map2.default());\n    return _this;\n  }\n  /**\n   * @see {@link Interceptor#onRequest}\n   * @param {Object} options\n   * @returns {Object}\n   */\n\n\n  (0, _createClass3.default)(RateLimitInterceptor, [{\n    key: 'onRequest',\n    value: function onRequest(options) {\n      if (this.isRateLimited(options.uri)) {\n        return _promise2.default.reject(new Error('API rate limited ' + options.uri));\n      }\n\n      return _promise2.default.resolve(options);\n    }\n    /**\n     * @see {@link Interceptor#onResponseError}\n     * @param {Object} options\n     * @param {Error} reason\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'onResponseError',\n    value: function onResponseError(options, reason) {\n      if (reason.statusCode === 429 && (options.uri.includes('idbroker') || options.uri.includes('identity'))) {\n        // set the retry after in the map, setting to milliseconds\n        this.setRateLimitExpiry(options.uri, this.extractRetryAfterTime(options));\n      }\n\n      return _promise2.default.reject(reason);\n    }\n    /**\n     * @param {object} options associated with the request\n     * @returns {number} retry after time in milliseconds\n     */\n\n  }, {\n    key: 'extractRetryAfterTime',\n    value: function extractRetryAfterTime(options) {\n      // 1S * 1K === 1MS\n      var milliMultiplier = 1000;\n      var retryAfter = options.headers['retry-after'] || null; // set 60 retry if no usable time defined\n\n      if (retryAfter === null || retryAfter <= 0) {\n        return 60 * milliMultiplier;\n      } // set max to 3600 S (1 hour) if greater than 1 hour\n\n\n      if (retryAfter > 3600) {\n        return 3600 * milliMultiplier;\n      }\n\n      return retryAfter * milliMultiplier;\n    }\n    /**\n     * Set the system time at which the rate limiting\n     * will expire in the rateLimitExpiryTime map.\n     * Assumes retryAfter is in milliseconds\n     * @param {string} uri API issuing the rate limiting\n     * @param {number} retryAfter milliseconds until rate limiting expires\n     * @returns {bool} true is value was successfully set\n     */\n\n  }, {\n    key: 'setRateLimitExpiry',\n    value: function setRateLimitExpiry(uri, retryAfter) {\n      var apiName = this.getApiName(uri);\n\n      if (!apiName) {\n        return false;\n      }\n\n      var currTimeMilli = new Date().getTime();\n      var expiry = currTimeMilli + retryAfter;\n      var dict = rateLimitExpiryTime.get(this);\n      return dict.set(apiName, expiry);\n    }\n    /**\n     * returns true if the API is currently rate limited\n     * @param {string} uri\n     * @returns {Boolean} indicates whether or not the API is rate currently rate limited\n     */\n\n  }, {\n    key: 'getRateLimitStatus',\n    value: function getRateLimitStatus(uri) {\n      var apiName = this.getApiName(uri);\n\n      if (!apiName) {\n        return false;\n      }\n\n      var currTimeMilli = new Date().getTime();\n      var dict = rateLimitExpiryTime.get(this);\n      var expiryTime = dict.get(apiName); // if no rate limit expiry has been registered in the map, return false.\n\n      if (expiryTime === undefined) {\n        return false;\n      } // return true, indicating rate limiting, if the system time is less than the expiry time\n\n\n      return currTimeMilli < dict.get(apiName);\n    }\n    /**\n     * split the URI and returns the API name of idBroker\n     * @param {string} uri\n     * @returns {string}\n     */\n\n  }, {\n    key: 'getApiName',\n    value: function getApiName(uri) {\n      if (!uri) {\n        return null;\n      }\n\n      var results = uri.match(idBrokerRegex);\n\n      if (!results) {\n        return null;\n      } // group 0 = full match of URL, group 1 = identity or idbroker base\n      // group 2 = api name\n\n\n      return results[2];\n    }\n    /**\n     * check URI against list of currently rate limited\n     * URIs, and determines if retry-after\n     * @param {String} uri pattern to check\n     * @returns {bool}\n     */\n\n  }, {\n    key: 'isRateLimited',\n    value: function isRateLimited(uri) {\n      // determine if the URI is associated with a common identity API\n      if (uri && (uri.includes('idbroker') || uri.includes('identity'))) {\n        return this.getRateLimitStatus(uri);\n      }\n\n      return false;\n    }\n  }]);\n  return RateLimitInterceptor;\n}(_httpCore.Interceptor);\n\nexports.default = RateLimitInterceptor;","map":null,"metadata":{},"sourceType":"script"}