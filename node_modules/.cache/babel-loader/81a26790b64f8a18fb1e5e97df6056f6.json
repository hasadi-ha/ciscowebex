{"ast":null,"code":"/*!\n * algorithms/pbes2.js - Password-Based Encryption (v2) Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar forge = require(\"../deps/forge.js\"),\n    util = require(\"../util\"),\n    helpers = require(\"./helpers.js\"),\n    CONSTANTS = require(\"./constants.js\"),\n    KW = require(\"./aes-kw.js\");\n\nvar NULL_BUFFER = new Buffer([0]);\n\nfunction fixSalt(hmac, kw, salt) {\n  var alg = \"PBES2-\" + hmac + \"+\" + kw;\n  var output = [new Buffer(alg, \"utf8\"), NULL_BUFFER, salt];\n  return Buffer.concat(output);\n}\n\nfunction pbkdf2Fn(hash) {\n  function prepareProps(props) {\n    props = props || {};\n    var keyLen = props.length || 0;\n    var salt = util.asBuffer(props.salt || new Buffer(0), \"base64u4l\"),\n        itrs = props.iterations || 0;\n\n    if (0 >= keyLen) {\n      throw new Error(\"invalid key length\");\n    }\n\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n\n    props.length = keyLen;\n    props.salt = salt;\n    props.iterations = itrs;\n    return props;\n  }\n\n  var fallback = function (key, props) {\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n    var promise = new Promise(function (resolve, reject) {\n      var md = forge.md[hash.replace(\"-\", \"\").toLowerCase()].create();\n\n      var cb = function (err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          dk = new Buffer(dk, \"binary\");\n          resolve(dk);\n        }\n      };\n\n      forge.pkcs5.pbkdf2(key.toString(\"binary\"), salt.toString(\"binary\"), itrs, keyLen, md, cb);\n    });\n    return promise;\n  };\n\n  var webcrypto = function (key, props) {\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n    var promise = Promise.resolve(key);\n    promise = promise.then(function (keyval) {\n      return helpers.subtleCrypto.importKey(\"raw\", keyval, \"PBKDF2\", false, [\"deriveBits\"]);\n    });\n    promise = promise.then(function (key) {\n      var mainAlgo = {\n        name: \"PBKDF2\",\n        salt: salt,\n        iterations: itrs,\n        hash: hash\n      };\n      return helpers.subtleCrypto.deriveBits(mainAlgo, key, keyLen * 8);\n    });\n    promise = promise.then(function (result) {\n      return util.asBuffer(result);\n    });\n    return promise;\n  };\n\n  var nodejs = function (key, props) {\n    if (6 > helpers.nodeCrypto.pbkdf2.length) {\n      throw new Error(\"unsupported algorithm: PBES2-\" + hmac + \"+\" + kw);\n    }\n\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n    var md = hash.replace(\"-\", \"\");\n    var promise = new Promise(function (resolve, reject) {\n      function cb(err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(dk);\n        }\n      }\n\n      helpers.nodeCrypto.pbkdf2(key, salt, itrs, keyLen, md, cb);\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction pbes2EncryptFN(hmac, kw) {\n  var keyLen = CONSTANTS.KEYLENGTH[kw] / 8;\n\n  var fallback = function (key, pdata, props) {\n    props = props || {};\n    var salt = util.asBuffer(props.p2s || new Buffer(0), \"base64url\"),\n        itrs = props.p2c || 0;\n\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n\n    if (8 > salt.length) {\n      throw new Error(\"salt too small\");\n    }\n\n    salt = fixSalt(hmac, kw, salt);\n    var promise; // STEP 1: derive shared key\n\n    promise = new Promise(function (resolve, reject) {\n      var md = forge.md[hmac.replace(\"HS\", \"SHA\").toLowerCase()].create();\n\n      var cb = function (err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          dk = new Buffer(dk, \"binary\");\n          resolve(dk);\n        }\n      };\n\n      forge.pkcs5.pbkdf2(key.toString(\"binary\"), salt.toString(\"binary\"), itrs, keyLen, md, cb);\n    }); // STEP 2: encrypt cek\n\n    promise = promise.then(function (dk) {\n      return KW[kw].encrypt(dk, pdata);\n    });\n    return promise;\n  };\n\n  var webcrypto = function (key, pdata, props) {\n    props = props || {};\n    var salt = util.asBuffer(props.p2s || new Buffer(0), \"base64url\"),\n        itrs = props.p2c || 0;\n\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n\n    if (8 > salt.length) {\n      throw new Error(\"salt too small\");\n    }\n\n    salt = fixSalt(hmac, kw, salt);\n    var promise; // STEP 1: derive shared key\n\n    var hash = hmac.replace(\"HS\", \"SHA-\");\n    promise = Promise.resolve(key);\n    promise = promise.then(function (keyval) {\n      return helpers.subtleCrypto.importKey(\"raw\", keyval, \"PBKDF2\", false, [\"deriveKey\"]);\n    });\n    promise = promise.then(function (key) {\n      var mainAlgo = {\n        name: \"PBKDF2\",\n        salt: salt,\n        iterations: itrs,\n        hash: hash\n      };\n      var deriveAlgo = {\n        name: \"AES-KW\",\n        length: keyLen * 8\n      };\n      return helpers.subtleCrypto.deriveKey(mainAlgo, key, deriveAlgo, true, [\"wrapKey\", \"unwrapKey\"]);\n    }); // STEP 2: encrypt cek\n\n    promise = promise.then(function (dk) {\n      // assume subtleCrypto for keywrap\n      return Promise.all([helpers.subtleCrypto.importKey(\"raw\", pdata, {\n        name: \"HMAC\",\n        hash: \"SHA-256\"\n      }, true, [\"sign\"]), dk]);\n    });\n    promise = promise.then(function (keys) {\n      return helpers.subtleCrypto.wrapKey(\"raw\", keys[0], // key\n      keys[1], // wrappingKey\n      \"AES-KW\");\n    });\n    promise = promise.then(function (result) {\n      result = new Buffer(result);\n      return {\n        data: result\n      };\n    });\n    return promise;\n  };\n\n  var nodejs = function (key, pdata, props) {\n    if (6 > helpers.nodeCrypto.pbkdf2.length) {\n      throw new Error(\"unsupported algorithm: PBES2-\" + hmac + \"+\" + kw);\n    }\n\n    props = props || {};\n    var salt = util.asBuffer(props.p2s || new Buffer(0), \"base64url\"),\n        itrs = props.p2c || 0;\n\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n\n    if (8 > salt.length) {\n      throw new Error(\"salt too small\");\n    }\n\n    salt = fixSalt(hmac, kw, salt);\n    var promise; // STEP 1: derive shared key\n\n    var hash = hmac.replace(\"HS\", \"SHA\");\n    promise = new Promise(function (resolve, reject) {\n      function cb(err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(dk);\n        }\n      }\n\n      helpers.nodeCrypto.pbkdf2(key, salt, itrs, keyLen, hash, cb);\n    }); // STEP 2: encrypt cek\n\n    promise = promise.then(function (dk) {\n      return KW[kw].encrypt(dk, pdata);\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction pbes2DecryptFN(hmac, kw) {\n  var keyLen = CONSTANTS.KEYLENGTH[kw] / 8;\n\n  var fallback = function (key, cdata, props) {\n    props = props || {};\n    var salt = util.asBuffer(props.p2s || new Buffer(0), \"base64url\"),\n        itrs = props.p2c || 0;\n\n    if (0 >= itrs) {\n      return Promise.reject(new Error(\"invalid iteration count\"));\n    }\n\n    if (8 > salt.length) {\n      return Promise.reject(new Error(\"salt too small\"));\n    }\n\n    salt = fixSalt(hmac, kw, salt);\n    var promise; // STEP 1: derived shared key\n\n    promise = new Promise(function (resolve, reject) {\n      var md = forge.md[hmac.replace(\"HS\", \"SHA\").toLowerCase()].create();\n\n      var cb = function (err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          dk = new Buffer(dk, \"binary\");\n          resolve(dk);\n        }\n      };\n\n      forge.pkcs5.pbkdf2(key.toString(\"binary\"), salt.toString(\"binary\"), itrs, keyLen, md, cb);\n    }); // STEP 2: decrypt cek\n\n    promise = promise.then(function (dk) {\n      return KW[kw].decrypt(dk, cdata);\n    });\n    return promise;\n  };\n\n  var webcrypto = function (key, cdata, props) {\n    props = props || {};\n    var salt = util.asBuffer(props.p2s || new Buffer(0), \"base64url\"),\n        itrs = props.p2c || 0;\n\n    if (0 >= itrs) {\n      return Promise.reject(new Error(\"invalid iteration count\"));\n    }\n\n    if (8 > salt.length) {\n      return Promise.reject(new Error(\"salt too small\"));\n    }\n\n    salt = fixSalt(hmac, kw, salt);\n    var hash = hmac.replace(\"HS\", \"SHA-\");\n    var promise;\n    promise = Promise.resolve(key);\n    promise = promise.then(function (keyval) {\n      return helpers.subtleCrypto.importKey(\"raw\", keyval, \"PBKDF2\", false, [\"deriveKey\"]);\n    });\n    promise = promise.then(function (key) {\n      var mainAlgo = {\n        name: \"PBKDF2\",\n        salt: salt,\n        iterations: itrs,\n        hash: hash\n      };\n      var deriveAlgo = {\n        name: \"AES-KW\",\n        length: keyLen * 8\n      };\n      return helpers.subtleCrypto.deriveKey(mainAlgo, key, deriveAlgo, true, [\"wrapKey\", \"unwrapKey\"]);\n    }); // STEP 2: decrypt cek\n\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.unwrapKey(\"raw\", cdata, key, \"AES-KW\", {\n        name: \"HMAC\",\n        hash: \"SHA-256\"\n      }, true, [\"sign\"]);\n    });\n    promise = promise.then(function (result) {\n      // unwrapped CryptoKey -- extract raw\n      return helpers.subtleCrypto.exportKey(\"raw\", result);\n    });\n    promise = promise.then(function (result) {\n      result = new Buffer(result);\n      return result;\n    });\n    return promise;\n  };\n\n  var nodejs = function (key, cdata, props) {\n    if (6 > helpers.nodeCrypto.pbkdf2.length) {\n      throw new Error(\"unsupported algorithm: PBES2-\" + hmac + \"+\" + kw);\n    }\n\n    props = props || {};\n    var salt = util.asBuffer(props.p2s || new Buffer(0), \"base64url\"),\n        itrs = props.p2c || 0;\n\n    if (0 >= itrs) {\n      return Promise.reject(new Error(\"invalid iteration count\"));\n    }\n\n    if (8 > salt.length) {\n      return Promise.reject(new Error(\"salt too small\"));\n    }\n\n    salt = fixSalt(hmac, kw, salt);\n    var promise; // STEP 1: derive shared key\n\n    var hash = hmac.replace(\"HS\", \"SHA\");\n    promise = new Promise(function (resolve, reject) {\n      function cb(err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(dk);\n        }\n      }\n\n      helpers.nodeCrypto.pbkdf2(key, salt, itrs, keyLen, hash, cb);\n    }); // STEP 2: decrypt cek\n\n    promise = promise.then(function (dk) {\n      return KW[kw].decrypt(dk, cdata);\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n} // ### Public API\n\n\nvar pbes2 = {}; // * [name].derive\n\n[\"PBKDF2-SHA-256\", \"PBKDF2-SHA-384\", \"PBKDF2-SHA-512\"].forEach(function (alg) {\n  var hash = alg.replace(\"PBKDF2-\", \"\");\n  pbes2[alg] = {\n    derive: pbkdf2Fn(hash)\n  };\n}); // [name].encrypt\n// [name].decrypt\n\n[\"PBES2-HS256+A128KW\", \"PBES2-HS384+A192KW\", \"PBES2-HS512+A256KW\"].forEach(function (alg) {\n  var parts = /PBES2-(HS\\d+)\\+(A\\d+KW)/g.exec(alg);\n  var hmac = parts[1],\n      kw = parts[2];\n  pbes2[alg] = {\n    encrypt: pbes2EncryptFN(hmac, kw),\n    decrypt: pbes2DecryptFN(hmac, kw)\n  };\n});\nmodule.exports = pbes2;","map":null,"metadata":{},"sourceType":"script"}