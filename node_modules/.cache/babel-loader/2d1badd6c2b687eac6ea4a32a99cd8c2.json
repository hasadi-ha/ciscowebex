{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');\n\nvar _deleteProperty2 = _interopRequireDefault(_deleteProperty);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _httpCore = require('@webex/http-core');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * @class\n */\n\n\nvar AuthInterceptor = function (_Interceptor) {\n  (0, _inherits3.default)(AuthInterceptor, _Interceptor);\n\n  function AuthInterceptor() {\n    (0, _classCallCheck3.default)(this, AuthInterceptor);\n    return (0, _possibleConstructorReturn3.default)(this, (AuthInterceptor.__proto__ || (0, _getPrototypeOf2.default)(AuthInterceptor)).apply(this, arguments));\n  }\n\n  (0, _createClass3.default)(AuthInterceptor, [{\n    key: 'onRequest',\n\n    /**\n     * @see {@link Interceptor#onRequest}\n     * @param {Object} options\n     * @returns {Object}\n     */\n    value: function onRequest(options) {\n      var _this2 = this;\n\n      options.headers = options.headers || {}; // If Authorizations is already set, don't overwrite it\n\n      if ('authorization' in options.headers || 'auth' in options) {\n        // If Authorization is set to null, false, or undefined, delete it to\n        // prevent a CORS preflight.\n        if (!options.headers.authorization) {\n          (0, _deleteProperty2.default)(options.headers, 'authorization');\n        }\n\n        return _promise2.default.resolve(options);\n      }\n\n      return this.requiresCredentials(options).then(function (requires) {\n        if (!requires) {\n          return options;\n        }\n\n        return _this2.spark.credentials.getUserToken().then(function (token) {\n          options.headers.authorization = token.toString();\n          return options;\n        });\n      });\n    }\n    /**\n     * Determines if the provided options object needs an auth header\n     * @param {Object} options\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: 'requiresCredentials',\n    value: function requiresCredentials(options) {\n      var _this3 = this;\n\n      if (options.uri && (options.uri.includes(this.spark.config.device.preDiscoveryServices.hydra) || options.uri.includes(this.spark.config.device.preDiscoveryServices.hydraServiceUrl))) {\n        return _promise2.default.resolve(true);\n      }\n\n      if (!this.spark.internal.device) {\n        return _promise2.default.resolve(false);\n      }\n\n      return this.spark.internal.device.isSpecificService('hydra', options.uri).then(function (isHydra) {\n        if (isHydra) {\n          return true;\n        }\n\n        if (options.service) {\n          return _this3.spark.internal.device.isService(options.service);\n        }\n\n        if (options.uri) {\n          // If service Url then return or else check if whitelisted\n          return _this3.spark.internal.device.isServiceUrl(options.uri).then(function (isServiceUrl) {\n            if (isServiceUrl) {\n              return true;\n            }\n\n            if (options.addAuthHeader === undefined && _this3.spark.config.device.validateDomains) {\n              options.addAuthHeader = true;\n            } // returns true if uri is in whitelistedServiceDomains and is requested\n\n\n            if (options.addAuthHeader) {\n              var matchingDomains = _this3.spark.config.device.whitelistedServiceDomains.filter(function (domain) {\n                return options.uri.includes(domain);\n              });\n\n              if (matchingDomains.length) {\n                return _promise2.default.resolve(true);\n              }\n            }\n\n            return false;\n          });\n        }\n\n        return false;\n      });\n    }\n    /**\n     * @see {@link Interceptor#onResponseError}\n     * @param {Object} options\n     * @param {Error} reason\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'onResponseError',\n    value: function onResponseError(options, reason) {\n      var _this4 = this;\n\n      return this.shouldAttemptReauth(reason, options).then(function (shouldAttemptReauth) {\n        if (shouldAttemptReauth) {\n          _this4.spark.logger.info('auth: received 401, attempting to reauthenticate');\n\n          if (reason.options.headers) {\n            (0, _deleteProperty2.default)(reason.options.headers, 'authorization');\n          }\n\n          if (_this4.spark.credentials.canRefresh) {\n            return _this4.spark.credentials.refresh().then(function () {\n              return _this4.replay(options);\n            });\n          }\n        }\n\n        return _promise2.default.reject(reason);\n      });\n    }\n    /**\n     * Replays the request\n     * @param {Object} options\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'replay',\n    value: function replay(options) {\n      if (options.replayCount) {\n        options.replayCount += 1;\n      } else {\n        options.replayCount = 1;\n      }\n\n      if (options.replayCount > this.spark.config.maxAuthenticationReplays) {\n        this.spark.logger.error('auth: failed after ' + this.spark.config.maxAuthenticationReplays + ' replay attempts');\n        return _promise2.default.reject(new Error('Failed after ' + this.spark.config.maxAuthenticationReplays + ' replay attempts'));\n      }\n\n      this.spark.logger.info('auth: replaying request ' + options.replayCount + ' time');\n      return this.spark.request(options);\n    }\n    /**\n     * Indicates whether or not the current request should refresh its access\n     * token in event of a 401\n     * @param {Error} reason\n     * @param {Object} options\n     * @returns {Promise<boolean>}\n     */\n\n  }, {\n    key: 'shouldAttemptReauth',\n    value: function shouldAttemptReauth(reason, options) {\n      if (options && options.shouldRefreshAccessToken === false) {\n        return _promise2.default.resolve(false);\n      }\n\n      if (reason.statusCode === 401) {\n        return _promise2.default.resolve(true);\n      }\n\n      return _promise2.default.resolve(false);\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * @returns {AuthInterceptor}\n     */\n    value: function create() {\n      return new AuthInterceptor({\n        spark: this\n      });\n    }\n  }]);\n  return AuthInterceptor;\n}(_httpCore.Interceptor);\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nexports.default = AuthInterceptor;","map":null,"metadata":{},"sourceType":"script"}