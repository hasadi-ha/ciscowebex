{"ast":null,"code":"/*!\n * jwk/octkey.js - Symmetric Octet Key Representation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar util = require(\"../util\");\n\nvar JWK = {\n  BaseKey: require(\"./basekey.js\"),\n  helpers: require(\"./helpers.js\")\n};\nvar SIG_ALGS = [\"HS256\", \"HS384\", \"HS512\"];\nvar ENC_ALGS = [\"A128GCM\", \"A192GCM\", \"A256GCM\", \"A128CBC-HS256\", \"A192CBC-HS384\", \"A256CBC-HS512\", \"A128CBC+HS256\", \"A192CBC+HS384\", \"A256CBC+HS512\"];\nvar WRAP_ALGS = [\"A128KW\", \"A192KW\", \"A256KW\", \"A128GCMKW\", \"A192GCMKW\", \"A256GCMKW\", \"PBES2-HS256+A128KW\", \"PBES2-HS384+A192KW\", \"PBES2-HS512+A256KW\", \"dir\"];\n\nfunction adjustDecryptProps(alg, props) {\n  if (\"iv\" in props) {\n    props.iv = Buffer.isBuffer(props.iv) ? props.iv : util.base64url.decode(props.iv || \"\");\n  }\n\n  if (\"adata\" in props) {\n    props.adata = Buffer.isBuffer(props.adata) ? props.adata : new Buffer(props.adata || \"\", \"utf8\");\n  }\n\n  if (\"mac\" in props) {\n    props.mac = Buffer.isBuffer(props.mac) ? props.mac : util.base64url.decode(props.mac || \"\");\n  }\n\n  if (\"tag\" in props) {\n    props.tag = Buffer.isBuffer(props.tag) ? props.tag : util.base64url.decode(props.tag || \"\");\n  }\n\n  return props;\n}\n\nfunction adjustEncryptProps(alg, props) {\n  if (\"iv\" in props) {\n    props.iv = Buffer.isBuffer(props.iv) ? props.iv : util.base64url.decode(props.iv || \"\");\n  }\n\n  if (\"adata\" in props) {\n    props.adata = Buffer.isBuffer(props.adata) ? props.adata : new Buffer(props.adata || \"\", \"utf8\");\n  }\n\n  return props;\n}\n\nvar JWKOctetCfg = {\n  publicKey: function (props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([]);\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n    return pk;\n  },\n  privateKey: function (props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([{\n      name: \"k\",\n      type: \"binary\"\n    }]);\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n\n    if (pk && pk.k) {\n      pk.length = pk.k.length * 8;\n    } else {\n      pk = undefined;\n    }\n\n    return pk;\n  },\n  thumbprint: function (json) {\n    if (json.private) {\n      json = json.private;\n    }\n\n    var fields;\n    fields = {\n      k: json.k || \"\",\n      kty: \"oct\"\n    };\n    return fields;\n  },\n  algorithms: function (keys, mode) {\n    var len = keys.private && keys.private.k.length * 8;\n    var mins = [256, 384, 512];\n\n    if (!len) {\n      return [];\n    }\n\n    switch (mode) {\n      case \"encrypt\":\n      case \"decrypt\":\n        return ENC_ALGS.filter(function (a) {\n          return a === \"A\" + len / 2 + \"CBC-HS\" + len || a === \"A\" + len / 2 + \"CBC+HS\" + len || a === \"A\" + len + \"GCM\";\n        });\n\n      case \"sign\":\n      case \"verify\":\n        // TODO: allow for HS{less-than-keysize}\n        return SIG_ALGS.filter(function (a) {\n          var result = false;\n          mins.forEach(function (m) {\n            if (m > len) {\n              return;\n            }\n\n            result = result | a === \"HS\" + m;\n          });\n          return result;\n        });\n\n      case \"wrap\":\n      case \"unwrap\":\n        return WRAP_ALGS.filter(function (a) {\n          return a === \"A\" + len + \"KW\" || a === \"A\" + len + \"GCMKW\" || a.indexOf(\"PBES2-\") === 0 || a === \"dir\";\n        });\n    }\n\n    return [];\n  },\n  encryptKey: function (alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  encryptProps: adjustEncryptProps,\n  decryptKey: function (alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  decryptProps: adjustDecryptProps,\n  wrapKey: function (alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  wrapProps: adjustEncryptProps,\n  unwrapKey: function (alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  unwrapProps: adjustDecryptProps,\n  signKey: function (alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  verifyKey: function (alg, keys) {\n    return keys.private && keys.private.k;\n  }\n}; // Factory\n\nvar JWKOctetFactory = {\n  kty: \"oct\",\n  prepare: function (props) {\n    // TODO: validate key properties\n    var cfg = JWKOctetCfg;\n    var p = Promise.resolve(props);\n    p = p.then(function (json) {\n      return JWK.helpers.thumbprint(cfg, json);\n    });\n    p = p.then(function (hash) {\n      var prints = {};\n      prints[JWK.helpers.INTERNALS.THUMBPRINT_HASH] = hash;\n      props[JWK.helpers.INTERNALS.THUMBPRINT_KEY] = prints;\n      return cfg;\n    });\n    return p;\n  },\n  generate: function (size) {\n    // TODO: validate key sizes\n    var key = util.randomBytes(size / 8);\n    return Promise.resolve({\n      k: key\n    });\n  }\n}; // public API\n\nmodule.exports = Object.freeze({\n  config: JWKOctetCfg,\n  factory: JWKOctetFactory\n}); // registration\n\n(function (REGISTRY) {\n  REGISTRY.register(JWKOctetFactory);\n})(require(\"./keystore\").registry);","map":null,"metadata":{},"sourceType":"script"}