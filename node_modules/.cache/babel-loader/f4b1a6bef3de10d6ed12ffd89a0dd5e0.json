{"ast":null,"code":"/*!\n * jws/verify.js - Verifies from a JWS\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar clone = require(\"lodash.clone\"),\n    merge = require(\"../util/merge\"),\n    base64url = require(\"../util/base64url\"),\n    AlgConfig = require(\"../util/algconfig\"),\n    JWK = require(\"../jwk\");\n\nvar DEFAULT_OPTIONS = {\n  algorithms: \"*\",\n  allowEmbeddedKey: false\n};\n/**\n * @class JWS.Verifier\n * @classdesc Parser of signed content.\n *\n * @description\n * **NOTE:** this class cannot be instantiated directly. Instead call {@link\n * JWS.createVerify}.\n */\n\nvar JWSVerifier = function (ks, globalOpts) {\n  var assumedKey, keystore;\n\n  if (JWK.isKey(ks)) {\n    assumedKey = ks;\n    keystore = assumedKey.keystore;\n  } else if (JWK.isKeyStore(ks)) {\n    keystore = ks;\n  } else {\n    keystore = JWK.createKeyStore();\n  }\n\n  globalOpts = merge(DEFAULT_OPTIONS, globalOpts);\n  Object.defineProperty(this, \"defaultKey\", {\n    value: assumedKey || undefined,\n    enumerable: true\n  });\n  Object.defineProperty(this, \"keystore\", {\n    value: keystore,\n    enumerable: true\n  });\n  Object.defineProperty(this, \"verify\", {\n    value: function (input, opts) {\n      opts = merge({}, globalOpts, opts || {});\n      var extraHandlers = opts.handlers || {};\n      var handlerKeys = Object.keys(extraHandlers);\n      var algSpec = new AlgConfig(opts.algorithms);\n\n      if (\"string\" === typeof input) {\n        input = input.split(\".\");\n        input = {\n          payload: input[1],\n          signatures: [{\n            protected: input[0],\n            signature: input[2]\n          }]\n        };\n      } else if (!input || \"object\" === input) {\n        throw new Error(\"invalid input\");\n      } // fixup \"flattened JSON\" to look like \"general JSON\"\n\n\n      if (input.signature) {\n        input.signatures = [{\n          protected: input.protected || undefined,\n          header: input.header || undefined,\n          signature: input.signature\n        }];\n      } // ensure signatories exists\n\n\n      var sigList = input.signatures || [{}]; // combine fields and decode signature per signatory\n\n      sigList = sigList.map(function (s) {\n        var header = clone(s.header || {});\n        var protect = s.protected ? JSON.parse(base64url.decode(s.protected, \"utf8\")) : {};\n        header = merge(header, protect);\n        var signature = base64url.decode(s.signature); // process allowed algorithims\n\n        if (!algSpec.match(header.alg)) {\n          return Promise.reject(new Error(\"Algorithm not allowed: \" + header.alg));\n        } // process \"crit\" first\n\n\n        var crit = protect.crit;\n\n        if (crit) {\n          if (!Array.isArray(crit)) {\n            return Promise.reject(new Error(\"Invalid 'crit' header\"));\n          }\n\n          for (var idx = 0; crit.length > idx; idx++) {\n            if (-1 === handlerKeys.indexOf(crit[idx])) {\n              return Promise.reject(new Error(\"Critical extension is not supported: \" + crit[idx]));\n            }\n          }\n        }\n\n        protect = Object.keys(protect);\n        return Promise.resolve({\n          protected: protect,\n          aad: s.protected || \"\",\n          header: header,\n          signature: signature\n        });\n      });\n      var promise = Promise.all(sigList);\n      promise = promise.then(function (sigList) {\n        return new Promise(function (resolve, reject) {\n          var processSig = function () {\n            var sig = sigList.shift();\n\n            if (!sig) {\n              reject(new Error(\"no key found\"));\n              return;\n            }\n\n            sig = merge({}, sig, {\n              payload: input.payload\n            });\n            var p = Promise.resolve(sig); // find the key\n\n            p = p.then(function (sig) {\n              var algKey; // TODO: resolve jku, x5c, x5u\n\n              if (opts.allowEmbeddedKey && sig.header.jwk) {\n                algKey = JWK.asKey(sig.header.jwk);\n              } else if (opts.allowEmbeddedKey && sig.header.x5c) {\n                algKey = sig.header.x5c[0];\n                algKey = new Buffer(algKey, \"base64\"); // TODO: callback to validate chain\n\n                algKey = JWK.asKey(algKey, \"pkix\");\n              } else {\n                algKey = Promise.resolve(assumedKey || keystore.get({\n                  use: \"sig\",\n                  alg: sig.header.alg,\n                  kid: sig.header.kid\n                }));\n              }\n\n              return algKey.then(function (k) {\n                if (!k) {\n                  return Promise.reject(new Error(\"key does not match\"));\n                }\n\n                sig.key = k;\n                return sig;\n              });\n            }); // process any prepare-verify handlers\n\n            p = p.then(function (sig) {\n              var processing = [];\n              handlerKeys.forEach(function (h) {\n                h = extraHandlers[h];\n                var p;\n\n                if (\"function\" === typeof h) {\n                  p = h(sig);\n                } else if (\"object\" === typeof h && \"function\" === typeof h.prepare) {\n                  p = h.prepare(sig);\n                }\n\n                if (p) {\n                  processing.push(Promise.resolve(p));\n                }\n              });\n              return Promise.all(processing).then(function () {\n                // don't actually care about individual handler results\n                // assume {sig} is updated\n                return sig;\n              });\n            }); // prepare verify inputs\n\n            p = p.then(function (sig) {\n              var aad = sig.aad || \"\",\n                  payload = sig.payload || \"\";\n              var content = new Buffer(1 + aad.length + payload.length),\n                  pos = 0;\n              content.write(aad, pos, \"ascii\");\n              pos += aad.length;\n              content.write(\".\", pos, \"ascii\");\n              pos++;\n\n              if (Buffer.isBuffer(payload)) {\n                payload.copy(content, pos);\n              } else {\n                content.write(payload, pos, \"binary\");\n              }\n\n              sig.content = content;\n              return sig;\n            });\n            p = p.then(function (sig) {\n              return sig.key.verify(sig.header.alg, sig.content, sig.signature);\n            });\n            p = p.then(function (result) {\n              var payload = sig.payload;\n              payload = base64url.decode(payload);\n              return {\n                protected: sig.protected,\n                header: sig.header,\n                payload: payload,\n                signature: result.mac,\n                key: sig.key\n              };\n            }); // process any post-verify handlers\n\n            p = p.then(function (jws) {\n              var processing = [];\n              handlerKeys.forEach(function (h) {\n                h = extraHandlers[h];\n                var p;\n\n                if (\"object\" === typeof h && \"function\" === typeof h.complete) {\n                  p = h.complete(jws);\n                }\n\n                if (p) {\n                  processing.push(Promise.resolve(p));\n                }\n              });\n              return Promise.all(processing).then(function () {\n                // don't actually care about individual handler results\n                // assume {jws} is updated\n                return jws;\n              });\n            });\n            p.then(resolve, processSig);\n          };\n\n          processSig();\n        });\n      });\n      return promise;\n    }\n  });\n};\n/**\n * @description\n * Creates a new JWS.Verifier with the given Key or KeyStore.\n *\n * @param {JWK.Key|JWK.KeyStore} ks The Key or KeyStore to use for verification.\n * @returns {JWS.Verifier} The new Verifier.\n */\n\n\nfunction createVerify(ks, opts) {\n  var vfy = new JWSVerifier(ks, opts);\n  return vfy;\n}\n\nmodule.exports = {\n  verifier: JWSVerifier,\n  createVerify: createVerify\n};","map":null,"metadata":{},"sourceType":"script"}