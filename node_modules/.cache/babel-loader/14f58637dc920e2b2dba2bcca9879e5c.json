{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transforms = undefined;\n\nvar _isInteger = require('babel-runtime/core-js/number/is-integer');\n\nvar _isInteger2 = _interopRequireDefault(_isInteger);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _curry2 = require('lodash/curry');\n\nvar _curry3 = _interopRequireDefault(_curry2);\n\nvar _capitalize2 = require('lodash/capitalize');\n\nvar _capitalize3 = _interopRequireDefault(_capitalize2);\n\nvar _camelCase2 = require('lodash/camelCase');\n\nvar _camelCase3 = _interopRequireDefault(_camelCase2);\n\nvar _toArray = require('./to-array');\n\nvar _toArray2 = _interopRequireDefault(_toArray);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar decryptTextProp = (0, _curry3.default)(function (name, ctx, key, object) {\n  return ctx.transform('decryptTextProp', name, key, object);\n}); // eslint-disable-next-line import/prefer-default-export\n\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\nvar transforms = exports.transforms = (0, _toArray2.default)('inbound', {\n  /**\n   * This function is used recursively to decrypt various properties on convesations, activities, etc\n   * @param   {Object} ctx    An object containg a spark instance and a transform\n   * @param   {String} key    KMS encryption key url\n   * @param   {Object} object Generic object that you want to decrypt some property on based on the type\n   * @returns {Promise}       Returns a transform promise\n   */\n  decryptObject: function decryptObject(ctx, key, object) {\n    if (!object) {\n      object = key; // eslint-disable-line no-param-reassign\n\n      key = undefined; // eslint-disable-line no-param-reassign\n    }\n\n    if (!object) {\n      return _promise2.default.resolve();\n    }\n\n    if (!object.objectType) {\n      return _promise2.default.resolve();\n    }\n\n    if (!key && object.encryptionKeyUrl) {\n      key = object.encryptionKeyUrl; // eslint-disable-line no-param-reassign\n    } // Transcoded content was not showing up on the activities since the\n    // decryptFile was not being called. Calling decryptFile for\n    // transcodedContent fixes the issue.\n\n\n    if (object.objectType === 'transcodedContent') {\n      return _promise2.default.all(object.files.items.map(function (item) {\n        return ctx.transform('decryptFile', key, item);\n      }));\n    }\n\n    return ctx.transform('decrypt' + (0, _capitalize3.default)(object.objectType), key, object);\n  },\n\n  /**\n   * Decrypts a given conversation and it's activites by building an array of promises that call\n   * decryptObject, which may then call other decrypt functions\n   *\n   * @param   {Object} ctx          An object containg a spark instance and a transform\n   * @param   {String} key          KMS encryption key url (or actual key?)\n   * @param   {Object} conversation A Webex Teams conversation object\n   * @returns {Promise}             Returns the result of Promise.all\n   */\n  decryptConversation: function decryptConversation(ctx, key, conversation) {\n    var promises = [];\n\n    if (conversation.activities.items) {\n      promises.push(_promise2.default.all(conversation.activities.items.map(function (item) {\n        return ctx.transform('decryptObject', null, item);\n      })));\n    }\n\n    var usableKey = conversation.encryptionKeyUrl || key;\n    var decryptionFailureMessage = ctx.spark.internal.conversation.config.decryptionFailureMessage;\n\n    if (usableKey) {\n      promises.push(ctx.transform('decryptPropDisplayName', usableKey, conversation).catch(function (error) {\n        ctx.spark.logger.warn('plugin-conversation: failed to decrypt display name of ', conversation.url, error);\n\n        _promise2.default.resolve(decryptionFailureMessage);\n      }));\n      promises.push(ctx.transform('decryptPropContent', usableKey, conversation));\n    }\n\n    if (conversation.avatarEncryptionKeyUrl) {\n      promises.push(ctx.transform('decryptObject', conversation.avatarEncryptionKeyUrl, conversation.avatar));\n    }\n\n    return _promise2.default.all(promises);\n  },\n\n  /**\n   * Decrypt an individual activity\n   * @param   {Object} ctx      An object containg a spark instance and a transform\n   * @param   {String} key      KMS encryption key url (or actual key?)\n   * @param   {Object} activity An instance of a Webex Teams activity\n   * @returns {Promise}         Returns a ctx.transform promise\n   */\n  decryptActivity: function decryptActivity(ctx, key, activity) {\n    if (!activity.encryptionKeyUrl && !(activity.object && activity.object.encryptionKeyUrl)) {\n      return _promise2.default.resolve(activity);\n    }\n\n    var keyUrl = activity.encryptionKeyUrl || activity.object.encryptionKeyUrl || key;\n    return ctx.transform('decryptObject', keyUrl, activity.object);\n  },\n\n  /**\n   * Decrypts a microappInstance (recording) model\n   * @param   {Object} ctx                     An object containing a spark instance and transform prop\n   * @param   {String} key                     KMS key\n   * @param   {Object} microappInstance        A microappInstance which includes several properties of a recording\n   * @param   {String} microappInstance.model  An encrypted string which decrypts to an object\n   * @returns {Promise}                        Returns a contex transform\n   */\n  decryptMicroappinstance: function decryptMicroappinstance(ctx, key, microappInstance) {\n    return ctx.transform('decryptPropModel', key, microappInstance);\n  },\n\n  /**\n  * Decrypts a comment...\n  * @param {Object} ctx An object containing a spark instance and transform prop\n  * @param {String} key KMS key\n  * @param {Object} comment A comment object with a displayName and content (encrypted)\n  * @returns {Promise} Returns the results of Promise.all on two transforms\n  */\n  decryptComment: function decryptComment(ctx, key, comment) {\n    var promises = [ctx.transform('decryptPropDisplayName', key, comment), ctx.transform('decryptPropContent', key, comment)];\n\n    if (comment.cards && Array.isArray(comment.cards)) {\n      comment.cards.map(function (item, index) {\n        return promises.push(ctx.transform('decryptPropCardItem', index, key, comment.cards));\n      });\n    }\n\n    return _promise2.default.all(promises);\n  },\n\n  /**\n   * Decrypts a content field\n   * @param   {Object} ctx            An object containing a spark instance and transform prop\n   * @param   {String} key            KMS key\n   * @param   {Object} content        An object with properties to be decrypted\n   * @returns {Promise}               A promise that will return when the decryption has finished\n   */\n  decryptContent: function decryptContent(ctx, key, content) {\n    if (content.contentCategory === 'links') {\n      return ctx.transform('decryptContentLinks', key, content);\n    }\n\n    return ctx.transform('decryptContentFiles', key, content);\n  },\n\n  /**\n   * Decrypts a content field which contains files and possibly links\n   * @param   {Object} ctx            An object containing a spark instance and transform prop\n   * @param   {String} key            KMS key\n   * @param   {Object} content        An object with properties to be decrypted\n   * @param   {Array}  content.files  An array of files to decrypt by calling decryptObject\n   * @param   {Array}  content.links  An array of links to decrypt by calling decryptObject\n   * @returns {Promise}               A promise that will return when the decryption has finished\n   */\n  decryptContentFiles: function decryptContentFiles(ctx, key, content) {\n    if (!content.files || !content.files.items || !Array.isArray(content.files.items)) {\n      return _promise2.default.resolve();\n    }\n\n    var promises = content.files.items.map(function (item) {\n      return ctx.transform('decryptObject', key, item);\n    });\n    promises.push(ctx.transform('decryptComment', key, content));\n\n    if (content.links && content.links.items && Array.isArray(content.links.items)) {\n      content.links.items.forEach(function (item) {\n        return promises.push(ctx.transform('decryptObject', key, item));\n      });\n    }\n\n    return _promise2.default.all(promises);\n  },\n\n  /**\n   * Decrypts a content field which contains links\n   * @param   {Object} ctx            An object containing a spark instance and transform prop\n   * @param   {String} key            KMS key\n   * @param   {Object} content        An object with properties to be decrypted\n   * @param   {Array}  content.links  An array of links to decrypt by calling decryptObject\n   * @returns {Promise}               A promise that will return when the decryption has finished\n   */\n  decryptContentLinks: function decryptContentLinks(ctx, key, content) {\n    if (!content.links || !content.links.items || !Array.isArray(content.links.items)) {\n      return _promise2.default.resolve();\n    }\n\n    var promises = content.links.items.map(function (item) {\n      return ctx.transform('decryptObject', key, item);\n    });\n    promises.push(ctx.transform('decryptComment', key, content));\n    return _promise2.default.all(promises);\n  },\n\n  /**\n   * Decrypts what may be a meeting event?\n   * @param   {Object} ctx   An object containing a spark instance and transform prop\n   * @param   {String} key   KMS key\n   * @param   {Object} event An object with a display name and location to be decrypted\n   * @returns {Promise}      Returns the result of Promise.all\n   */\n  decryptEvent: function decryptEvent(ctx, key, event) {\n    var promises = [ctx.transform('decryptPropDisplayName', key, event)];\n\n    if (event.location && event.location.split('.').length === 5) {\n      promises.push(ctx.transform('decryptPropLocation', key, event));\n    }\n\n    return _promise2.default.all(promises);\n  },\n\n  /**\n   * Decrypts a file and it's transcodedContents if they exist\n   * @param   {Object} ctx  An object containing a spark instance and transform prop\n   * @param   {String} key  KMS key\n   * @param   {Object} file A file object with file props an optional transcodedCollection to decrypt\n   * @returns {Promise}     Returns the result of Promise.all\n   */\n  decryptFile: function decryptFile(ctx, key, file) {\n    return _promise2.default.all([file.transcodedCollection && _promise2.default.all(file.transcodedCollection.items.map(function (item) {\n      return ctx.transform('decryptObject', key, item);\n    })), ctx.transform('decryptPropScr', key, file), ctx.transform('decryptPropDisplayName', key, file), ctx.transform('decryptPropContent', key, file), file.image && ctx.transform('decryptPropScr', key, file.image)]);\n  },\n\n  /**\n   * Decrypts a file and it's transcodedContents if they exist\n   * @param   {Object} ctx  An object containing a spark instance and transform prop\n   * @param   {String} key  KMS key\n   * @param   {Object} link A link object with a URL to decrypt\n   * @returns {Promise}     Returns the result of Promise.all\n   */\n  decryptLink: function decryptLink(ctx, key, link) {\n    return _promise2.default.all([ctx.transform('decryptPropSslr', key, link), ctx.transform('decryptPropDisplayName', key, link)]);\n  },\n\n  /**\n   * Decrypts transcoded file content. Calls decryptFile\n   * @param   {Object} ctx               An object containing a spark instance and transform prop\n   * @param   {String} key               KMS key\n   * @param   {Object} transcodedContent Transcoded content with a files prop\n   * @returns {Promise}                  Returns the result of Promise.all\n   */\n  decryptTranscodedContent: function decryptTranscodedContent(ctx, key, transcodedContent) {\n    return _promise2.default.all(transcodedContent.files.items.map(function (item) {\n      return ctx.transform('decryptFile', key, item);\n    }));\n  },\n\n  /**\n   * Decrypts an image uri\n   * @param   {Object} ctx       An object containing a spark instance and transform prop\n   * @param   {String} key       KMS key\n   * @param   {String} imageURI  URI of the image to decrypt\n   * @returns {Promise}          Returns a promise.\n   */\n  decryptImageURI: function decryptImageURI(ctx, key, imageURI) {\n    return ctx.transform('decryptPropLocation', key, imageURI);\n  },\n\n  /**\n   * The heart of most decryption logic ends here. Decrypting text.\n   * @param   {Object} ctx    An object containing a spark instance and transform prop\n   * @param   {String} name   Property of an object to be decrypted\n   * @param   {String} key    KMS key\n   * @param   {Object} object A generic object with text props to be decrypted\n   * @returns {Promise}       Returns a lonely Promise\n   */\n  decryptTextProp: function decryptTextProp(ctx, name, key, object) {\n    if (!object[name]) {\n      return _promise2.default.resolve();\n    }\n\n    var decryptionFailureMessage = ctx.spark.internal.conversation.config.decryptionFailureMessage;\n    return ctx.spark.internal.encryption.decryptText(key, object[name]).then(function (plaintext) {\n      if (ctx.spark.config.conversation.keepEncryptedProperties) {\n        var encryptedPropName = (0, _camelCase3.default)('encrypted_' + name);\n        object[encryptedPropName] = object[name]; // eslint-disable-line no-param-reassign\n      }\n\n      object[name] = plaintext; // eslint-disable-line no-param-reassign\n    }).catch(function (reason) {\n      ctx.spark.logger.warn('plugin-conversation: failed to decrypt ' + name + ' ', reason);\n      object[name] = decryptionFailureMessage; // eslint-disable-line no-param-reassign\n\n      return _promise2.default.resolve(decryptionFailureMessage);\n    });\n  },\n\n  /**\n  * Decrypting an element in an Array.\n  * @param {Object} ctx An object containing a spark instance and transform prop\n  * @param {Integer} index Property of an object to be decrypted\n  * @param {String} key KMS key\n  * @param {Array} array An array of Strings to be decrypted\n  * @returns {Promise} Returns a lonely Promise\n  */\n  decryptPropCardItem: function decryptPropCardItem(ctx, index, key, array) {\n    if (!(0, _isInteger2.default)(index) || !array || !Array.isArray(array) || index < 0 || index >= array.length || !(array[index] instanceof String || typeof array[index] === 'string')) {\n      return _promise2.default.resolve();\n    }\n\n    var decryptionFailureMessage = ctx.spark.internal.conversation.config.decryptionFailureMessage;\n    return ctx.spark.internal.encryption.decryptText(key, array[index]).then(function (plaintext) {\n      array[index] = plaintext; // eslint-disable-line no-param-reassign\n    }).catch(function (reason) {\n      ctx.spark.logger.warn('plugin-conversation: failed to decrypt card at ' + index + ' ', reason);\n      array[index] = decryptionFailureMessage; // eslint-disable-line no-param-reassign\n\n      return _promise2.default.resolve(decryptionFailureMessage);\n    });\n  },\n\n  /**\n   * Decrypts the src of an object (for images?)\n   * @param   {Object} ctx    An object containing a spark instance and transform prop\n   * @param   {String} key    KMS key\n   * @param   {Object} object An object with a scr property to be decrypted\n   * @returns {Promise}       Returns a promise\n   */\n  decryptPropScr: function decryptPropScr(ctx, key, object) {\n    return ctx.spark.internal.encryption.decryptScr(key, object.scr).then(function (scr) {\n      object.scr = scr; // eslint-disable-line no-param-reassign\n    });\n  },\n\n  /**\n   * Decrypts the sslr object\n   * @param   {Object} ctx    An object containing a spark instance and transform prop\n   * @param   {String} key    KMS key\n   * @param   {Object} object An object with a sslr property to be decrypted\n   * @returns {Promise}       Returns a promise\n   */\n  decryptPropSslr: function decryptPropSslr(ctx, key, object) {\n    return ctx.spark.internal.encryption.decryptScr(key, object.sslr).then(function (sslr) {\n      object.sslr = sslr; // eslint-disable-line no-param-reassign\n    });\n  },\n  decryptPropDisplayName: decryptTextProp('displayName'),\n  decryptPropContent: decryptTextProp('content'),\n  decryptPropModel: decryptTextProp('model'),\n  decryptPropLocation: decryptTextProp('location')\n});","map":null,"metadata":{},"sourceType":"script"}