{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _find2 = require('lodash/find');\n\nvar _find3 = _interopRequireDefault(_find2);\n\nvar _some2 = require('lodash/some');\n\nvar _some3 = _interopRequireDefault(_some2);\n\nvar _isObject2 = require('lodash/isObject');\n\nvar _isObject3 = _interopRequireDefault(_isObject2);\n\nvar _defaults2 = require('lodash/defaults');\n\nvar _defaults3 = _interopRequireDefault(_defaults2);\n\nvar _ampersandState = require('ampersand-state');\n\nvar _ampersandState2 = _interopRequireDefault(_ampersandState);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Represent a service parsed from wdm registration.serviceHostMap.serviceLinks and\n * registration.serviceHostMap.hostCatalog\n * @param {string} service service name from key of registration.serviceHostMap.serviceLinks\n * @param {string} defaultUrl Url provided in registration.serviceHostMap.serviceLinks\n * @param {Array<Host>} availableHosts Available datacenters from\n * registration.serviceHostMap.hostCatalog sorted by priority\n * @param {string} url Basically is the defaultUrl replaced with host provided in\n * the catalog\n * @class\n */\n\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar ServiceModel = _ampersandState2.default.extend({\n  /**\n    * @typedef {Object} Host - Represent a datacenter\n    * @property {int} priority - Closer to 0 is higher priority.\n    * @property {string} host - Host name.\n    * @property {boolean} failed - True when cannot connect to url.\n    */\n  props: {\n    service: 'string',\n    defaultUrl: 'string',\n    availableHosts: {\n      type: 'array',\n      default: function _default() {\n        return [];\n      }\n    }\n  },\n  session: {\n    currentHostIndex: {\n      type: 'number',\n      default: 0\n    }\n  },\n  derived: {\n    url: {\n      deps: ['defaultUrl', 'availableHosts', 'currentHostIndex'],\n      fn: function fn() {\n        if (this.availableHosts.length === 0) {\n          return this.defaultUrl;\n        }\n\n        var host = void 0;\n\n        if (this.currentHostIndex >= this.availableHosts.length) {\n          host = this.availableHosts[this.availableHosts.length - 1];\n        } else {\n          host = this.availableHosts[this.currentHostIndex];\n        }\n\n        return this._changeUrlHost(this.defaultUrl, host.host);\n      }\n    }\n  },\n  constructor: function constructor(attrs, options) {\n    options = options || {};\n    (0, _defaults3.default)(options, {\n      parse: true\n    });\n    return (0, _apply2.default)(_ampersandState2.default.prototype.constructor, this, [attrs, options]);\n  },\n  idAttribute: 'service',\n  // Override AmpersandState.serialize so we can return the latest url\n  serialize: function serialize() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var attrs = (0, _apply2.default)(_ampersandState2.default.prototype.serialize, this, args);\n    attrs.url = this.url;\n    return attrs;\n  },\n  // Override parse\n  parse: function parse(attrs) {\n    if (!attrs) {\n      return {};\n    }\n\n    if (attrs.availableHosts) {\n      // ensure highest priority is at the top\n      // using number value here instead boolean for IE and Edge\n      // https://github.com/tc39/ecma262/issues/902\n      attrs.availableHosts.sort(function (a, b) {\n        return a.priority - b.priority;\n      });\n    }\n\n    return attrs;\n  },\n  // Override set to make sure we always run parse()\n  // See https://github.com/AmpersandJS/ampersand-state/issues/146 for related\n  // bug\n  set: function set(key, value, options) {\n    var attrs = void 0; // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    // The next block is a direct copy from ampersand-state, so no need to test\n    // both scenarios.\n\n    /* istanbul ignore next */\n\n    if ((0, _isObject3.default)(key) || key === null) {\n      attrs = key;\n      options = value;\n    } else {\n      attrs = {};\n      attrs[key] = value;\n    }\n\n    attrs = this.parse(attrs, options);\n    return (0, _apply2.default)(_ampersandState2.default.prototype.set, this, [attrs, options]);\n  },\n\n  /**\n   * Mark the current host as failing or if a uri is provided, find the host\n   * and mark it as fail\n   * @param {string} uri Mark the host of this url as fail\n   * @returns {undefined}\n   */\n  markHostFailed: function markHostFailed(uri) {\n    var host = this.getCurrentHost();\n\n    if (uri) {\n      var urlObj = _url2.default.parse(uri);\n\n      host = (0, _find3.default)(this.availableHosts, function (h) {\n        return h.host === urlObj.host;\n      });\n    }\n\n    if (host) {\n      host.failed = true;\n    }\n  },\n\n  /**\n   * Return the next available host, which is usually the next higher priority\n   * host that has not yet been marked as failed\n   * @returns {Promise<Host>}\n   */\n  cycleNextHost: function cycleNextHost() {\n    for (var i = 0; i < this.availableHosts.length; i += 1) {\n      var host = this.availableHosts[i];\n\n      if (!host.failed && this.currentHostIndex !== i) {\n        this.currentHostIndex = i;\n        return _promise2.default.resolve(host);\n      }\n    } // this means all hosts have failed\n\n\n    this.currentHostIndex = 0;\n    return _promise2.default.reject(new Error('All hosts have failed for ' + this.service));\n  },\n\n  /**\n   * Check if a url comes from this service\n   * @param {string} uri\n   * @returns {Boolean}\n   */\n  doesUrlBelongToService: function doesUrlBelongToService(uri) {\n    var urlObj = _url2.default.parse(uri);\n\n    var hosts = this.availableHosts.map(function (h) {\n      return h.host;\n    });\n    hosts.push(_url2.default.parse(this.defaultUrl).host);\n    return (0, _some3.default)(hosts, function (host) {\n      return host === urlObj.host;\n    });\n  },\n\n  /**\n   * Return the current host/datacenter\n   * @returns {Host}\n   */\n  getCurrentHost: function getCurrentHost() {\n    return this.availableHosts[this.currentHostIndex];\n  },\n\n  /**\n   * Resets all host/datacenter for a retry\n   * @returns {undefined}\n   */\n  resetAllHosts: function resetAllHosts() {\n    this.availableHosts.forEach(function (host) {\n      host.failed = false;\n    });\n  },\n\n  /**\n   * Replace provided url by the current active host\n   * @param {string} uri\n   * @returns {string} uri\n   */\n  replaceUrlWithCurrentHost: function replaceUrlWithCurrentHost(uri) {\n    return this._changeUrlHost(uri, this.getCurrentHost().host);\n  },\n  _changeUrlHost: function _changeUrlHost(currentUrl, host) {\n    var urlObj = _url2.default.parse(currentUrl);\n\n    urlObj.host = host;\n    return _url2.default.format(urlObj);\n  }\n});\n\nexports.default = ServiceModel;","map":null,"metadata":{},"sourceType":"script"}