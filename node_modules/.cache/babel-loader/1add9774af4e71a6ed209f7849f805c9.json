{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');\n\nvar _deleteProperty2 = _interopRequireDefault(_deleteProperty);\n\nvar _isEmpty2 = require('lodash/isEmpty');\n\nvar _isEmpty3 = _interopRequireDefault(_isEmpty2);\n\nvar _isObject2 = require('lodash/isObject');\n\nvar _isObject3 = _interopRequireDefault(_isObject2);\n\nvar _cloneDeep2 = require('lodash/cloneDeep');\n\nvar _cloneDeep3 = _interopRequireDefault(_cloneDeep2);\n\nvar _clone2 = require('lodash/clone');\n\nvar _clone3 = _interopRequireDefault(_clone2);\n\nvar _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar _querystring = require('querystring');\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _common = require('@webex/common');\n\nvar _commonTimers = require('@webex/common-timers');\n\nvar _webexPlugin = require('../webex-plugin');\n\nvar _webexPlugin2 = _interopRequireDefault(_webexPlugin);\n\nvar _decorators = require('../storage/decorators');\n\nvar _grantErrors = require('./grant-errors');\n\nvar _grantErrors2 = _interopRequireDefault(_grantErrors);\n\nvar _scope = require('./scope');\n\nvar _token = require('./token');\n\nvar _token2 = _interopRequireDefault(_token);\n\nvar _tokenCollection = require('./token-collection');\n\nvar _tokenCollection2 = _interopRequireDefault(_tokenCollection);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n/**\n * @class\n */\n\n\nvar Credentials = _webexPlugin2.default.extend((_dec = (0, _common.oneFlight)({\n  keyFactory: function keyFactory(scope) {\n    return scope;\n  }\n}), _dec2 = (0, _decorators.waitForValue)('@'), _dec3 = (0, _decorators.persist)('@'), _dec4 = (0, _decorators.waitForValue)('@'), _dec5 = (0, _common.whileInFlight)('isRefreshing'), _dec6 = (0, _decorators.waitForValue)('@'), (_obj = {\n  collections: {\n    userTokens: _tokenCollection2.default\n  },\n  dataTypes: {\n    token: (0, _common.makeStateDataType)(_token2.default, 'token').dataType\n  },\n  derived: {\n    canAuthorize: {\n      deps: ['supertoken', 'supertoken.canAuthorize', 'canRefresh'],\n      fn: function fn() {\n        return Boolean(this.supertoken && this.supertoken.canAuthorize || this.canRefresh);\n      }\n    },\n    canRefresh: {\n      deps: ['supertoken', 'supertoken.canRefresh'],\n      fn: function fn() {\n        // If we're operating in JWT mode, we have to delegate to the consumer\n        if (this.config.jwtRefreshCallback) {\n          return true;\n        }\n\n        return Boolean(this.supertoken && this.supertoken.canRefresh);\n      }\n    }\n  },\n  props: {\n    supertoken: (0, _common.makeStateDataType)(_token2.default, 'token').prop\n  },\n  namespace: 'Credentials',\n  session: {\n    isRefreshing: {\n      default: false,\n      type: 'boolean'\n    },\n\n    /**\n     * Becomes `true` once the {@link loaded} event fires.\n     * @see {@link WebexPlugin#ready}\n     * @instance\n     * @memberof Credentials\n     * @type {boolean}\n     */\n    ready: {\n      default: false,\n      type: 'boolean'\n    },\n    refreshTimer: {\n      default: undefined,\n      type: 'any'\n    }\n  },\n\n  /**\n   * Generates an OAuth Login URL. Prefers the api.ciscospark.com proxy if the\n   * instance is initialize with an authorizatUrl, but fallsback to idbroker\n   * as the base otherwise.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {string}\n   */\n  buildLoginUrl: function buildLoginUrl() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      clientType: 'public'\n    };\n    /* eslint-disable camelcase */\n\n    if (options.state && !(0, _isObject3.default)(options.state)) {\n      throw new Error('if specified, `options.state` must be an object');\n    }\n\n    options.client_id = this.config.client_id;\n    options.redirect_uri = this.config.redirect_uri;\n    options.scope = this.config.scope;\n    options = (0, _cloneDeep3.default)(options);\n\n    if (!options.response_type) {\n      options.response_type = options.clientType === 'public' ? 'token' : 'code';\n    }\n\n    (0, _deleteProperty2.default)(options, 'clientType');\n\n    if (options.state) {\n      if (!(0, _isEmpty3.default)(options.state)) {\n        options.state = _common.base64.toBase64Url((0, _stringify2.default)(options.state));\n      } else {\n        delete options.state;\n      }\n    }\n\n    return this.config.authorizeUrl + '?' + _querystring2.default.stringify(options);\n    /* eslint-enable camelcase */\n  },\n\n  /**\n   * Generates a Logout URL\n   * @instance\n   * @memberof Credentials\n   * @param {Object} [options={}]\n   * @returns {[type]}\n   */\n  buildLogoutUrl: function buildLogoutUrl() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.config.logoutUrl + '?' + _querystring2.default.stringify((0, _assign2.default)({\n      cisService: this.config.service,\n      goto: this.config.redirect_uri\n    }, options));\n  },\n\n  /**\n   * Generates a number between 60% - 90% of expired value\n   * @instance\n   * @memberof Credentials\n   * @param {number} expiration\n   * @private\n   * @returns {number}\n   */\n  calcRefreshTimeout: function calcRefreshTimeout(expiration) {\n    return Math.floor((Math.floor(Math.random() * 4) + 6) / 10 * expiration);\n  },\n  constructor: function constructor() {\n    var _this = this; // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure\n    // function.\n\n\n    this._dataTypes = (0, _cloneDeep3.default)(this._dataTypes);\n    (0, _keys2.default)(this._dataTypes).forEach(function (key) {\n      if (_this._dataTypes[key].set) {\n        _this._dataTypes[key].set = _this._dataTypes[key].set.bind(_this);\n      }\n    }); // END HACK\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    (0, _apply2.default)(_webexPlugin2.default, this, args);\n  },\n\n  /**\n   * Downscopes a token\n   * @instance\n   * @memberof Credentials\n   * @param {string} scope\n   * @private\n   * @returns {Promise<Token>}\n   */\n  downscope: function downscope(scope) {\n    var _this2 = this;\n\n    return this.supertoken.downscope(scope).catch(function (reason) {\n      _this2.logger.trace('credentials: failed to downscope supertoken to ' + scope, reason);\n\n      _this2.logger.trace('credentials: falling back to supertoken for ' + scope);\n\n      return _promise2.default.resolve(new _token2.default((0, _assign2.default)({\n        scope: scope\n      }, _this2.supertoken.serialize())), {\n        parent: _this2\n      });\n    });\n  },\n\n  /**\n   * Requests a client credentials grant and returns the token. Given the\n   * limited use for such tokens as this time, this method does not cache its\n   * token.\n   * @instance\n   * @memberof Credentials\n   * @param {Object} options\n   * @returns {Promise<Token>}\n   */\n  getClientToken: function getClientToken() {\n    var _this3 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.info('credentials: requesting client credentials grant');\n    options = options || {};\n    options.scope = options.scope || 'webexsquare:admin';\n    return this.webex.request({\n      /* eslint-disable camelcase */\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      form: {\n        grant_type: 'client_credentials',\n        scope: options.scope,\n        self_contained_token: true\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n      /* eslint-enable camelcase */\n\n    }).then(function (res) {\n      return new _token2.default(res.body, {\n        parent: _this3\n      });\n    }).catch(function (res) {\n      if (res.statusCode !== 400) {\n        return _promise2.default.reject(res);\n      }\n\n      var ErrorConstructor = _grantErrors2.default.select(res.body.error);\n\n      return _promise2.default.reject(new ErrorConstructor(res._res || res));\n    });\n  },\n\n  /**\n   * Resolves with a token with the specified scopes. If no scope is specified,\n   * defaults to omit(webex.credentials.scope, 'spark:kms'). If no such token is\n   * available, downscopes the supertoken to that scope.\n   * @instance\n   * @memberof Credentials\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  getUserToken: function getUserToken(scope) {\n    var _this4 = this;\n\n    return _promise2.default.resolve(!this.isRefreshing || new _promise2.default(function (resolve) {\n      _this4.logger.info('credentials: token refresh inflight; delaying getUserToken until refresh completes');\n\n      _this4.once('change:isRefreshing', function () {\n        _this4.logger.info('credentials: token refresh complete; reinvoking getUserToken');\n\n        resolve();\n      });\n    })).then(function () {\n      if (!_this4.canAuthorize) {\n        _this4.logger.info('credentials: cannot produce an access token from current state');\n\n        return _promise2.default.reject(new Error('Current state cannot produce an access token'));\n      }\n\n      if (!scope) {\n        scope = (0, _scope.filterScope)('spark:kms', _this4.config.scope);\n      }\n\n      scope = (0, _scope.sortScope)(scope);\n\n      if (scope === (0, _scope.sortScope)(_this4.config.scope)) {\n        return _promise2.default.resolve(_this4.supertoken);\n      }\n\n      var token = _this4.userTokens.get(scope); // we should also check for the token.access_token since token object does\n      // not get cleared on unsetting while logging out.\n\n\n      if (!token || !token.access_token) {\n        return _this4.downscope(scope).then((0, _common.tap)(function (t) {\n          return _this4.userTokens.add(t);\n        }));\n      }\n\n      return _promise2.default.resolve(token);\n    });\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Credentials\n   * @param {Object} attrs\n   * @param {Object} options\n   * @private\n   * @returns {Credentials}\n   */\n  initialize: function initialize(attrs, options) {\n    var _this5 = this;\n\n    if (attrs) {\n      if (typeof attrs === 'string') {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.access_token) {\n        this.supertoken = attrs;\n      }\n\n      if (attrs.authorization) {\n        if (attrs.authorization.supertoken) {\n          this.supertoken = attrs.authorization.supertoken;\n        } else {\n          this.supertoken = attrs.authorization;\n        }\n      } // schedule refresh\n\n\n      if (this.supertoken && this.supertoken.expires) {\n        this.scheduleRefresh(this.supertoken.expires);\n      }\n    }\n\n    (0, _apply2.default)(_webexPlugin2.default.prototype.initialize, this, [attrs, options]);\n    this.listenToOnce(this.parent, 'change:config', function () {\n      if (_this5.config.authorizationString) {\n        var parsed = _url2.default.parse(_this5.config.authorizationString, true);\n        /* eslint-disable camelcase */\n\n\n        _this5.config.client_id = parsed.query.client_id;\n        _this5.config.redirect_uri = parsed.query.redirect_uri;\n        _this5.config.scope = parsed.query.scope;\n        _this5.config.authorizeUrl = parsed.href.substr(0, parsed.href.indexOf('?'));\n        /* eslint-enable camelcase */\n      }\n    });\n    this.webex.once('loaded', function () {\n      _this5.ready = true;\n    });\n  },\n\n  /**\n   * Clears all tokens from store them from the stores.\n   *\n   * This is no longer quite the right name for this method, but all of the\n   * alternatives I'm coming up with are already taken.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  invalidate: function invalidate() {\n    this.logger.info('credentials: invalidating tokens'); // clear refresh timer\n\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.unset('refreshTimer');\n    }\n\n    try {\n      this.unset('supertoken');\n    } catch (err) {\n      this.logger.warn('credentials: failed to clear supertoken', err);\n    }\n\n    while (this.userTokens.models.length) {\n      try {\n        this.userTokens.remove(this.userTokens.models[0]);\n      } catch (err) {\n        this.logger.warn('credentials: failed to remove user token', err);\n      }\n    }\n\n    this.logger.info('credentials: finished removing tokens'); // Return a promise to give the storage layer a tick or two to clear\n    // localStorage\n\n    return _promise2.default.resolve();\n  },\n\n  /**\n   * Removes the supertoken and child tokens, then refreshes the supertoken;\n   * subsequent calls to {@link Credentials#getUserToken()} will re-downscope\n   * child tokens. Enqueus revocation of previous previousTokens. Yes, that's\n   * the correct number of \"previous\"es.\n   * @instance\n   * @memberof Credentials\n   * @returns {Promise}\n   */\n  refresh: function refresh() {\n    var _this6 = this;\n\n    this.logger.info('credentials: refresh requested');\n    var supertoken = this.supertoken;\n    var tokens = (0, _clone3.default)(this.userTokens.models); // This is kind of a leaky abstraction, since it relies on the authorization\n    // plugin, but the only alternatives I see are\n    // 1. put all JWT support in core\n    // 2. have separate jwt and non-jwt auth plugins\n    // while I like #2 from a code simplicity standpoint, the third-party DX\n    // isn't great\n\n    if (this.config.jwtRefreshCallback) {\n      return this.config.jwtRefreshCallback(this.webex).then(function (jwt) {\n        return _this6.webex.authorization.requestAccessTokenFromJwt({\n          jwt: jwt\n        });\n      });\n    }\n\n    return supertoken.refresh().then(function (st) {\n      // clear refresh timer\n      if (_this6.refreshTimer) {\n        clearTimeout(_this6.refreshTimer);\n\n        _this6.unset('refreshTimer');\n      }\n\n      _this6.supertoken = st;\n      return _promise2.default.all(tokens.map(function (token) {\n        return _this6.downscope(token.scope) // eslint-disable-next-line max-nested-callbacks\n        .then(function (t) {\n          _this6.logger.info('credentials: revoking token for ' + token.scope);\n\n          return token.revoke().catch(function (err) {\n            _this6.logger.warn('credentials: failed to revoke user token', err);\n          }).then(function () {\n            _this6.userTokens.remove(token.scope);\n\n            _this6.userTokens.add(t);\n          });\n        });\n      }));\n    }).then(function () {\n      _this6.scheduleRefresh(_this6.supertoken.expires);\n    }).catch(function (error) {\n      var InvalidRequestError = _grantErrors2.default.InvalidRequestError;\n\n      if (error instanceof InvalidRequestError) {\n        // Error: The refresh token provided is expired, revoked, malformed, or invalid. Hence emit an event to the client, an opportunity to logout.\n        _this6.unset('supertoken');\n\n        while (_this6.userTokens.models.length) {\n          try {\n            _this6.userTokens.remove(_this6.userTokens.models[0]);\n          } catch (err) {\n            _this6.logger.warn('credentials: failed to remove user token', err);\n          }\n        }\n\n        _this6.webex.trigger('client:InvalidRequestError');\n      }\n\n      return _promise2.default.reject(error);\n    });\n  },\n\n  /**\n   * Schedules a token refresh or refreshes the token if token has expired\n   * @instance\n   * @memberof Credentials\n   * @param {number} expires\n   * @private\n   * @returns {undefined}\n   */\n  scheduleRefresh: function scheduleRefresh(expires) {\n    var _this7 = this;\n\n    var expiresIn = expires - Date.now();\n\n    if (expiresIn > 0) {\n      var timeoutLength = this.calcRefreshTimeout(expiresIn);\n      this.refreshTimer = (0, _commonTimers.safeSetTimeout)(function () {\n        return _this7.refresh();\n      }, timeoutLength);\n    } else {\n      this.refresh();\n    }\n  },\n  version: '1.69.1'\n}, (_applyDecoratedDescriptor(_obj, 'getUserToken', [_dec, _dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'getUserToken'), _obj), _applyDecoratedDescriptor(_obj, 'initialize', [_dec3], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initialize'), _obj), _applyDecoratedDescriptor(_obj, 'invalidate', [_common.oneFlight, _dec4], (0, _getOwnPropertyDescriptor2.default)(_obj, 'invalidate'), _obj), _applyDecoratedDescriptor(_obj, 'refresh', [_common.oneFlight, _dec5, _dec6], (0, _getOwnPropertyDescriptor2.default)(_obj, 'refresh'), _obj)), _obj)));\n\nexports.default = Credentials;","map":null,"metadata":{},"sourceType":"script"}