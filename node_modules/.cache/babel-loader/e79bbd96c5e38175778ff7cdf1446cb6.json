{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _map = require('babel-runtime/core-js/map');\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _weakMap = require('babel-runtime/core-js/weak-map');\n\nvar _weakMap2 = _interopRequireDefault(_weakMap);\n\nvar _wrap2 = require('lodash/wrap');\n\nvar _wrap3 = _interopRequireDefault(_wrap2);\n\nexports.default = oneFlight;\n\nvar _templateContainer = require('./template-container');\n\nvar _templateContainer2 = _interopRequireDefault(_templateContainer);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Alias Map and WeakMap to get around a babel compiler bug\n\n\nvar W = _weakMap2.default;\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\nvar M = _map2.default;\nvar WeakMappedMappedMap = (0, _templateContainer2.default)(W, M, M);\nvar flights = new WeakMappedMappedMap();\n/**\n * @memberof Util\n * @param {Object} options\n * @param {Function} options.keyFactory\n * @param {boolean} options.cacheFailures\n * @param {boolean} options.cacheSuccesses\n * @returns {Function}\n */\n\nfunction oneFlight() {\n  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {\n    params[_key] = arguments[_key];\n  }\n\n  if (params.length === 3) {\n    return (0, _apply2.default)(oneFlightDecorator, null, params);\n  }\n\n  var options = params[0] || {};\n  var cacheFailures = options.cacheFailures,\n      cacheSuccesses = options.cacheSuccesses,\n      keyFactory = options.keyFactory;\n  return oneFlightDecorator;\n  /**\n   * @param {Object} target\n   * @param {string} prop\n   * @param {Object} descriptor\n   * @private\n   * @returns {Object}\n   */\n\n  function oneFlightDecorator(target, prop, descriptor) {\n    var key = prop;\n    descriptor.value = (0, _wrap3.default)(descriptor.value, function oneFlightExecutor(fn) {\n      var _this = this;\n\n      var innerKey = key;\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      if (keyFactory) {\n        innerKey = innerKey + '_' + keyFactory.apply(undefined, args);\n      }\n      /* eslint no-invalid-this: [0] */\n\n\n      var flight = flights.get(this, target, innerKey);\n\n      if (flight) {\n        return flight;\n      }\n\n      flight = (0, _apply2.default)(fn, this, args);\n\n      if (!cacheFailures && flight && flight.catch) {\n        flight = flight.catch(function (reason) {\n          flights.delete(_this, target, innerKey);\n          return _promise2.default.reject(reason);\n        });\n      }\n\n      if (!cacheSuccesses && flight && flight.then) {\n        flight = flight.then(function (result) {\n          flights.delete(_this, target, innerKey);\n          return result;\n        });\n      }\n\n      flights.set(this, target, innerKey, flight);\n      return flight;\n    }); // This *should* make decorators compatible with AmpersandState class\n    // definitions\n\n    if ((typeof target === 'undefined' ? 'undefined' : (0, _typeof3.default)(target)) === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    return descriptor;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}