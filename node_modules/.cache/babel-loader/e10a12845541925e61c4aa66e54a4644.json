{"ast":null,"code":"/*!\n * algorithms/concat.js - Concat Key Derivation\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar CONSTANTS = require(\"./constants.js\"),\n    sha = require(\"./sha.js\");\n\nfunction concatDeriveFn(name) {\n  name = name.replace(\"CONCAT-\", \"\"); // NOTE: no nodejs/webcrypto/fallback model, since ConcatKDF is\n  //       implemented using the SHA algorithms\n\n  var fn = function (key, props) {\n    props = props || {};\n    var keyLen = props.length,\n        hashLen = CONSTANTS.HASHLENGTH[name];\n\n    if (!keyLen) {\n      return Promise.reject(new Error(\"invalid key length\"));\n    } // setup otherInfo\n\n\n    if (!props.otherInfo) {\n      return Promise.reject(new Error(\"invalid otherInfo\"));\n    }\n\n    var otherInfo = props.otherInfo;\n    var op = sha[name].digest;\n    var N = Math.ceil(keyLen / hashLen),\n        idx = 0,\n        okm = [];\n\n    function step() {\n      if (N === idx++) {\n        return Buffer.concat(okm).slice(0, keyLen);\n      }\n\n      var T = new Buffer(4 + key.length + otherInfo.length);\n      T.writeUInt32BE(idx, 0);\n      key.copy(T, 4);\n      otherInfo.copy(T, 4 + key.length);\n      return op(T).then(function (result) {\n        okm.push(result);\n        return step();\n      });\n    }\n\n    return step();\n  };\n\n  return fn;\n} // Public API\n// * [name].derive\n\n\nvar concat = {};\n[\"CONCAT-SHA-1\", \"CONCAT-SHA-256\", \"CONCAT-SHA-384\", \"CONCAT-SHA-512\"].forEach(function (name) {\n  concat[name] = {\n    derive: concatDeriveFn(name)\n  };\n});\nmodule.exports = concat;","map":null,"metadata":{},"sourceType":"script"}