{"ast":null,"code":"/*!\n * algorithms/ecdsa.js - Elliptic Curve Digitial Signature Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar ecUtil = require(\"./ec-util.js\"),\n    helpers = require(\"./helpers.js\"),\n    sha = require(\"./sha.js\");\n\nfunction idealCurve(hash) {\n  switch (hash) {\n    case \"SHA-256\":\n      return \"P-256\";\n\n    case \"SHA-384\":\n      return \"P-384\";\n\n    case \"SHA-512\":\n      return \"P-521\";\n\n    default:\n      throw new Error(\"unsupported hash: \" + hash);\n  }\n}\n\nfunction ecdsaSignFN(hash) {\n  var curve = idealCurve(hash); // ### Fallback implementation -- uses forge\n\n  var fallback = function (key, pdata\n  /*, props */\n  ) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n\n    var pk = ecUtil.convertToForge(key, false);\n    var promise; // generate hash\n\n    promise = sha[hash].digest(pdata); // sign hash\n\n    promise = promise.then(function (result) {\n      result = pk.sign(result);\n      result = Buffer.concat([result.r, result.s]);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  }; // ### WebCrypto API implementation\n\n\n  var webcrypto = function (key, pdata\n  /*, props */\n  ) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n\n    var pk = ecUtil.convertToJWK(key, false);\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\", pk, alg, true, [\"sign\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function (result) {\n      result = new Buffer(result);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(null, webcrypto, fallback);\n}\n\nfunction ecdsaVerifyFN(hash) {\n  var curve = idealCurve(hash); // ### Fallback implementation -- uses forge\n\n  var fallback = function (key, pdata, mac\n  /*, props */\n  ) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n\n    var pk = ecUtil.convertToForge(key, true);\n    var promise; // generate hash\n\n    promise = sha[hash].digest(pdata); // verify hash\n\n    promise = promise.then(function (result) {\n      var len = mac.length / 2;\n      var rs = {\n        r: mac.slice(0, len),\n        s: mac.slice(len)\n      };\n\n      if (!pk.verify(result, rs)) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  }; // ### WebCrypto API implementation\n\n\n  var webcrypto = function (key, pdata, mac\n  /* , props */\n  ) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n\n    var pk = ecUtil.convertToJWK(key, true);\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\", pk, alg, true, [\"verify\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function (result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(null, webcrypto, fallback);\n} // ### Public API\n\n\nvar ecdsa = {}; // * [name].sign\n// * [name].verify\n\n[\"ES256\", \"ES384\", \"ES512\"].forEach(function (name) {\n  var hash = name.replace(/ES(\\d+)/g, function (m, size) {\n    return \"SHA-\" + size;\n  });\n  ecdsa[name] = {\n    sign: ecdsaSignFN(hash),\n    verify: ecdsaVerifyFN(hash)\n  };\n});\nmodule.exports = ecdsa;","map":null,"metadata":{},"sourceType":"script"}