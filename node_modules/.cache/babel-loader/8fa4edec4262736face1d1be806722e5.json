{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _wrap2 = require('lodash/wrap');\n\nvar _wrap3 = _interopRequireDefault(_wrap2);\n\nvar _get2 = require('lodash/get');\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _find2 = require('lodash/find');\n\nvar _find3 = _interopRequireDefault(_find2);\n\nvar _defaults2 = require('lodash/defaults');\n\nvar _defaults3 = _interopRequireDefault(_defaults2);\n\nvar _dec, _dec2, _dec3, _dec4, _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint-env browser: true */\n\n\nvar _lodashDecorators = require('lodash-decorators');\n\nvar _sdpTransform = require('sdp-transform');\n\nvar _uuid = require('uuid');\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _common = require('@webex/common');\n\nvar _internalPluginLocus = require('@webex/internal-plugin-locus');\n\nvar _mediaEngineWebrtc = require('@webex/media-engine-webrtc');\n\nvar _mediaEngineWebrtc2 = _interopRequireDefault(_mediaEngineWebrtc);\n\nvar _stateParsers = require('./state-parsers');\n\nvar _boolToStatus = require('./bool-to-status');\n\nvar _boolToStatus2 = _interopRequireDefault(_boolToStatus);\n\nvar _callMemberships = require('./call-memberships');\n\nvar _callMemberships2 = _interopRequireDefault(_callMemberships);\n\nvar _filter = require('./stats/filter');\n\nvar _filter2 = _interopRequireDefault(_filter);\n\nvar _stream = require('./stats/stream');\n\nvar _stream2 = _interopRequireDefault(_stream);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nvar boolToDirection = _mediaEngineWebrtc.webrtcHelpers.boolToDirection;\nvar deprecatedCallEventNames = ['ringing', 'connected', 'disconnected', 'replaced'];\n/**\n * Pulls the direction line for the specified media kind from an sdp\n * @param {string} kind\n * @param {string} sdp\n * @private\n * @returns {string}\n */\n\nfunction getMediaDirectionFromSDP(kind, sdp) {\n  var parsed = typeof sdp === 'string' ? (0, _sdpTransform.parse)(sdp) : sdp;\n  var media = void 0;\n\n  if (kind === 'screen') {\n    media = parsed.media.find(function (m) {\n      return m.type === 'video' && m.content;\n    });\n  } else {\n    media = parsed.media.find(function (m) {\n      return m.type === kind;\n    });\n  }\n\n  if (!media || !media.direction) {\n    return 'inactive';\n  }\n\n  return media.direction;\n}\n/**\n * Reverses a media direction from offer to answer (e.g. sendonly -> recvonly)\n * @param {string} dir\n * @private\n * @returns {string}\n */\n\n\nfunction reverseMediaDirection(dir) {\n  switch (dir) {\n    case 'inactive':\n    case 'sendrecv':\n      return dir;\n\n    case 'sendonly':\n      return 'recvonly';\n\n    case 'recvonly':\n      return 'sendonly';\n\n    default:\n      throw new Error('direction \"' + dir + '\" is not valid');\n  }\n}\n\nvar capitalize = {\n  audio: 'Audio',\n  video: 'Video'\n};\n/**\n * @event ringing\n * @instance\n * @memberof Call\n * @deprecated with {@link PhoneConfig.enableExperimentalGroupCallingSupport}\n * enabled; instead, listen for {@link Call.membership:notified}\n */\n\n/**\n * @event connected\n * @instance\n * @memberof Call\n * @deprecated with {@link PhoneConfig.enableExperimentalGroupCallingSupport}\n * enabled; instead, listen for {@link Call.active}\n */\n\n/**\n * @event disconnected\n * @instance\n * @memberof Call\n * @deprecated with {@link PhoneConfig.enableExperimentalGroupCallingSupport}\n * enabled; instead, listen for {@link Call.inactive}\n */\n\n/**\n * @event active\n * @instance\n * @memberof Call\n * @description only emitted if enableExperimentalGroupCallingSupport is enabled\n */\n\n/**\n * @event initializing\n * @instance\n * @memberof Call\n * @description only emitted if enableExperimentalGroupCallingSupport is enabled\n */\n\n/**\n * @event inactive\n * @instance\n * @memberof Call\n * @description only emitted if enableExperimentalGroupCallingSupport is enabled\n */\n\n/**\n * @event terminating\n * @instance\n * @memberof Call\n * @description only emitted if enableExperimentalGroupCallingSupport is enabled\n */\n\n/**\n * @event localMediaStream:change\n * @instance\n * @memberof Call\n */\n\n/**\n * @event remoteMediaStream:change\n * @instance\n * @memberof Call\n */\n\n/**\n * @event error\n * @instance\n * @memberof Call\n */\n\n/**\n * @event membership:notified\n * @instance\n * @memberof Call\n * @type {CallMembership}\n * @description This replaces the {@link Call.ringing} event, but note that it's\n * subtly different. {@link Call.ringing} is emitted when the remote party calls\n * {@link Call#acknowledge()} whereas {@link Call.membership:notified} emits\n * shortly after (but as a direct result of) locally calling\n * {@link Phone#dial()}\n */\n\n/**\n * @event membership:connected\n * @instance\n * @memberof Call\n * @type {CallMembership}\n */\n\n/**\n * @event membership:declined\n * @instance\n * @memberof Call\n * @type {CallMembership}\n */\n\n/**\n * @event membership:disconnected\n * @instance\n * @memberof Call\n * @type {CallMembership}\n */\n\n/**\n * @event membership:waiting\n * @instance\n * @memberof Call\n * @type {CallMembership}\n */\n\n/**\n * @event membership:change\n * @instance\n * @memberof Call\n * @type {CallMembership}\n */\n\n/**\n * @event memberships:add\n * @instance\n * @memberof Call\n * @description Emitted when a new {@link CallMembership} is added to\n * {@link Call#memberships}. Note that {@link CallMembership#state} still needs\n * to be read to determine if the instance represents someone actively\n * participating the call.\n */\n\n/**\n * @event memberships:remove\n * @instance\n * @memberof Call\n * @description Emitted when a {@link CallMembership} is removed from\n * {@link Call#memberships}.\n */\n\n/**\n * Payload for {@link Call#sendFeedback}\n * @typedef {Object} FeedbackObject\n * @property {number} userRating Number between 1 and 5 (5 being best) to let\n * the user score the call\n * @property {string} userComments Freeform feedback from the user about the\n * call\n * @property {Boolean} includeLogs set to true to submit client logs to the\n * Webex Teams cloud. Note: at this time, all logs, not just call logs,\n * generated by the sdk will be uploaded to the Webex Cloud. Care has been taken\n * to avoid including PII in these logs, but if you've taken advantage of the\n * SDK's logger, you should make sure to avoid logging PII as well.\n */\n\n/**\n * @class\n */\n\nvar Call = _webexCore.WebexPlugin.extend((_dec = (0, _common.whileInFlight)('locusJoinInFlight'), _dec2 = (0, _common.deprecated)('Please use Call#reject()'), _dec3 = (0, _common.whileInFlight)('locusLeaveInFlight'), _dec4 = (0, _lodashDecorators.debounce)(), (_obj = {\n  namespace: 'Phone',\n  mediaConnections: [],\n  children: {\n    media: _mediaEngineWebrtc2.default\n  },\n  collections: {\n    /**\n     * @instance\n     * @memberof Call\n     * @type CallMemberships\n     */\n    memberships: _callMemberships2.default\n  },\n  session: {\n    activeParticipantsCount: {\n      default: 0,\n      required: true,\n      type: 'number'\n    },\n\n    /**\n     * Indicates if the other party in the call has turned off their microphone.\n     * `undefined` for multiparty calls\n     * @instance\n     * @memberof Call\n     * @readonly\n     * @type {boolean}\n     */\n    remoteAudioMuted: {\n      default: false,\n      required: false,\n      type: 'boolean'\n    },\n\n    /**\n     * Indicates if the other party in the call has turned off their camera.\n     * `undefined` for multiparty calls\n     * @instance\n     * @memberof Call\n     * @readonly\n     * @type {boolean}\n     */\n    remoteVideoMuted: {\n      default: false,\n      required: false,\n      type: 'boolean'\n    },\n    correlationId: 'string',\n\n    /**\n     * @instance\n     * @memberof Call\n     * @readonly\n     * @type {string}\n     */\n    facingMode: {\n      type: 'string',\n      values: ['user', 'environment']\n    },\n\n    /**\n     * Derived from locus.id and locus.fullState.lastActive. Not actually a\n     * \"derived\" property because it shouldn't be reset in event a locus\n     * replacement. Marked as private because this isn't necessarily the callId\n     * that we'll eventually expose as a first-class feature.\n     * @instance\n     * @memberof Call\n     * @private\n     * @readonly\n     * @type {string}\n     */\n    internalCallId: {\n      setOnce: true,\n      type: 'string'\n    },\n    locus: 'object',\n\n    /**\n     * Returns the local MediaStream for the call. May initially be `null`\n     * between the time @{Phone#dial is invoked and the  media stream is\n     * acquired if {@link Phone#dial} is invoked without a `localMediaStream`\n     * option.\n     *\n     * This property can also be set mid-call in which case the streams sent to\n     * the remote party are replaced by this stream. On success, the\n     * {@link Call}'s {@link localMediaStream:change} event fires, notifying any\n     * listeners that we are now sending media from a new source.\n     * @instance\n     * @memberof Call\n     * @type {MediaStream}\n     */\n    localMediaStream: 'object',\n    locusJoinInFlight: {\n      default: false,\n      type: 'boolean'\n    },\n    locusLeaveInFlight: {\n      default: false,\n      type: 'boolean'\n    },\n\n    /**\n     * Test helper. Shortcut to the current user's membership object. not\n     * official for now, but may get published at some point\n     * @instance\n     * @memberof Call\n     * @private\n     * @type {CallMembership}\n     */\n    me: {\n      type: 'object'\n    }\n  },\n  // Note, in its current form, any derived property that is an object will emit\n  // a change event everytime a locus gets replaced, even if no values change.\n  // For the moment, this is probably ok; once we have multi-party, regular\n  // change events on activeParticipants may be a problem.\n  derived: {\n    id: {\n      deps: ['locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return (0, _get3.default)(this, 'locus.url');\n      }\n    },\n    isActive: {\n      deps: ['locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return !!(this.locus && (0, _stateParsers.isActive)(this.locus));\n      }\n    },\n    joinedOnThisDevice: {\n      deps: ['locus'],\n      default: false,\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return !!(this.locus && (0, _stateParsers.joinedOnThisDevice)(this.webex, this.locus));\n      }\n    },\n    locusUrl: {\n      deps: ['locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return (0, _get3.default)(this, 'locus.url');\n      }\n    },\n    device: {\n      deps: ['locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return (0, _stateParsers.getThisDevice)(this.webex, this.locus);\n      }\n    },\n    mediaConnection: {\n      deps: ['locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        var device = (0, _stateParsers.getThisDevice)(this.webex, this.locus);\n        return (0, _get3.default)(device, 'mediaConnections[0]');\n      }\n    },\n    mediaId: {\n      deps: ['locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        var device = (0, _stateParsers.getThisDevice)(this.webex, this.locus);\n        return (0, _get3.default)(device, 'mediaConnections[0].mediaId');\n      }\n    },\n\n    /**\n     * The other participant in a two-party call. `undefined` for multiparty\n     * calls\n     * @instance\n     * @memberof Call\n     * @readyonly\n     * @type {CallMembership}\n     */\n    remoteMember: {\n      deps: ['memberships', 'locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        if ((0, _stateParsers.isCall)(this.locus)) {\n          return this.memberships.find(function (m) {\n            return !m.isSelf;\n          });\n        }\n\n        return undefined;\n      }\n    },\n    direction: {\n      deps: ['locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        // This seems brittle, but I can't come up with a better way. The only\n        // way we should have a Call without a locus is if we just initiated a\n        // call but haven't got the response from locus yet.\n        if (!this.locus) {\n          return 'out';\n        }\n\n        return (0, _stateParsers.direction)(this.locus);\n      }\n    },\n\n    /**\n     * The initiating participant in a two-party call.\n     * @deprecated The {@link Call#from} attribute will likely be replaced by\n     * the {@link Call#host}.\n     * @instance\n     * @memberof Call\n     * @readyonly\n     * @type {CallMembership}\n     */\n    from: {\n      deps: ['memberships'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        if (this.isCall) {\n          return this.memberships.find(function (m) {\n            return m.isInitiator;\n          });\n        }\n\n        return undefined;\n      }\n    },\n    to: {\n      deps: ['memberships'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        if (this.isCall) {\n          return this.memberships.find(function (m) {\n            return !m.isInitiator;\n          });\n        }\n\n        return undefined;\n      }\n    },\n\n    /**\n     * <b>active</b> - At least one person (not necessarily this user) is\n     * participating in the call<br/>\n     * <b>inactive</b> - No one is participating in the call<br/>\n     * <b>initializing</b> - reserved for future use<br/>\n     * <b>terminating</b> - reserved for future use<br/>\n     * Only defined if\n     * {@link PhoneConfig.enableExperimentalGroupCallingSupport} has been\n     * enabled\n     * @instance\n     * @memberof Call\n     * @member {string}\n     * @readonly\n     */\n    state: {\n      deps: ['locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        if (this.config.enableExperimentalGroupCallingSupport) {\n          return (0, _stateParsers.getState)(this.locus);\n        }\n\n        return undefined;\n      }\n    },\n\n    /**\n     * <b>initiated</b> - Offer was sent to remote party but they have not yet\n     * accepted <br>\n     * <b>ringing</b> - Remote party has acknowledged the call <br>\n     * <b>connected</b> - At least one party is still on the call <br>\n     * <b>disconnected</b> - All parties have dropped <br>\n     * <b>replaced</b> - In (hopefully) rare cases, the underlying data backing\n     * a Call instance may change in such a way that further interaction with\n     * that Call is handled by a different instance. In such cases, the first\n     * Call's status, will transition to `replaced`, which is almost the same\n     * state as `disconnected`. Generally speaking, such a transition should not\n     * happen for a Call instance that is actively sending/receiving media.\n     * @deprecated The {@link Call#status} attribute will likely be replaced by\n     * the {@link Call#state}.\n     * @instance\n     * @memberof Call\n     * @member {string}\n     * @readonly\n     */\n    status: {\n      deps: ['locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return (0, _stateParsers.getStatus)(this.webex, this.locus, this.previousAttributes().locus);\n      }\n    },\n\n    /**\n     * The host of the call\n     * Only defined if\n     * {@link PhoneConfig.enableExperimentalGroupCallingSupport} has been\n     * enabled\n     * @instance\n     * @memberof Call\n     * @readyonly\n     * @type {object}\n     */\n    host: {\n      deps: ['locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        if (this.config.enableExperimentalGroupCallingSupport) {\n          return this.locus.host;\n        }\n\n        return undefined;\n      }\n    },\n\n    /**\n     * The room id of the call\n     * Only defined if\n     * {@link PhoneConfig.enableExperimentalGroupCallingSupport} has been\n     * enabled\n     * @instance\n     * @memberof Call\n     * @readyonly\n     * @type {object}\n     */\n    roomId: {\n      deps: ['locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        if (this.config.enableExperimentalGroupCallingSupport && this.locus.conversationUrl) {\n          return _common.base64.encode('ciscospark://us/ROOM/' + this.locus.conversationUrl.split('/').pop());\n        }\n\n        return undefined;\n      }\n    },\n\n    /**\n     * Access to the remote party’s `MediaStream`.\n     * @instance\n     * @memberof Call\n     * @member {MediaStream}\n     * @readonly\n     */\n    remoteMediaStream: {\n      deps: ['media.remoteMediaStream'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return this.media.remoteMediaStream;\n      }\n    },\n\n    /**\n     * Access to the local party’s screen share `MediaStream`.\n     * @instance\n     * @memberof Call\n     * @member {MediaStream}\n     * @readonly\n     */\n    localScreenShare: {\n      deps: ['media.localScreenShare'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return this.media.localScreenShare;\n      }\n    },\n    receivingAudio: {\n      deps: ['media.receivingAudio'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return this.media.receivingAudio;\n      }\n    },\n    receivingVideo: {\n      deps: ['media.receivingVideo'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return this.media.receivingVideo;\n      }\n    },\n    sendingAudio: {\n      deps: ['media.sendingAudio'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return this.media.sendingAudio;\n      }\n    },\n    sendingVideo: {\n      deps: ['media.sendingVideo'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return this.media.sendingVideo;\n      }\n    },\n    isCall: {\n      deps: ['locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return (0, _stateParsers.isCall)(this.locus);\n      }\n    },\n    supportsDtmf: {\n      deps: ['locus'],\n\n      /**\n       * @private\n       * @returns {mixed}\n       */\n      fn: function fn() {\n        return (0, _get3.default)(this, 'locus.self.enableDTMF');\n      }\n    }\n  },\n\n  /**\n   * Use to acknowledge (without answering) an incoming call. Will cause the\n   * initiator's Call instance to emit the ringing event.\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  acknowledge: function acknowledge() {\n    var _this = this;\n\n    this.logger.info('call: acknowledging');\n    return this.webex.internal.locus.alert(this.locus).then(function (locus) {\n      return _this.setLocus(locus);\n    }).then((0, _common.tap)(function () {\n      return _this.logger.info('call: acknowledged');\n    }));\n  },\n  // Note: the `whileInFlight` decorator screws up name inferrence, so we need\n  // to include @name below.\n\n  /**\n   * Answers an incoming call.\n   * @instance\n   * @name answer\n   * @memberof Call\n   * @param {Object} options\n   * @param {MediaStreamConstraints} options.constraints\n   * @returns {Promise}\n   */\n  answer: function answer(options) {\n    var _this2 = this;\n\n    this.logger.info('call: answering');\n\n    if (!this.locus) {\n      this.logger.info('call: no locus provided, answer() is a noop');\n      return _promise2.default.resolve();\n    } // Locus may think we're joined on this device if we e.g. reload the page,\n    // so, we need to check if we also have a working peer connection\n    // this.media.pc.remoteDescription.sdp is a temporary proxy for\n    // pc.connectionState until chrome catches up to the spec\n\n\n    if (this.joinedOnThisDevice && this.media.pc.remoteDescription && this.media.pc.remoteDescription.sdp) {\n      this.logger.info('call: already joined on this device');\n      return _promise2.default.resolve();\n    }\n\n    return this.createOrJoinLocus(this.locus, options).then((0, _common.tap)(function () {\n      return _this2.logger.info('call: answered');\n    }));\n  },\n\n  /**\n   * Change the receiving media state. may induce a renegoatiation\n   * @instance\n   * @memberof Call\n   * @param {string} kind one of \"audio\" or \"video\"\n   * @param {boolean} value\n   * @private\n   * @returns {Promise}\n   */\n  changeReceivingMedia: function changeReceivingMedia(kind, value) {\n    var _this3 = this;\n\n    return new _promise2.default(function (resolve) {\n      var sdp = (0, _sdpTransform.parse)(_this3.media.offerSdp);\n      var section = (0, _find3.default)(sdp.media, {\n        type: kind\n      }); // If the current offer is going to trigger a renegotiation, then we don't\n      // need to renegotiate here.\n\n      if (!section || !section.direction.includes('recv')) {\n        _this3.logger.info('changeReceivingMedia: expecting to renegotiate, waiting for media to emit \"answeraccepted\"');\n\n        _this3.media.once('answeraccepted', function () {\n          return resolve();\n        });\n      } else {\n        _this3.logger.info('changeReceivingMedia: expecting to renegotiate, waiting for call to emit \"change:receiving' + capitalize[kind] + '\"');\n\n        _this3.once('change:receiving' + capitalize[kind], function () {\n          return resolve();\n        });\n      }\n\n      var newDirection = (0, _boolToStatus2.default)(_this3.media['sending' + capitalize[kind]], value);\n      console.warn('starting to setMedia ' + kind + ' to ' + newDirection);\n\n      _this3.media.setMedia(kind, newDirection);\n    });\n  },\n\n  /**\n   * Change the receiving media state. may induce a renegoatiation\n   * @instance\n   * @memberof Call\n   * @param {string} kind one of \"audio\" or \"video\"\n   * @param {boolean} value\n   * @private\n   * @returns {Promise}\n   */\n  changeSendingMedia: function changeSendingMedia(kind, value) {\n    var _this4 = this; // Changing media direction only should not trigger renegotiation as long as a new\n    // track is not introduced. If that is the case we would expect renegotiation to happen.\n\n\n    this.logger.info('changeSendingMedia: changing sending \"' + kind + '\" to \"' + value + '\"');\n\n    if (['audio', 'video'].includes(kind)) {\n      var tracks = this.media.senderTracks.filter(function (t) {\n        return t.kind === kind;\n      });\n      var newDirection = (0, _boolToStatus2.default)(value, this.media['receiving' + capitalize[kind]]);\n\n      if (tracks.length > 0) {\n        // track already exists, we only need to toggle direction\n        return this.media.setMedia(kind, newDirection).then(function () {\n          return _this4.updateMuteToggles(kind, value);\n        });\n      } // adding a new track and needs renegotiation\n\n\n      return new _promise2.default(function (resolve) {\n        _this4.once('mediaNegotiationCompleted', function () {\n          return resolve();\n        });\n\n        _this4.media.setMedia(kind, newDirection);\n      });\n    }\n\n    return _promise2.default.reject(new Error('kind must be one of \"audio\" or \"video\"'));\n  },\n\n  /**\n   * Does the cleanup after a call has ended\n   * @instance\n   * @memberof Call\n   * @private\n   * @returns {Promise}\n   */\n  cleanup: function cleanup() {\n    var _this5 = this;\n\n    return new _promise2.default(function (resolve) {\n      // need to do this on next tick otherwise this.off() prevents remaining\n      // events from being received (e.g. other listeners for `disconnected`\n      // won't execute)\n      process.nextTick(function () {\n        _this5.media.stop();\n\n        _this5.stopListening(_this5.webex.internal.mercury);\n\n        _this5.off();\n\n        resolve();\n      });\n    });\n  },\n\n  /**\n   * Call and answer require nearly identical logic, so this method unifies them.\n   * @instance\n   * @memberof Call\n   * @param {Object|locus} target\n   * @param {Object} options\n   * @todo remove 'locusMethodName' and move that logic to locus plugin\n   * @todo move options and target processing to separate function\n   * @todo rename to join()?\n   * @returns {Promise}\n   */\n  createOrJoinLocus: function createOrJoinLocus(target) {\n    var _this6 = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.localMediaStream) {\n      this.localMediaStream = options.localMediaStream;\n    } else {\n      if (!options.constraints) {\n        options.constraints = {\n          audio: true,\n          video: {\n            facingMode: {\n              ideal: this.webex.phone.defaultFacingMode\n            }\n          }\n        };\n      }\n\n      var mode = (0, _get3.default)(options, 'constraints.video.facingMode.ideal', (0, _get3.default)(options, 'constraints.video.facingMode.exact'));\n\n      if (mode === 'user' || mode === 'environment') {\n        this.facingMode = mode;\n      }\n\n      var recvOnly = !options.constraints.audio && !options.constraints.video;\n      options.offerOptions = (0, _defaults3.default)(options.offerOptions, {\n        offerToReceiveAudio: recvOnly || !!options.constraints.audio,\n        offerToReceiveVideo: recvOnly || !!options.constraints.video\n      });\n\n      if (options.constraints.fake) {\n        this.media.constraints.fake = true;\n      }\n\n      this.media.setMedia('audio', (0, _boolToStatus2.default)(options.constraints.audio, options.offerOptions.offerToReceiveAudio), options.constraints.audio);\n\n      if ((0, _get3.default)(options, 'constraints.video.mediaSource') === 'screen' || (0, _get3.default)(options, 'constraints.video.mediaSource') === 'application') {\n        this.media.setMedia('screen', 'sendonly');\n      } else {\n        this.media.setMedia('video', (0, _boolToStatus2.default)(options.constraints.video, options.offerOptions.offerToReceiveVideo), options.constraints.video);\n      }\n    }\n\n    if (!target.correlationId) {\n      options.correlationId = _uuid2.default.v4();\n      this.correlationId = options.correlationId;\n    }\n\n    if (!this.correlationId) {\n      this.correlationId = target.correlationId;\n    } // reminder: not doing this copy in initialize() because config may not yet\n    // be available\n\n\n    this.media.bandwidthLimit = {\n      audioBandwidthLimit: this.config.audioBandwidthLimit,\n      videoBandwidthLimit: this.config.videoBandwidthLimit\n    };\n    return this.media.createOffer().then((0, _common.tap)(function () {\n      return _this6.logger.info('created offer');\n    })).then(function () {\n      return _this6.webex.internal.locus.createOrJoin(target, (0, _assign2.default)({\n        localSdp: _this6.media.offerSdp,\n        correlationId: _this6.correlationId\n      }, options));\n    }).then((0, _common.tap)(function () {\n      return _this6.logger.info('sent offer to locus');\n    })).then((0, _common.tap)(function () {\n      return _this6.logger.info('setting locus');\n    })).then(function (locus) {\n      return _this6.setLocus(locus);\n    }).then((0, _common.tap)(function () {\n      return _this6.logger.info('successfully set locus');\n    })).then(function () {\n      var answer = _this6.mediaConnection.remoteSdp ? JSON.parse(_this6.mediaConnection.remoteSdp).sdp : JSON.parse(_this6.mediaConnections.remoteSdp).sdp;\n\n      _this6.logger.info('accepting answer');\n\n      _this6.logger.info('peer state', _this6.media.pc && _this6.media.pc.signalingState);\n\n      if (!_this6.media.ended) {\n        return _this6.media.acceptAnswer(answer).then(function () {\n          return _this6.logger.info('answer accepted');\n        }).catch(function (err) {\n          _this6.logger.error('failed to accept answer', err);\n\n          return _promise2.default.reject(err);\n        });\n      }\n\n      _this6.logger.info('call: already ended, not accepting answer');\n\n      return _promise2.default.resolve();\n    });\n  },\n\n  /**\n   * Alias of {@link Call#reject}\n   * @see {@link Call#reject}\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  decline: function decline() {\n    return this.reject();\n  },\n\n  /**\n   * Used by {@link Phone#dial} to initiate an outbound call\n   * @instance\n   * @memberof Call\n   * @param {[type]} invitee\n   * @param {[type]} options\n   * @private\n   * @returns {[type]}\n   */\n  dial: function dial(invitee, options) {\n    var _this7 = this;\n\n    this.locusJoinInFlight = true;\n    this.logger.info('call: dialing');\n    var target = invitee;\n\n    if (_common.base64.validate(invitee)) {\n      // eslint-disable-next-line no-unused-vars\n      var parsed = _common.base64.decode(invitee).split('/');\n\n      var resourceType = parsed[3];\n      var id = parsed[4];\n      var feature = this.webex.internal.feature.getFeature('developer', 'web-high-availability');\n\n      if (resourceType === 'PEOPLE') {\n        target = id;\n      }\n\n      if (resourceType === 'ROOM') {\n        if (!(0, _get3.default)(this, 'config.enableExperimentalGroupCallingSupport')) {\n          throw new Error('Group calling is not enabled. Please enable config.phone.enableExperimentalGroupCallingSupport');\n        }\n\n        if (feature && feature.value) {\n          this.webex.internal.device.getServiceUrl('conversation').then(function (u) {\n            target = {\n              url: u + '/conversations/' + id + '/locus'\n            };\n            return target;\n          });\n        } else {\n          target = {\n            url: this.webex.internal.device.services.conversationServiceUrl + '/conversations/' + id + '/locus'\n          };\n        }\n      }\n    } // Note: mercury.connect() will call device.register() if needed. We're not\n    // using phone.register() here because it guarantees a device refresh, which\n    // is probably unnecessary.\n\n\n    this.webex.internal.mercury.connect().then(function () {\n      return _this7.createOrJoinLocus(target, options);\n    }).then((0, _common.tap)(function () {\n      return _this7.logger.info('call: dialed');\n    })).catch(function (reason) {\n      _this7.trigger('error', reason);\n    }).then(function () {\n      _this7.locusJoinInFlight = false;\n    });\n    return this;\n  },\n\n  /**\n   * Returns a {@link Readable} that emits {@link Call#media.pc}'s\n   * {@link RTCStatsReport} every second.\n   * @instance\n   * @memberof Call\n   * @returns {StatsStream}\n   */\n  getRawStatsStream: function getRawStatsStream() {\n    return new _stream2.default(this.media.pc);\n  },\n\n  /**\n   * Returns a {@link StatsStream} piped through a {@link StatsFilter}\n   * @instance\n   * @memberof Call\n   * @returns {Readable}\n   */\n  getStatsStream: function getStatsStream() {\n    return this.getRawStatsStream().pipe(new _filter2.default());\n  },\n\n  /**\n   * Disconnects the active call. Applies to both incoming and outgoing calls.\n   * This method may be invoked in any call state and the SDK should take care\n   * to tear down the call and free up all resources regardless of the state.\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  hangup: function hangup() {\n    var _this8 = this; // Note: not a @oneFlight because this function must call itself\n\n\n    if (this.direction === 'in' && !this.joinedOnThisDevice) {\n      return this.reject();\n    }\n\n    this.logger.info('call: hanging up');\n    this.media.stop();\n\n    if (this.locusJoinInFlight) {\n      this.logger.info('call: locus join in flight, waiting for rest call to complete before hanging up');\n      return this.when('change:locusJoinInFlight').then(function () {\n        return _this8.hangup();\n      });\n    }\n\n    if (!this.locus) {\n      return this.cleanup().then(function () {\n        return _this8.logger.info('call: hang up complete, call never created');\n      });\n    }\n\n    return this.leave();\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Call\n   * @private\n   * @param {Object} attrs\n   * @param {Object} options\n   * @returns {undefined}\n   */\n  initialize: function initialize() {\n    var _this9 = this;\n\n    for (var _len = arguments.length, initArgs = Array(_len), _key = 0; _key < _len; _key++) {\n      initArgs[_key] = arguments[_key];\n    }\n\n    (0, _apply2.default)(_webexCore.WebexPlugin.prototype.initialize, this, initArgs);\n    this.on('change:activeParticipantsCount', function () {\n      return _this9.onChangeActiveParticipantsCount.apply(_this9, arguments);\n    }); // This handler is untested because there's no way to provoke it. It's\n    // probably actually only relevant for group calls.\n\n    this.on('change:isActive', function () {\n      return _this9.onChangeIsActive.apply(_this9, arguments);\n    });\n    this.on('change:localMediaStream', function () {\n      return _this9.onChangeLocalMediaStream.apply(_this9, arguments);\n    }); // Reminder: this is not a derived property so that we can reassign the\n    // stream midcall\n\n    this.on('change:media.localMediaStream', function () {\n      _this9.localMediaStream = _this9.media.localMediaStream;\n    });\n    this.on('change:remoteMember', function () {\n      return _this9.onChangeRemoteMember.apply(_this9, arguments);\n    });\n    ['localMediaStream', 'remoteAudioMuted', 'remoteMediaStream', 'remoteVideoMuted', 'localScreenShare'].forEach(function (key) {\n      _this9.on('change:' + key, function () {\n        return _this9.trigger(key + ':change');\n      });\n    });\n    this.on('replaced', function () {\n      return _this9.cleanup();\n    });\n    this.listenTo(this.memberships, 'add', function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _this9.trigger.apply(_this9, ['memberships:add'].concat(args));\n    });\n    this.listenTo(this.memberships, 'change', function () {\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return _this9.trigger.apply(_this9, ['membership:change'].concat(args));\n    });\n    this.listenTo(this.memberships, 'change:audioMuted', function () {\n      return _this9.onMembershipsAudioMuted.apply(_this9, arguments);\n    });\n    this.listenTo(this.memberships, 'change:state', function () {\n      return _this9.onMembershipsChangeState.apply(_this9, arguments);\n    });\n    this.listenTo(this.memberships, 'change:videoMuted', function () {\n      return _this9.onMembershipsVideoMuted.apply(_this9, arguments);\n    });\n    this.listenTo(this.memberships, 'remove', function () {\n      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return _this9.trigger.apply(_this9, ['memberships:remove'].concat(args));\n    });\n    this.listenTo(this.webex.internal.mercury, 'event:locus', function (event) {\n      return _this9.onLocusEvent(event);\n    });\n    this.listenTo(this.webex.internal.mercury, 'event:locus.difference', function (event) {\n      return _this9.onLocusEvent(event);\n    });\n    this.listenTo(this.media, 'error', function (error) {\n      return _this9.trigger('error', error);\n    });\n    this.listenTo(this.media, 'internalTrackUpdate', function () {\n      _this9.trigger('remoteMediaStream:change');\n    });\n    this.listenTo(this.media, 'negotiationneeded', function () {\n      return _this9.onMediaNegotiationNeeded.apply(_this9, arguments);\n    });\n\n    if (this.locus) {\n      this.internalCallId = (0, _stateParsers.makeInternalCallId)(this.locus);\n    } else {\n      this.once('change:locus', function () {\n        _this9.internalCallId = (0, _stateParsers.makeInternalCallId)(_this9.locus);\n      });\n    }\n\n    this.memberships.listenToAndRun(this, 'change:locus', function () {\n      if (_this9.locus && _this9.locus.participants) {\n        // Reminder: we're parsing here instead of CallMembership(s) so that we\n        // can avoid making those classes webex aware and therefore keep them a\n        // lot simpler\n        _this9.memberships.set((0, _stateParsers.participantsToCallMemberships)(_this9.webex, _this9.locus));\n\n        _this9.me = _this9.memberships.find(function (m) {\n          return m.isSelf;\n        });\n      }\n    });\n\n    if (this.config.enableExperimentalGroupCallingSupport) {\n      this.on('inactive', function () {\n        return _this9.hangup();\n      });\n      this.on('inactive', function () {\n        return _this9.cleanup();\n      });\n      this.on('change:state', function () {\n        process.nextTick(function () {\n          return _this9.trigger(_this9.state);\n        });\n      });\n      this.on = (0, _wrap3.default)(this.on, function (fn, eventName) {\n        for (var _len5 = arguments.length, rest = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n          rest[_key5 - 2] = arguments[_key5];\n        }\n\n        if (deprecatedCallEventNames.includes(eventName)) {\n          throw new Error('The \"' + eventName + '\" event is no longer valid with \"enableExperimentalGroupCallingSupport===true\"');\n        }\n\n        return (0, _apply2.default)(fn, _this9, [eventName].concat(rest));\n      });\n    } else {\n      this.on('disconnected', function () {\n        return _this9.hangup();\n      });\n      this.on('disconnected', function () {\n        return _this9.cleanup();\n      });\n      this.on('change:status', function () {\n        process.nextTick(function () {\n          return _this9.trigger(_this9.status);\n        });\n      });\n    }\n  },\n\n  /**\n   * Does the internal work necessary to end a call while allowing hangup() to\n   * call itself without getting stuck in promise change because of oneFlight\n   * The name of this function is temporary to address the no-underscore-dangle\n   * rule. A future commit in this PR will rename all of the\n   * reject/end/hangup/finish functions to be more meaningful and not just be\n   * synonyms the same word.\n   * @private\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  leave: function leave() {\n    var _this10 = this;\n\n    this.logger.info('leave: attempting to leave locus');\n    var status = (0, _get3.default)(this, this.config.enableExperimentalGroupCallingSupport ? 'me.state' : 'status');\n\n    if (status === 'disconnected') {\n      this.logger.info('already hung up, not calling locus again');\n      return _promise2.default.resolve();\n    }\n\n    if (status === 'declined') {\n      this.logger.info('call was declined, not leaving again');\n      return _promise2.default.resolve();\n    }\n\n    if (status !== 'connected') {\n      this.logger.info('call is neither connected, disconnected, or declined, declining instead of leaving');\n      return this.decline();\n    }\n\n    this.logger.info('leave: leaving locus');\n    return this.webex.internal.locus.leave(this.locus).catch(function (err) {\n      _this10.logger.error('leave: locus leave error: ', err.stack || err.toString());\n\n      return _promise2.default.reject(err);\n    }).then((0, _common.tap)(function () {\n      return _this10.logger.info('leave ' + _this10.locus.id + ': finished leaving via locus');\n    })).then((0, _common.tap)(function () {\n      return _this10.logger.info('leave ' + _this10.locus.id + ': setting locus');\n    })).then(function (locus) {\n      return _this10.setLocus(locus);\n    }).then((0, _common.tap)(function () {\n      return _this10.logger.info('leave ' + _this10.locus.id + ': finished setting locus');\n    })) // Note: not stopping event-listening here; that'll happening\n    // automatically when `disconnected` fires.\n    .then((0, _common.tap)(function () {\n      return _this10.logger.info('call: hung up');\n    }));\n  },\n\n  /**\n   * Handles an incoming mercury event if relevant to this call.\n   * @instance\n   * @memberof Call\n   * @param {Types~MercuryEvent} event\n   * @private\n   * @returns {undefined}\n   */\n  onLocusEvent: function onLocusEvent(event) {\n    var _this11 = this;\n\n    var devices = (0, _get3.default)(event, 'data.locus.self.devices');\n    var device = devices && (0, _find3.default)(devices, function (item) {\n      return item.url === _this11.webex.internal.device.url;\n    });\n    var internalCallId = this.locus && (0, _stateParsers.makeInternalCallId)(event.data.locus);\n\n    if (internalCallId === this.internalCallId || device && this.correlationId === device.correlationId) {\n      this.logger.info('locus event: ' + event.data.eventType);\n      this.setLocus(event.data.locus);\n    }\n\n    if (event.data.locus.replaces) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = (0, _getIterator3.default)(event.data.locus.replaces), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var replaced = _step.value;\n\n          if (replaced.locusUrl + '_' + replaced.lastActive === this.internalCallId) {\n            this.setLocus(event.data.locus);\n            this.logger.info('locus replacement event: ' + event.data.eventType, this.locusUrl, '->', event.data.locus.url);\n            return;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   * Event handler\n   * @instance\n   * @memberof Call\n   * @private\n   * @returns {undefined}\n   */\n  onMembershipsAudioMuted: function onMembershipsAudioMuted() {\n    this.logger.info('onMembershipsAudioMuted');\n\n    if (this.remoteMember) {\n      this.remoteAudioMuted = this.remoteMember.audioMuted;\n    }\n  },\n\n  /**\n   * Event handler\n   * @instance\n   * @memberof Call\n   * @private\n   * @returns {undefined}\n   */\n  onMembershipsVideoMuted: function onMembershipsVideoMuted() {\n    this.logger.info('onMembershipsVideoMuted');\n\n    if (this.remoteMember) {\n      this.remoteVideoMuted = this.remoteMember.videoMuted;\n    }\n  },\n\n  /**\n   * Event handler\n   * @instance\n   * @memberof Call\n   * @private\n   * @returns {undefined}\n   */\n  onChangeRemoteMember: function onChangeRemoteMember() {\n    if (this.remoteMember) {\n      this.remoteAudioMuted = this.remoteMember.audioMuted;\n      this.remoteVideoMuted = this.remoteMember.videoMuted;\n    } else {\n      this.remoteAudioMuted = undefined;\n      this.remoteVideoMuted = undefined;\n    }\n  },\n\n  /**\n   * Event handler\n   * @instance\n   * @memberof Call\n   * @param {Membership} model\n   * @private\n   * @returns {undefined}\n   */\n  onMembershipsChangeState: function onMembershipsChangeState(model) {\n    this.activeParticipantsCount = this.memberships.filter(function (m) {\n      return m.state === 'connected';\n    }).length;\n    this.trigger('membership:' + model.state, model);\n  },\n\n  /**\n   * Event handler\n   * @instance\n   * @memberof Call\n   * @private\n   * @returns {undefined}\n   */\n  onMediaNegotiationNeeded: function onMediaNegotiationNeeded() {\n    var _this12 = this;\n\n    this.logger.info('onMediaNegotiationNeeded');\n    this.media.createOffer().then(function () {\n      // Determine mute state for locus from sdp\n      var offer = (0, _sdpTransform.parse)(_this12.media.offerSdp);\n      var audioOfferDir = getMediaDirectionFromSDP('audio', offer);\n      var audioMuted = !audioOfferDir.includes('send');\n      var videoOfferDir = getMediaDirectionFromSDP('video', offer);\n      var videoMuted = !videoOfferDir.includes('send');\n      var screenOfferDir = getMediaDirectionFromSDP('screen', offer);\n\n      _this12.logger.info('onMediaNegotiationNeeded: audioOfferDir=' + audioOfferDir + ' videoOfferDir=' + videoOfferDir + ' screenOfferDir=' + screenOfferDir);\n\n      _this12.logger.info('onMediaNegotiationNeeded: audioMuted=' + audioMuted + ' videoMuted=' + videoMuted);\n\n      var updateMediaOptions = {\n        sdp: _this12.media.offerSdp,\n        mediaId: _this12.mediaId,\n        audioMuted: audioMuted,\n        videoMuted: videoMuted\n      };\n      return _this12.updateMedia(updateMediaOptions);\n    }).then(function () {\n      return _this12.pollForExpectedLocusAndSdp();\n    }).then(function () {\n      var _JSON$parse = JSON.parse(_this12.mediaConnection.remoteSdp),\n          sdp = _JSON$parse.sdp;\n\n      return _this12.media.acceptAnswer(sdp);\n    }).then(function () {\n      return _this12.emit('mediaNegotiationCompleted');\n    }).catch(function (reason) {\n      return _this12.emit('error', reason);\n    });\n  },\n\n  /**\n   * Event handler\n   * @instance\n   * @memberof Call\n   * @private\n   * @returns {undefined}\n   */\n  onChangeLocalMediaStream: function onChangeLocalMediaStream() {\n    var _this13 = this;\n\n    if (this.localMediaStream && this.localMediaStream !== this.media.localMediaStream) {\n      ['audio', 'video'].forEach(function (kind) {\n        // eslint-disable-next-line max-nested-callbacks\n        var track = _this13.localMediaStream.getTracks().find(function (t) {\n          return t.kind === kind;\n        });\n\n        if (track) {\n          _this13.media.setMedia(kind, (0, _boolToStatus2.default)(track.enabled, _this13['receiving' + capitalize[kind]]), track);\n        } else {\n          _this13.media.setMedia(kind, (0, _boolToStatus2.default)(false, _this13['receiving' + capitalize[kind]]));\n        }\n      });\n      this.localMediaStream = this.media.localMediaStream;\n    }\n  },\n\n  /**\n   * Event handler\n   * @instance\n   * @memberof Call\n   * @private\n   * @returns {undefined}\n   */\n  onChangeIsActive: function onChangeIsActive() {\n    if (!this.isActive) {\n      if (this.joinedOnThisDevice) {\n        this.logger.info('call: hanging up due to locus going inactive');\n        this.hangup();\n      }\n    }\n  },\n\n  /**\n   * Event handler\n   * @instance\n   * @memberof Call\n   * @private\n   * @returns {undefined}\n   */\n  onChangeActiveParticipantsCount: function onChangeActiveParticipantsCount() {\n    if (!this.joinedOnThisDevice) {\n      return;\n    }\n\n    if (this.activeParticipantsCount !== 1) {\n      return;\n    }\n\n    if (this.isCall && !this.config.hangupIfLastActive.call) {\n      return;\n    }\n\n    if (!this.isCall && !this.config.hangupIfLastActive.meeting) {\n      return;\n    }\n\n    var previousLocus = this.previousAttributes().locus;\n\n    if (!previousLocus) {\n      return;\n    }\n\n    if ((0, _stateParsers.activeParticipants)(previousLocus).length > 1) {\n      this.logger.info('call: hanging up due to last participant in call');\n      this.hangup();\n    }\n  },\n\n  /**\n   * The response to a PUT to LOCUS/media may not be fully up-to-date when we\n   * receive it. This method polls locus until we get a locus with the status\n   * properties we expect (or three errors occur)\n   * @instance\n   * @memberof Call\n   * @private\n   * @returns {Promise<Types~Locus>}\n   */\n  pollForExpectedLocusAndSdp: function pollForExpectedLocusAndSdp() {\n    var _this14 = this;\n\n    return new _promise2.default(function (resolve, reject) {\n      var offer = (0, _sdpTransform.parse)(_this14.media.offerSdp);\n      var audioOfferDir = getMediaDirectionFromSDP('audio', offer);\n      var videoOfferDir = getMediaDirectionFromSDP('video', offer);\n      var screenOfferDir = getMediaDirectionFromSDP('screen', offer);\n      var self = _this14;\n      var count = 0;\n\n      var validate = function validate() {\n        count += 1;\n\n        try {\n          _this14.logger.info('iteration ' + count + ': checking if current locus sdp has the expected audio and video directions');\n\n          if (isExpectedDirection(JSON.parse(_this14.mediaConnection.remoteSdp).sdp)) {\n            _this14.logger.info('iteration ' + count + ': the current locus sdp has the expected audio and video directions');\n\n            try {\n              _this14.logger.info('iteration ' + count + ': checking if current locus has the expected audio and video directions');\n\n              _this14.validateLocusMediaState(_this14.locus);\n\n              _this14.logger.info('iteration ' + count + ': the current locus has the expected audio and video directions; not syncing');\n\n              resolve();\n              return;\n            } catch (err) {\n              _this14.logger.info('iteration ' + count + ': the current locus does not have the expected audio and video directions; syncing');\n            }\n          } else {\n            _this14.logger.info('iteration ' + count + ': the current locus sdp does not have the expected audio and video directions; syncing');\n          }\n\n          if (count > 4) {\n            reject(new Error('After ' + count + ' attempts polling locus'));\n            return;\n          }\n\n          setTimeout(function () {\n            return _this14.webex.internal.locus.sync(_this14.locus).then(function (locus) {\n              return _this14.setLocus(locus);\n            }).then(validate).catch(reject);\n          }, 1000 * Math.pow(2, count));\n        } catch (err) {\n          reject(err);\n        }\n      };\n\n      validate();\n      /**\n       * Determine if the incoming sdp has the expected media directions\n       * @private\n       * @param {string} sdp\n       * @returns {boolean}\n       */\n\n      function isExpectedDirection(sdp) {\n        var answer = (0, _sdpTransform.parse)(sdp);\n        var audioAnswerDir = getMediaDirectionFromSDP('audio', answer);\n        var videoAnswerDir = getMediaDirectionFromSDP('video', answer);\n        var screenAnswerDir = getMediaDirectionFromSDP('screen', answer);\n        var expectedAudioAnswerDir = reverseMediaDirection(audioOfferDir);\n        var expectedVideoAnswerDir = reverseMediaDirection(videoOfferDir);\n        var expectedScreenAnswerDir = reverseMediaDirection(screenOfferDir);\n        self.logger.info('audio: ' + audioOfferDir + ', ' + audioAnswerDir + ', ' + expectedAudioAnswerDir);\n        self.logger.info('video: ' + videoOfferDir + ', ' + videoAnswerDir + ', ' + expectedVideoAnswerDir);\n        self.logger.info('screen: ' + screenOfferDir + ', ' + screenAnswerDir + ', ' + expectedScreenAnswerDir); // eslint-disable-next-line max-len\n\n        return audioAnswerDir === expectedAudioAnswerDir && videoAnswerDir === expectedVideoAnswerDir && screenAnswerDir === expectedScreenAnswerDir;\n      }\n    });\n  },\n\n  /**\n   * Tells locus we're done sharing some or all of our screen.\n   * @instance\n   * @memberof Call\n   * @private\n   * @returns {Promise}\n   */\n  releaseFloor: function releaseFloor() {\n    var _this15 = this;\n\n    this.logger.info('call: releasing floor grant');\n    return _promise2.default.resolve().then((0, _stateParsers.waitForMediaShare)(this)).then(function (mediaShare) {\n      return _this15.webex.internal.locus.releaseFloorGrant(_this15.locus, mediaShare);\n    });\n  },\n\n  /**\n   * Rejects an incoming call. Only applies to incoming calls. Invoking this\n   * method on an outgoing call is a no-op.\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  reject: function reject() {\n    var _this16 = this;\n\n    if (this.direction === 'out') {\n      return _promise2.default.resolve();\n    }\n\n    this.logger.info('call: rejecting');\n    /* eslint no-invalid-this: [0] */\n\n    return this.webex.internal.locus.decline(this.locus).then(function (locus) {\n      return _this16.setLocus(locus);\n    }).then((0, _common.tap)(function () {\n      return _this16.cleanup();\n    })).then((0, _common.tap)(function () {\n      return _this16.logger.info('call: rejected');\n    }));\n  },\n\n  /**\n   * Tells locus we'd like to share some or all of our screen.\n   * @instance\n   * @memberof Call\n   * @private\n   * @returns {Promise}\n   */\n  requestFloor: function requestFloor() {\n    var _this17 = this;\n\n    this.logger.info('call: requesting floor grant');\n    return _promise2.default.resolve().then((0, _stateParsers.waitForMediaShare)(this)).then(function (mediaShare) {\n      return _this17.webex.internal.locus.requestFloorGrant(_this17.locus, mediaShare);\n    });\n  },\n\n  /**\n   * Assigns a new locus to this.locus according to locus sequencing rules\n   * @instance\n   * @memberof Call\n   * @param {Types~Locus} incoming\n   * @param {boolean} recursing - when true, indicates that this method has\n   * called itself and we should fall back to {@link locus.get()} instead of\n   * calling {@link locus.sync()}\n   * @private\n   * @returns {Promise}\n   */\n  setLocus: function setLocus(incoming) {\n    var _this18 = this;\n\n    var recursing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var current = this.locus;\n\n    if (!current) {\n      this.locus = incoming;\n      return _promise2.default.resolve();\n    }\n\n    if ('self' in current && 'self' in incoming && current.self.devices[0] && 'mediaConnections' in current.self.devices[0] && incoming.self.state !== 'LEFT') {\n      if ('remoteSdp' in current.self.devices[0].mediaConnections[0] && !('remoteSdp' in incoming.self.devices[0].mediaConnections[0])) {\n        incoming.self.devices.map(function (item, index) {\n          item.mediaConnections = [current.self.devices[index].mediaConnections[index]];\n          return item;\n        });\n        this.setLocus(incoming);\n      } else if (!('remoteSdp' in current.self.devices[0].mediaConnections[0]) && 'remoteSdp' in incoming.self.devices[0].mediaConnections[0]) {\n        this.mediaConnections = incoming.self.devices[0].mediaConnections[0];\n        this.locus.self.devices.map(function (item, index) {\n          item.mediaConnections = [incoming.self.devices[index].mediaConnections[index]];\n          return item;\n        });\n        this.setLocus(incoming);\n      }\n    }\n\n    var action = this.webex.internal.locus.compare(current, incoming);\n\n    switch (action) {\n      case _internalPluginLocus.USE_INCOMING:\n        this.locus = this.webex.internal.locus.merge(this.locus, incoming);\n\n        if (this.device) {\n          this.correlationId = this.device.correlationId;\n        }\n\n        break;\n\n      case _internalPluginLocus.FETCH:\n        if (recursing) {\n          this.logger.info('call: fetching locus according to sequencing algorithm');\n          return this.webex.internal.locus.get(current).then(function (locus) {\n            return _this18.setLocus(locus, true);\n          });\n        }\n\n        this.logger.info('call: syncing locus according to sequencing algorithm');\n        return this.webex.internal.locus.sync(current).then(function (locus) {\n          return _this18.setLocus(locus, true);\n        });\n\n      default: // do nothing\n\n    }\n\n    return _promise2.default.resolve();\n  },\n\n  /**\n   * Send DTMF tones to the current call\n   * @instance\n   * @memberof Call\n   * @param {string} tones\n   * @returns {Promise}\n   */\n  sendDtmf: function sendDtmf(tones) {\n    if (!this.supportsDtmf) {\n      return _promise2.default.reject(new Error('this call does not support dtmf'));\n    }\n\n    return this.webex.internal.locus.sendDtmf(this.locus, tones);\n  },\n\n  /**\n   * Sends feedback about the call to the Webex Teams cloud\n   * @instance\n   * @memberof Call\n   * @param {FeedbackObject} feedback\n   * @returns {Promise}\n   */\n  sendFeedback: function sendFeedback(feedback) {\n    return this.webex.internal.metrics.submit('meetup_call_user_rating', feedback);\n  },\n\n  /**\n   * Shares a particular application as a second stream in the call\n   * @returns {Promise}\n   */\n  startApplicationShare: function startApplicationShare() {\n    var _this19 = this;\n\n    this.logger.info('call: sharing application');\n    return new _promise2.default(function (resolve) {\n      _this19.media.once('answeraccepted', resolve);\n\n      _this19.media.setMedia('screen', 'sendonly', {\n        mediaSource: 'application'\n      });\n    }).then(function () {\n      return _this19.requestFloor();\n    });\n  },\n\n  /**\n   * Shares the whole screen as a second stream in the call\n   * @returns {Promise}\n   */\n  startScreenShare: function startScreenShare() {\n    var _this20 = this;\n\n    this.logger.info('call: sharing screen');\n    return new _promise2.default(function (resolve) {\n      _this20.media.once('answeraccepted', resolve);\n\n      _this20.media.setMedia('screen', 'sendonly', {\n        mediaSource: 'screen'\n      });\n    }).then(function () {\n      return _this20.requestFloor();\n    });\n  },\n\n  /**\n   * Start receiving audio\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  startReceivingAudio: function startReceivingAudio() {\n    return this.changeReceivingMedia('audio', true);\n  },\n\n  /**\n   * Start receiving video\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  startReceivingVideo: function startReceivingVideo() {\n    return this.changeReceivingMedia('video', true);\n  },\n\n  /**\n   * Starts sending audio to the Webex Teams Cloud\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  startSendingAudio: function startSendingAudio() {\n    return this.changeSendingMedia('audio', true);\n  },\n\n  /**\n   * Starts sending video to the Webex Teams Cloud\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  startSendingVideo: function startSendingVideo() {\n    return this.changeSendingMedia('video', true);\n  },\n\n  /**\n   * Stops sharing an application or whole screen media stream\n   * @returns {Promise}\n   */\n  stopScreenShare: function stopScreenShare() {\n    var _this21 = this;\n\n    this.logger.info('call: stopping screen/application share');\n    return this.releaseFloor().then(function () {\n      return new _promise2.default(function (resolve) {\n        _this21.media.once('answeraccepted', resolve);\n\n        _this21.media.setMedia('screen', 'inactive');\n      });\n    });\n  },\n\n  /**\n   * Stop receiving audio\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  stopReceivingAudio: function stopReceivingAudio() {\n    return this.changeReceivingMedia('audio', false);\n  },\n\n  /**\n   * Stop receiving video\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  stopReceivingVideo: function stopReceivingVideo() {\n    return this.changeReceivingMedia('video', false);\n  },\n\n  /**\n   * Stops sending audio to the Webex Teams Cloud. (stops broadcast immediately,\n   * even if renegotiation has not completed)\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  stopSendingAudio: function stopSendingAudio() {\n    return this.changeSendingMedia('audio', false);\n  },\n\n  /**\n   * Stops sending video to the Webex Teams Cloud. (stops broadcast immediately,\n   * even if renegotiation has not completed)\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  stopSendingVideo: function stopSendingVideo() {\n    return this.changeSendingMedia('video', false);\n  },\n\n  /**\n   * Replaces the current mediaStrem with one with identical constraints, except\n   * for an opposite facing mode. If the current facing mode cannot be\n   * determined, the facing mode will be set to `user`. If the call is audio\n   * only, this function will throw.\n   * @instance\n   * @memberof Call\n   * @returns {undefined}\n   */\n  toggleFacingMode: function toggleFacingMode() {\n    var _this22 = this;\n\n    if (!this.sendingVideo) {\n      throw new Error('Cannot toggle facingMode if we\\'re not sending video');\n    }\n\n    if (this.facingMode !== 'user' && this.facingMode !== 'environment') {\n      throw new Error('Cannot determine current facing mode; specify a new localMediaStream to change cameras');\n    }\n\n    var constraint = {\n      facingMode: {\n        ideal: this.facingMode === 'user' ? 'environment' : 'user'\n      }\n    }; // Constraint changes that don't result in a new sender does not trigger renegotiate\n    // We now use replaceTrack to swap in a new media\n\n    return this.media.setMedia('video', (0, _boolToStatus2.default)(this.sendingAudio, this.sendingVideo), constraint).then(function () {\n      _this22.facingMode = constraint.facingMode.ideal;\n    });\n  },\n\n  /**\n   * Toggles receiving audio from the Webex Teams Cloud\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  toggleReceivingAudio: function toggleReceivingAudio() {\n    return this.receivingAudio ? this.stopReceivingAudio() : this.startReceivingAudio();\n  },\n\n  /**\n   * Toggles receiving video from the Webex Teams Cloud\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  toggleReceivingVideo: function toggleReceivingVideo() {\n    return this.receivingVideo ? this.stopReceivingVideo() : this.startReceivingVideo();\n  },\n\n  /**\n   * Toggles sending audio to the Webex Teams Cloud\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  toggleSendingAudio: function toggleSendingAudio() {\n    return this.sendingAudio ? this.stopSendingAudio() : this.startSendingAudio();\n  },\n\n  /**\n   * Toggles sending video to the Webex Teams Cloud\n   * @instance\n   * @memberof Call\n   * @returns {Promise}\n   */\n  toggleSendingVideo: function toggleSendingVideo() {\n    return this.sendingVideo ? this.stopSendingVideo() : this.startSendingVideo();\n  },\n\n  /**\n   * Changes the status of media\n   * @instance\n   * @memberof Call\n   * @param {Object} payload\n   * @private\n   * @returns {Promise}\n   */\n  updateMedia: function updateMedia(payload) {\n    var _this23 = this;\n\n    this.logger.info('updateMedia');\n\n    if (payload.sdp && !payload.sdp.includes('b=')) {\n      throw new Error('outbound sdp should always have a \\'b=\\' line');\n    }\n\n    return this.webex.internal.locus.updateMedia(this.locus, payload).then(function (locus) {\n      return _this23.setLocus(locus);\n    });\n  },\n\n  /**\n   * Updates sdp with correct video status\n   * @instance\n   * @memberof Call\n   * @param {string} sdp\n   * @param {boolean} isMuted\n   * @private\n   * @returns {Promise}\n   */\n  updateVideoMuteSdp: function updateVideoMuteSdp(sdp, isMuted) {\n    var newDir = boolToDirection(!isMuted, this.receivingVideo);\n    var oldDir = boolToDirection(isMuted, this.receivingVideo);\n    return sdp.replace(new RegExp('a=mid:video[^a]+a=' + oldDir, 'gi'), 'a=mid:video\\na=' + newDir);\n  },\n\n  /**\n   * Tells locus we've got a new media direction\n   * @instance\n   * @memberof Call\n   * @param {string} kind of 'audio' or 'video'\n   * @param {boolean} value\n   * @private\n   * @returns {Promise}\n   */\n  updateMuteToggles: function updateMuteToggles(kind, value) {\n    this.logger.info('updating mute toggles: ' + kind + '=' + value);\n    var payload = {\n      mediaId: this.mediaId,\n      audioMuted: !this.sendingAudio,\n      videoMuted: !this.sendingVideo\n    };\n\n    if (kind === 'audio') {\n      payload.audioMuted = !value;\n    } else if (kind === 'video') {\n      payload.videoMuted = !value;\n      payload.sdp = this.updateVideoMuteSdp(this.media.offerSdp, !value);\n    }\n\n    return this.updateMedia(payload);\n  },\n\n  /**\n   * Checks that this.locus has the expected state\n   * @instance\n   * @memberof Call\n   * @param {Types~Locus} locus\n   * @private\n   * @returns {Promise}\n   */\n  validateLocusMediaState: function validateLocusMediaState(locus) {\n    var locusAudio = locus.self.status.audioStatus.toLowerCase();\n    var mediaAudio = this.media.audioDirection;\n\n    if (locusAudio !== mediaAudio) {\n      this.logger.warn('locus: expected audio ' + locusAudio + ' (locus) to equal ' + mediaAudio + ' (local media)');\n      throw new Error('locus.self.status.audioStatus indicates the received DTO is out of date');\n    }\n\n    var locusVideo = locus.self.status.videoStatus.toLowerCase();\n    var mediaVideo = this.media.videoDirection;\n\n    if (locusVideo !== mediaVideo) {\n      this.logger.warn('locus: expected video ' + locusVideo + ' (locus) to equal ' + mediaVideo + ' (local media)');\n      throw new Error('locus.self.status.videoStatus indicates the received DTO is out of date');\n    }\n\n    return locus;\n  },\n\n  /**\n   * Waits until this.locus describes the expected state\n   * @instance\n   * @memberof Call\n   * @private\n   * @returns {Promise}\n   */\n  waitForExpectedLocus: function waitForExpectedLocus() {\n    var _this24 = this;\n\n    return new _promise2.default(function (resolve) {\n      var listener = function listener() {\n        try {\n          _this24.validateLocusMediaState(_this24.locus);\n\n          _this24.off('change:locus', listener);\n\n          resolve();\n        } catch (err) {\n          _this24.logger.warn('locus: current locus not in expected state; waiting for next locus');\n        }\n      };\n\n      _this24.on('change:locus', listener);\n\n      listener();\n    });\n  },\n  version: '1.69.1'\n}, (_applyDecoratedDescriptor(_obj, 'acknowledge', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'acknowledge'), _obj), _applyDecoratedDescriptor(_obj, 'answer', [_common.oneFlight, _dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'answer'), _obj), _applyDecoratedDescriptor(_obj, 'createOrJoinLocus', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'createOrJoinLocus'), _obj), _applyDecoratedDescriptor(_obj, 'decline', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'decline'), _obj), _applyDecoratedDescriptor(_obj, 'dial', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'dial'), _obj), _applyDecoratedDescriptor(_obj, 'leave', [_common.oneFlight, _dec3], (0, _getOwnPropertyDescriptor2.default)(_obj, 'leave'), _obj), _applyDecoratedDescriptor(_obj, 'onMediaNegotiationNeeded', [_dec4], (0, _getOwnPropertyDescriptor2.default)(_obj, 'onMediaNegotiationNeeded'), _obj), _applyDecoratedDescriptor(_obj, 'pollForExpectedLocusAndSdp', [_common.retry], (0, _getOwnPropertyDescriptor2.default)(_obj, 'pollForExpectedLocusAndSdp'), _obj), _applyDecoratedDescriptor(_obj, 'reject', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'reject'), _obj), _applyDecoratedDescriptor(_obj, 'updateMuteToggles', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'updateMuteToggles'), _obj)), _obj)));\n\nCall.make = function make(attrs, options) {\n  return new Call(attrs, options);\n};\n\nexports.default = Call;","map":null,"metadata":{},"sourceType":"script"}