{"ast":null,"code":"/*!\n * deps/ciphermodes/gcm/index.js - AES-GCM implementation Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar Long = require(\"long\"),\n    forge = require(\"../../../deps/forge.js\"),\n    multipliers = require(\"./multipliers.js\"),\n    helpers = require(\"./helpers.js\"),\n    pack = require(\"../pack.js\"),\n    DataBuffer = require(\"../../../util/databuffer.js\"),\n    cipherHelpers = require(\"../helpers.js\");\n\nvar BLOCK_SIZE = 16; // ### GCM Mode\n// ### Constructor\n\nfunction Gcm(options) {\n  options = options || {};\n  this.name = \"GCM\";\n  this.cipher = options.cipher;\n  this.blockSize = this.blockSize || 16;\n} // ### exports\n\n\nmodule.exports = {\n  createCipher: function (options) {\n    var alg = new forge.aes.Algorithm(\"AES-GCM\", Gcm);\n    alg.initialize({\n      key: new DataBuffer(options.key)\n    });\n    alg.mode.start(options);\n    return alg.mode;\n  },\n  createDecipher: function (options) {\n    var alg = new forge.aes.Algorithm(\"AES-GCM\", Gcm);\n    alg.initialize({\n      key: new DataBuffer(options.key)\n    });\n    alg.mode._decrypt = true;\n    alg.mode.start(options);\n    return alg.mode;\n  }\n}; // ### Public API\n\nGcm.prototype.start = function (options) {\n  this.tag = null;\n  options = options || {};\n\n  if (!(\"iv\" in options)) {\n    throw new Error(\"Gcm needs ParametersWithIV or AEADParameters\");\n  }\n\n  this.nonce = options.iv;\n\n  if (this.nonce == null || this.nonce.length < 1) {\n    throw new Error(\"IV must be at least 1 byte\");\n  } // TODO: variable tagLength?\n\n\n  this.tagLength = 16; // TODO: validate tag\n\n  if (\"tag\" in options) {\n    this.tag = new Buffer(options.tag);\n  }\n\n  var bufLength = !this._decrypt ? this.blockSize : this.blockSize + this.tagLength;\n  this.bufBlock = new Buffer(bufLength);\n  this.bufBlock.fill(0);\n  var multiplier = options.multiplier;\n\n  if (multiplier == null) {\n    multiplier = new multipliers[\"8k\"]();\n  }\n\n  this.multiplier = multiplier;\n  this.H = this.zeroBlock();\n  cipherHelpers.encrypt(this.cipher, this.H, 0, this.H, 0); // GcmMultiplier tables don\"t change unless the key changes\n  // (and are expensive to init)\n\n  this.multiplier.init(this.H);\n  this.exp = null;\n  this.J0 = this.zeroBlock();\n\n  if (this.nonce.length === 12) {\n    this.nonce.copy(this.J0, 0, 0, this.nonce.length);\n    this.J0[this.blockSize - 1] = 0x01;\n  } else {\n    this.gHASH(this.J0, this.nonce, this.nonce.length);\n    var X = this.zeroBlock();\n    pack.longToBigEndian(new Long(this.nonce.length).multiply(8), X, 8);\n    this.gHASHBlock(this.J0, X);\n  }\n\n  this.S = this.zeroBlock();\n  this.SAt = this.zeroBlock();\n  this.SAtPre = this.zeroBlock();\n  this.atBlock = this.zeroBlock();\n  this.atBlockPos = 0;\n  this.atLength = Long.ZERO;\n  this.atLengthPre = Long.ZERO;\n  this.counter = new Buffer(this.J0);\n  this.bufOff = 0;\n  this.totalLength = Long.ZERO;\n\n  if (\"additionalData\" in options) {\n    this.processAADBytes(options.additionalData, 0, options.additionalData.length);\n  }\n};\n\nGcm.prototype.update = function (inV, inOff, len, out, outOff) {\n  var resultLen = 0;\n\n  while (len > 0) {\n    var inLen = Math.min(len, this.bufBlock.length - this.bufOff);\n    inV.copy(this.bufBlock, this.bufOff, inOff, inOff + inLen);\n    len -= inLen;\n    inOff += inLen;\n    this.bufOff += inLen;\n\n    if (this.bufOff === this.bufBlock.length) {\n      this.outputBlock(out, outOff + resultLen);\n      resultLen += this.blockSize;\n    }\n  }\n\n  return resultLen;\n};\n\nGcm.prototype.finish = function (out, outOff) {\n  var resultLen = 0;\n\n  if (this._decrypt) {\n    // append tag\n    resultLen += this.update(this.tag, 0, this.tag.length, out, outOff);\n  }\n\n  if (this.totalLength.isZero()) {\n    this.initCipher();\n  }\n\n  var extra = this.bufOff;\n\n  if (this._decrypt) {\n    if (extra < this.tagLength) {\n      throw new Error(\"data too short\");\n    }\n\n    extra -= this.tagLength;\n  }\n\n  if (extra > 0) {\n    this.gCTRPartial(this.bufBlock, 0, extra, out, outOff + resultLen);\n    resultLen += extra;\n  }\n\n  this.atLength = this.atLength.add(this.atBlockPos); // Final gHASH\n\n  var X = this.zeroBlock();\n  pack.longToBigEndian(this.atLength.multiply(8), X, 0);\n  pack.longToBigEndian(this.totalLength.multiply(8), X, 8);\n  this.gHASHBlock(this.S, X); // TODO Fix this if tagLength becomes configurable\n  // T = MSBt(GCTRk(J0,S))\n\n  var tag = new Buffer(this.blockSize);\n  tag.fill(0);\n  cipherHelpers.encrypt(this.cipher, this.J0, 0, tag, 0);\n  this.xor(tag, this.S);\n\n  if (this._decrypt) {\n    if (!helpers.arrayEqual(this.tag, tag)) {\n      throw new Error(\"mac check in Gcm failed\");\n    }\n  } else {\n    // We place into tag our calculated value for T\n    this.tag = new Buffer(this.tagLength);\n    tag.copy(this.tag, 0, 0, this.tagLength);\n  }\n\n  return resultLen;\n}; // ### \"Internal\" Helper Functions\n\n\nGcm.prototype.initCipher = function () {\n  if (this.atLength.greaterThan(Long.ZERO)) {\n    this.SAt.copy(this.SAtPre, 0, 0, this.blockSize);\n    this.atLengthPre = this.atLength.add(Long.ZERO);\n  } // Finish hash for partial AAD block\n\n\n  if (this.atBlockPos > 0) {\n    this.gHASHPartial(this.SAtPre, this.atBlock, 0, this.atBlockPos);\n    this.atLengthPre = this.atLengthPre.add(this.atBlockPos);\n  }\n\n  if (this.atLengthPre.greaterThan(Long.ZERO)) {\n    this.SAtPre.copy(this.S, 0, 0, this.blockSize);\n  }\n};\n\nGcm.prototype.outputBlock = function (output, offset) {\n  if (this.totalLength.isZero()) {\n    this.initCipher();\n  }\n\n  this.gCTRBlock(this.bufBlock, output, offset);\n\n  if (!this._decrypt) {\n    this.bufOff = 0;\n  } else {\n    this.bufBlock.copy(this.bufBlock, 0, this.blockSize, this.blockSize + this.tagLength);\n    this.bufOff = this.tagLength;\n  }\n};\n\nGcm.prototype.processAADBytes = function (inV, inOff, len) {\n  for (var i = 0; i < len; ++i) {\n    this.atBlock[this.atBlockPos] = inV[inOff + i];\n\n    if (++this.atBlockPos === this.blockSize) {\n      // Hash each block as it fills\n      this.gHASHBlock(this.SAt, this.atBlock);\n      this.atBlockPos = 0;\n      this.atLength = this.atLength.add(this.blockSize);\n    }\n  }\n};\n\nGcm.prototype.getNextCounterBlock = function () {\n  for (var i = 15; i >= 12; --i) {\n    var b = this.counter[i] + 1 & 0xff;\n    this.counter[i] = b;\n\n    if (b !== 0) {\n      break;\n    }\n  } // encrypt counter\n\n\n  var outb = new Buffer(this.blockSize);\n  outb.fill(0);\n  cipherHelpers.encrypt(this.cipher, this.counter, 0, outb, 0);\n  return outb;\n};\n\nGcm.prototype.gCTRBlock = function (block, out, outOff) {\n  var tmp = this.getNextCounterBlock();\n  this.xor(tmp, block);\n  tmp.copy(out, outOff, 0, this.blockSize);\n  this.gHASHBlock(this.S, !this._decrypt ? tmp : block);\n  this.totalLength = this.totalLength.add(this.blockSize);\n};\n\nGcm.prototype.gCTRPartial = function (buf, off, len, out, outOff) {\n  var tmp = this.getNextCounterBlock();\n  this.xor(tmp, buf, off, len);\n  tmp.copy(out, outOff, 0, len);\n  this.gHASHPartial(this.S, !this._decrypt ? tmp : buf, 0, len);\n  this.totalLength = this.totalLength.add(len);\n};\n\nGcm.prototype.gHASHBlock = function (Y, b) {\n  this.xor(Y, b);\n  this.multiplier.multiplyH(Y);\n};\n\nGcm.prototype.gHASHPartial = function (Y, b, off, len) {\n  this.xor(Y, b, off, len);\n  this.multiplier.multiplyH(Y);\n};\n\nGcm.prototype.xor = function (block, val, off, len) {\n  switch (arguments.length) {\n    case 2:\n      for (var i = 15; i >= 0; --i) {\n        block[i] ^= val[i];\n      }\n\n      break;\n\n    case 4:\n      while (len-- > 0) {\n        block[len] ^= val[off + len];\n      }\n\n      break;\n\n    default:\n      throw new TypeError(\"Expected 2 or 4 arguments.\");\n  }\n\n  return block;\n};\n\nGcm.prototype.zeroBlock = function () {\n  var block = new Buffer(BLOCK_SIZE);\n  block.fill(0);\n  return block;\n};","map":null,"metadata":{},"sourceType":"script"}