{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = makeStateDataType;\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n// Reminder: any class using this function must have something like the\n// following in its initialize method:\n//\n// // HACK to deal with the fact that AmpersandState#dataTypes#set is a pure\n// // function.\n// this._dataTypes = cloneDeep(this._dataTypes);\n// Object.keys(this._dataTypes).forEach((key) => {\n//   if (this._dataTypes[key].set) {\n//     this._dataTypes[key].set = this._dataTypes[key].set.bind(this);\n//   }\n// });\n// // END HACK\n\n/**\n * Creates an ampersand state object that wires its event handlers like a an\n * ampersand child\n * @param {Function} Constructor\n * @param {string} name\n * @returns {Object}\n */\n\nfunction makeStateDataType(Constructor, name) {\n  if (!Constructor || !name) {\n    throw new Error('missing parameter for makeStateDataType');\n  }\n\n  return {\n    dataType: {\n      set: function set(newVal) {\n        // newVal.parent = this;\n        if (newVal instanceof Constructor) {\n          newVal.parent = this;\n          return {\n            val: newVal,\n            type: name\n          };\n        } // We only want to construct the new instance if we have some set of\n        // attributes (even an empty object) to base it on. This is to deal with\n        // the unexpected side effect that AmpState#unset will create a new\n        // instance.\n\n\n        return {\n          val: newVal ? new Constructor(newVal, {\n            parent: this\n          }) : undefined,\n          type: name\n        };\n      },\n      compare: function compare(currentValue, newVal) {\n        return currentValue === newVal;\n      },\n      onChange: function onChange(newVal, previousVal, attributeName) {\n        // Copied from ampersand-state.js\n        // if this has changed we want to also handle\n        // event propagation\n        if (previousVal) {\n          this.stopListening(previousVal, 'all', this._getCachedEventBubblingHandler(attributeName));\n        }\n\n        if (newVal) {\n          this.listenTo(newVal, 'all', this._getCachedEventBubblingHandler(attributeName));\n        }\n      }\n    },\n    prop: {\n      /**\n       * This is a really unfortunate hack to deal with ampersand`s decision to\n       * make the dateType#set function pure. The only function called with the\n       * scope of the parent at set time seems to be test\n       * @param {AmpersandState} newVal\n       * @returns {boolean}\n       */\n      test: function test(newVal) {\n        if (!newVal) {\n          return false;\n        }\n\n        newVal.parent = this;\n        return false;\n      },\n      type: name\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"script"}