{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transforms = undefined;\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');\n\nvar _deleteProperty2 = _interopRequireDefault(_deleteProperty);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _symbol = require('babel-runtime/core-js/symbol');\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _isArray2 = require('lodash/isArray');\n\nvar _isArray3 = _interopRequireDefault(_isArray2);\n\nvar _has2 = require('lodash/has');\n\nvar _has3 = _interopRequireDefault(_has2);\n\nvar _get2 = require('lodash/get');\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _curry2 = require('lodash/curry');\n\nvar _curry3 = _interopRequireDefault(_curry2);\n\nvar _capitalize2 = require('lodash/capitalize');\n\nvar _capitalize3 = _interopRequireDefault(_capitalize2);\n\nvar _toArray = require('./to-array');\n\nvar _toArray2 = _interopRequireDefault(_toArray);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar KEY = (0, _symbol2.default)('KEY');\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nvar encryptTextProp = (0, _curry3.default)(function (name, ctx, key, object) {\n  return ctx.transform('encryptTextProp', name, key, object);\n});\nvar encryptJsonProp = (0, _curry3.default)(function (name, ctx, key, object) {\n  return ctx.transform('encryptJsonProp', name, key, object);\n}); // eslint-disable-next-line import/prefer-default-export\n\nvar transforms = exports.transforms = (0, _toArray2.default)('outbound', {\n  encryptObject: function encryptObject(ctx, key, object) {\n    if (!object) {\n      object = key;\n      key = undefined;\n    }\n\n    if (!object) {\n      return _promise2.default.resolve();\n    }\n\n    if (!object.objectType) {\n      return _promise2.default.resolve();\n    }\n\n    if (key === false) {\n      return _promise2.default.resolve();\n    }\n\n    return ctx.transform('encrypt' + (0, _capitalize3.default)(object.objectType), key, object);\n  },\n  encryptConversation: function encryptConversation(ctx, key, conversation) {\n    if (key === false) {\n      return _promise2.default.resolve();\n    }\n\n    return _promise2.default.resolve(key || ctx.webex.internal.encryption.kms.createUnboundKeys({\n      count: 1\n    })).then(function (keys) {\n      var k = (0, _isArray3.default)(keys) ? keys[0] : keys;\n\n      if ((0, _has3.default)(conversation, 'kmsMessage.keyUris') && !conversation.kmsMessage.keyUris.includes(k.uri)) {\n        conversation.kmsMessage.keyUris.push(k.uri);\n      }\n\n      return _promise2.default.all([// too many implicit returns on the same line is difficult to interpret\n      // eslint-disable-next-line arrow-body-style\n      (0, _has3.default)(conversation, 'activities.items') && conversation.activities.items.reduce(function (p, activity) {\n        // eslint-disable-next-line max-nested-callbacks\n        return p.then(function () {\n          return ctx.transform('encryptObject', k, activity);\n        });\n      }, _promise2.default.resolve()), ctx.transform('encryptPropDisplayName', k, conversation)]).then(function () {\n        conversation.encryptionKeyUrl = k.uri || k; // we only want to set the defaultActivityEncryptionKeyUrl if we've\n        // bound a new key\n\n        if (!key) {\n          conversation.defaultActivityEncryptionKeyUrl = conversation.defaultActivityEncryptionKeyUrl || k.uri || k;\n        }\n      });\n    });\n  },\n  encryptActivity: function encryptActivity(ctx, key, activity) {\n    // Activity is already encrypted\n    if (activity.encryptionKeyUrl) {\n      return _promise2.default.resolve();\n    }\n\n    return ctx.transform('encrypt' + (0, _capitalize3.default)(activity.verb) + 'Activity', key, activity).then(function () {\n      key = key || activity[KEY];\n      return ctx.transform('prepareActivityKmsMessage', key, activity);\n    });\n  },\n  encryptVerbActivity: function encryptVerbActivity(ctx, key, activity) {\n    return ctx.transform('maybeEncryptTarget', key, activity).then(function () {\n      key = key || activity[KEY];\n    }).then(function () {\n      return ctx.transform('encryptObject', key, activity.object);\n    });\n  },\n  maybeEncryptTarget: function maybeEncryptTarget(ctx, key, activity) {\n    // This isn't quite right; if we just go by key, we have no guarantee that\n    // we have a proper KRO available for add activities\n    if (key) {\n      return _promise2.default.resolve();\n    }\n\n    if ((0, _has3.default)(activity, 'target.defaultActivityEncryptionKeyUrl') && (0, _has3.default)(activity, 'target.kmsResourceObjectUrl')) {\n      activity[KEY] = key || activity.target.defaultActivityEncryptionKeyUrl;\n      return _promise2.default.resolve();\n    }\n\n    var conversationUrl = activity.target && activity.target.url;\n\n    if (!conversationUrl) {\n      return _promise2.default.reject(new Error('Cannot determine encryption key for activity\\'s conversation; no key url or conversation url provided'));\n    }\n\n    return ctx.webex.internal.conversation.get({\n      url: conversationUrl\n    }).then(function (conversation) {\n      if (!conversation.defaultActivityEncryptionKeyUrl) {\n        return ctx.webex.internal.conversation.updateKey(conversation).then(function (updateKeyActivity) {\n          activity.target.kmsResourceObjectUrl = updateKeyActivity.kmsMessage.resource.uri;\n          activity[KEY] = activity.target.defaultActivityEncryptionKeyUrl = updateKeyActivity.object.defaultActivityEncryptionKeyUrl;\n        });\n      }\n\n      if (!activity.target.defaultActivityEncryptionKeyUrl) {\n        ctx.webex.logger.warn('plugin-conversation: downloaded conversation to determine its defaultActivityEncryptionKeyUrl; make sure to pass all encryption related properties when calling Webex.conversation methods.');\n      }\n\n      if (!activity.target.kmsResourceObjectUrl) {\n        ctx.webex.logger.warn('plugin-conversation: downloaded conversation to determine its kmsResourceObjectUrl; make sure to pass all encryption related properties when calling Webex.conversation methods.');\n      }\n\n      activity[KEY] = activity.target.defaultActivityEncryptionKeyUrl = conversation.defaultActivityEncryptionKeyUrl;\n      activity.target.kmsResourceObjectUrl = conversation.kmsResourceObjectUrl;\n      return _promise2.default.resolve();\n    });\n  },\n  prepareActivityKmsMessage: function prepareActivityKmsMessage(ctx, key, activity) {\n    if (activity.kmsMessage) {\n      if (!key && activity.verb === 'updateKey' && (0, _has3.default)(activity, 'object.defaultActivityEncryptionKeyUrl')) {\n        key = (0, _get3.default)(activity, 'object.defaultActivityEncryptionKeyUrl');\n      }\n\n      if (!key && activity.verb === 'leave' && (0, _has3.default)(activity, 'target.defaultActivityEncryptionKeyUrl')) {\n        key = (0, _get3.default)(activity, 'target.defaultActivityEncryptionKeyUrl');\n      }\n\n      if (key) {\n        var kro = activity.target.kmsResourceObjectUrl;\n        ['uri', 'resourceUri'].forEach(function (k) {\n          if (activity.kmsMessage[k] && !kro && activity.kmsMessage[k].includes('<KRO>')) {\n            throw new Error('encrypter: cannot determine kro');\n          }\n\n          if (activity.kmsMessage[k]) {\n            activity.kmsMessage[k] = activity.kmsMessage[k].replace('<KRO>', kro); // key may be a key or a key url\n\n            activity.kmsMessage[k] = activity.kmsMessage[k].replace('<KEYURL>', key.keyUrl || key);\n          }\n        });\n      } // If we made it this far and still don't have an encryption key, assume\n      // this is a conversation that is not encrypted and we're performing an\n      // action that should not encrypt it (e.g. `leave`)\n      else {\n          (0, _deleteProperty2.default)(activity, 'kmsMessage');\n        }\n    }\n  },\n  encryptVerbActivityWithKey: {\n    direction: 'outbound',\n    fn: function fn(ctx, key, activity) {\n      return ctx.transform('encryptVerbActivity', key, activity).then(function () {\n        key = key || activity[KEY];\n        activity.encryptionKeyUrl = key.uri || key;\n      });\n    }\n  },\n  encryptAddActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivity'\n  },\n  encryptAssignActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n  encryptCreateActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivity'\n  },\n  encryptPostActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n  encryptShareActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n  encryptCardactionActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n  encryptUpdateActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivityWithKey'\n  },\n  encryptUpdateKeyActivity: {\n    direction: 'outbound',\n    alias: 'encryptVerbActivity'\n  },\n  encryptComment: function encryptComment(ctx, key, comment) {\n    return _promise2.default.all([ctx.transform('encryptPropDisplayName', key, comment), ctx.transform('encryptPropContent', key, comment)]);\n  },\n  encryptContent: function encryptContent(ctx, key, content) {\n    var promises = content.files.items.map(function (item) {\n      return ctx.transform('encryptObject', key, item);\n    });\n    promises.push(ctx.transform('encryptPropContent', key, content));\n    promises.push(ctx.transform('encryptPropDisplayName', key, content));\n    return _promise2.default.all(promises);\n  },\n  encryptFile: function encryptFile(ctx, key, file) {\n    if (file.image && !file.image.scr) {\n      return _promise2.default.reject(new Error('`file.image` must have an `scr`'));\n    }\n\n    return _promise2.default.all([ctx.transform('encryptPropScr', key, file), ctx.transform('encryptPropDisplayName', key, file), ctx.transform('encryptPropContent', key, file), file.image && ctx.transform('encryptPropScr', key, file.image)]);\n  },\n  encryptSubmit: function encryptSubmit(ctx, key, submit) {\n    return ctx.transform('encryptPropInputs', key, submit);\n  },\n  // TODO is this used for anything other than the now-removed stickies service?\n  encryptImageURI: function encryptImageURI(ctx, key, imageURI) {\n    return ctx.transform('encryptPropLocation', key, imageURI);\n  },\n  encryptPropContent: encryptTextProp('content'),\n  encryptPropDisplayName: encryptTextProp('displayName'),\n  encryptPropInputs: encryptJsonProp('inputs'),\n  encryptPropLocation: encryptTextProp('location'),\n  encryptPropScr: function encryptPropScr(ctx, key, object) {\n    if (!object.scr) {\n      return _promise2.default.resolve();\n    }\n\n    return ctx.webex.internal.encryption.encryptScr(key, object.scr).then(function (scr) {\n      object.scr = scr;\n    });\n  },\n  encryptJsonProp: function encryptJsonProp(ctx, name, key, object) {\n    if (!object[name]) {\n      return _promise2.default.resolve();\n    }\n\n    return ctx.webex.internal.encryption.encryptText(key.uri || key, (0, _stringify2.default)(object[name])).then(function (ciphertext) {\n      object[name] = ciphertext;\n    });\n  },\n  encryptTextProp: function encryptTextProp(ctx, name, key, object) {\n    if (!object[name]) {\n      return _promise2.default.resolve();\n    }\n\n    return ctx.webex.internal.encryption.encryptText(key.uri || key, object[name]).then(function (ciphertext) {\n      object[name] = ciphertext;\n    });\n  }\n});","map":null,"metadata":{},"sourceType":"script"}