{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');\n\nvar _deleteProperty2 = _interopRequireDefault(_deleteProperty);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _set2 = require('lodash/set');\n\nvar _set3 = _interopRequireDefault(_set2);\n\nvar _get2 = require('lodash/get');\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _camelCase2 = require('lodash/camelCase');\n\nvar _camelCase3 = _interopRequireDefault(_camelCase2);\n\nvar _dec, _dec2, _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _common = require('@webex/common');\n\nvar _backoff = require('backoff');\n\nvar _backoff2 = _interopRequireDefault(_backoff);\n\nvar _socket = require('./socket');\n\nvar _socket2 = _interopRequireDefault(_socket);\n\nvar _errors = require('./errors');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nvar normalReconnectReasons = ['idle', 'done (forced)', 'pong not received', 'pong mismatch'];\n\nvar Mercury = _webexCore.WebexPlugin.extend((_dec = (0, _common.deprecated)('Mercury#listen(): Use Mercury#connect() instead'), _dec2 = (0, _common.deprecated)('Mercury#stopListening(): Use Mercury#disconnect() instead'), (_obj = {\n  namespace: 'Mercury',\n  session: {\n    connected: {\n      default: false,\n      type: 'boolean'\n    },\n    connecting: {\n      default: false,\n      type: 'boolean'\n    },\n    socket: 'object',\n    localClusterServiceUrls: 'object'\n  },\n  derived: {\n    listening: {\n      deps: ['connected'],\n      fn: function fn() {\n        return this.connected;\n      }\n    }\n  },\n  connect: function connect(webSocketUrl) {\n    var _this = this;\n\n    if (this.connected) {\n      this.logger.info('mercury: already connected, will not connect again');\n      return _promise2.default.resolve();\n    }\n\n    this.connecting = true;\n    return _promise2.default.resolve(this.webex.internal.device.registered || this.webex.internal.device.register()).then(function () {\n      _this.logger.info('mercury: connecting');\n\n      return _this._connectWithBackoff(webSocketUrl);\n    });\n  },\n  disconnect: function disconnect() {\n    var _this2 = this;\n\n    return new _promise2.default(function (resolve) {\n      if (_this2.backoffCall) {\n        _this2.logger.info('mercury: aborting connection');\n\n        _this2.backoffCall.abort();\n      }\n\n      if (_this2.socket) {\n        _this2.socket.removeAllListeners('message');\n\n        _this2.once('offline', resolve);\n\n        _this2.socket.close();\n\n        return;\n      }\n\n      resolve();\n    });\n  },\n  listen: function listen() {\n    /* eslint no-invalid-this: [0] */\n    return this.connect();\n  },\n  stopListening: function stopListening() {\n    /* eslint no-invalid-this: [0] */\n    return this.disconnect();\n  },\n  processRegistrationStatusEvent: function processRegistrationStatusEvent(message) {\n    this.localClusterServiceUrls = message.localClusterServiceUrls;\n  },\n  _applyOverrides: function _applyOverrides(event) {\n    if (!event.headers) {\n      return;\n    }\n\n    var headerKeys = (0, _keys2.default)(event.headers);\n    headerKeys.forEach(function (keyPath) {\n      (0, _set3.default)(event, keyPath, event.headers[keyPath]);\n    });\n  },\n  _prepareUrl: function _prepareUrl(webSocketUrl) {\n    var _this3 = this;\n\n    if (!webSocketUrl) {\n      webSocketUrl = this.webex.internal.device.webSocketUrl;\n    }\n\n    return this.webex.internal.feature.getFeature('developer', 'web-high-availability').then(function (haMessagingEnabled) {\n      if (haMessagingEnabled) {\n        return _this3.webex.internal.device.useServiceCatalogUrl(webSocketUrl);\n      }\n\n      return webSocketUrl;\n    }).then(function (wsUrl) {\n      webSocketUrl = wsUrl;\n    }).then(function () {\n      return _this3.webex.internal.feature.getFeature('developer', 'web-shared-mercury');\n    }).then(function (webSharedMercury) {\n      webSocketUrl = _url2.default.parse(webSocketUrl, true);\n      (0, _assign2.default)(webSocketUrl.query, {\n        outboundWireFormat: 'text',\n        bufferStates: true,\n        aliasHttpStatus: true\n      });\n\n      if (webSharedMercury) {\n        (0, _assign2.default)(webSocketUrl.query, {\n          mercuryRegistrationStatus: true,\n          isRegistrationRefreshEnabled: true\n        });\n        (0, _deleteProperty2.default)(webSocketUrl.query, 'bufferStates');\n      }\n\n      if ((0, _get3.default)(_this3, 'webex.config.device.ephemeral', false)) {\n        webSocketUrl.query.multipleConnections = true;\n      }\n\n      return _url2.default.format(webSocketUrl);\n    });\n  },\n  _attemptConnection: function _attemptConnection(socketUrl, callback) {\n    var _this4 = this;\n\n    var socket = new _socket2.default();\n    var attemptWSUrl = void 0;\n    socket.on('close', function () {\n      return _this4._onclose.apply(_this4, arguments);\n    });\n    socket.on('message', function () {\n      return _this4._onmessage.apply(_this4, arguments);\n    });\n    socket.on('sequence-mismatch', function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _this4._emit.apply(_this4, ['sequence-mismatch'].concat(args));\n    });\n\n    _promise2.default.all([this._prepareUrl(socketUrl), this.webex.credentials.getUserToken()]).then(function (_ref) {\n      var _ref2 = (0, _slicedToArray3.default)(_ref, 2),\n          webSocketUrl = _ref2[0],\n          token = _ref2[1];\n\n      attemptWSUrl = webSocketUrl;\n      return socket.open(webSocketUrl, {\n        forceCloseDelay: _this4.config.forceCloseDelay,\n        pingInterval: _this4.config.pingInterval,\n        pongTimeout: _this4.config.pongTimeout,\n        token: token.toString(),\n        trackingId: _this4.webex.sessionId + '_' + Date.now(),\n        logger: _this4.logger\n      });\n    }).then(function () {\n      _this4.socket = socket;\n\n      _this4.webex.internal.metrics.submitClientMetrics('web-ha-mercury', {\n        fields: {\n          success: true\n        },\n        tags: {\n          action: 'connected',\n          url: attemptWSUrl\n        }\n      });\n\n      callback();\n      return _this4.webex.internal.feature.getFeature('developer', 'web-high-availability').then(function (haMessagingEnabled) {\n        if (haMessagingEnabled) {\n          return _this4.webex.internal.device.fetchNewUrls(attemptWSUrl);\n        }\n\n        return _promise2.default.resolve();\n      });\n    }).catch(function (reason) {\n      // Suppress connection errors that appear to be network related. This\n      // may end up suppressing metrics during outages, but we might not care\n      // (especially since many of our outages happen in a way that client\n      // metrics can't be trusted).\n      if (reason.code !== 1006 && _this4.backoffCall && _this4.backoffCall.getNumRetries() > 0) {\n        _this4._emit('connection_failed', reason, {\n          retries: _this4.backoffCall.getNumRetries()\n        });\n      }\n\n      _this4.logger.info('mercury: connection attempt failed', reason); // UnknownResponse is produced by IE for any 4XXX; treated it like a bad\n      // web socket url and let WDM handle the token checking\n\n\n      if (reason instanceof _errors.UnknownResponse) {\n        _this4.logger.info('mercury: received unknown response code, refreshing device registration');\n\n        return _this4.webex.internal.device.refresh().then(function () {\n          return callback(reason);\n        });\n      } // NotAuthorized implies expired token\n\n\n      if (reason instanceof _errors.NotAuthorized) {\n        _this4.logger.info('mercury: received authorization error, reauthorizing');\n\n        return _this4.webex.credentials.refresh({\n          force: true\n        }).then(function () {\n          return callback(reason);\n        });\n      } // // NotFound implies expired web socket url\n      // else if (reason instanceof NotFound) {\n      //   this.logger.info(`mercury: received not found error, refreshing device registration`);\n      //   return this.webex.internal.device.refresh()\n      //     .then(() => callback(reason));\n      // }\n      // BadRequest implies current credentials are for a Service Account\n      // Forbidden implies current user is not entitle for Webex\n\n\n      if (reason instanceof _errors.BadRequest || reason instanceof _errors.Forbidden) {\n        _this4.logger.warn('mercury: received unrecoverable response from mercury');\n\n        _this4.backoffCall.abort();\n\n        return callback(reason);\n      }\n\n      if (reason instanceof _errors.ConnectionError) {\n        return _this4.webex.internal.feature.getFeature('developer', 'web-high-availability').then(function (haMessagingEnabled) {\n          if (haMessagingEnabled) {\n            _this4.logger.info('mercury: received a generic connection error, will try to connect to another datacenter');\n\n            _this4.webex.internal.metrics.submitClientMetrics('web-ha-mercury', {\n              fields: {\n                success: false\n              },\n              tags: {\n                action: 'failed',\n                error: reason.message,\n                url: attemptWSUrl\n              }\n            });\n\n            return _this4.webex.internal.device.markUrlFailedAndGetNew(attemptWSUrl);\n          }\n\n          return null;\n        }).then(function () {\n          return callback(reason);\n        });\n      }\n\n      return callback(reason);\n    }).catch(function (reason) {\n      _this4.logger.error('mercury: failed to handle connection failure', reason);\n\n      callback(reason);\n    });\n  },\n  _connectWithBackoff: function _connectWithBackoff(webSocketUrl) {\n    var _this5 = this;\n\n    return new _promise2.default(function (resolve, reject) {\n      // eslint gets confused about whether or not call is actually used\n      // eslint-disable-next-line prefer-const\n      var call = void 0;\n\n      var onComplete = function onComplete(err) {\n        _this5.connecting = false;\n        _this5.backoffCall = undefined;\n\n        if (err) {\n          _this5.logger.info('mercury: failed to connect after ' + call.getNumRetries() + ' retries; log statement about next retry was inaccurate');\n\n          return reject(err);\n        }\n\n        _this5.connected = true;\n\n        _this5._emit('online');\n\n        return resolve();\n      }; // eslint-disable-next-line prefer-reflect\n\n\n      call = _backoff2.default.call(function (callback) {\n        _this5.logger.info('mercury: executing connection attempt ' + call.getNumRetries());\n\n        _this5._attemptConnection(webSocketUrl, callback);\n      }, onComplete);\n      call.setStrategy(new _backoff2.default.ExponentialStrategy({\n        initialDelay: _this5.config.backoffTimeReset,\n        maxDelay: _this5.config.backoffTimeMax\n      }));\n\n      if (_this5.config.maxRetries) {\n        call.failAfter(_this5.config.maxRetries);\n      }\n\n      call.on('abort', function () {\n        _this5.logger.info('mercury: connection aborted');\n\n        reject();\n      });\n      call.on('callback', function (err) {\n        if (err) {\n          var number = call.getNumRetries();\n          var delay = Math.min(call.strategy_.nextBackoffDelay_, _this5.config.backoffTimeMax);\n\n          _this5.logger.info('mercury: failed to connect; attempting retry ' + (number + 1) + ' in ' + delay + ' ms');\n          /* istanbul ignore if */\n\n\n          if (process.env.NODE_ENV === 'development') {\n            _this5.logger.debug('mercury: ', err, err.stack);\n          }\n\n          return;\n        }\n\n        _this5.logger.info('mercury: connected');\n      });\n      call.start();\n      _this5.backoffCall = call;\n    });\n  },\n  _emit: function _emit() {\n    try {\n      this.trigger.apply(this, arguments);\n    } catch (error) {\n      this.logger.error('mercury: error occurred in event handler', error);\n    }\n  },\n  _getEventHandlers: function _getEventHandlers(eventType) {\n    var _eventType$split = eventType.split('.'),\n        _eventType$split2 = (0, _slicedToArray3.default)(_eventType$split, 2),\n        namespace = _eventType$split2[0],\n        name = _eventType$split2[1];\n\n    var handlers = [];\n\n    if (!this.webex[namespace] && !this.webex.internal[namespace]) {\n      return handlers;\n    }\n\n    var handlerName = (0, _camelCase3.default)('process_' + name + '_event');\n\n    if ((this.webex[namespace] || this.webex.internal[namespace])[handlerName]) {\n      handlers.push({\n        name: handlerName,\n        namespace: namespace\n      });\n    }\n\n    return handlers;\n  },\n  _onclose: function _onclose(event) {\n    // I don't see any way to avoid the complexity or statement count in here.\n\n    /* eslint complexity: [0] */\n    try {\n      var reason = event.reason && event.reason.toLowerCase();\n      var socketUrl = this.socket.url;\n      this.socket.removeAllListeners();\n      this.unset('socket');\n      this.connected = false;\n\n      this._emit('offline', event);\n\n      switch (event.code) {\n        case 1003:\n          // metric: disconnect\n          this.logger.info('mercury: Mercury service rejected last message; will not reconnect: ' + event.reason);\n\n          this._emit('offline.permanent', event);\n\n          break;\n\n        case 4000:\n          // metric: disconnect\n          this.logger.info('mercury: socket replaced; will not reconnect');\n\n          this._emit('offline.replaced', event);\n\n          break;\n\n        case 1001:\n        case 1005:\n        case 1006:\n        case 1011:\n          this.logger.info('mercury: socket disconnected; reconnecting');\n\n          this._emit('offline.transient', event);\n\n          this._reconnect(socketUrl); // metric: disconnect\n          // if (code == 1011 && rason !== ping error) metric: unexpected disconnect\n\n\n          break;\n\n        case 1000:\n          if (normalReconnectReasons.includes(reason)) {\n            this.logger.info('mercury: socket disconnected; reconnecting');\n\n            this._emit('offline.transient', event);\n\n            this._reconnect(socketUrl); // metric: disconnect\n            // if (reason === done forced) metric: force closure\n\n          } else {\n            this.logger.info('mercury: socket disconnected; will not reconnect');\n\n            this._emit('offline.permanent', event);\n          }\n\n          break;\n\n        default:\n          this.logger.info('mercury: socket disconnected unexpectedly; will not reconnect'); // unexpected disconnect\n\n          this._emit('offline.permanent', event);\n\n      }\n    } catch (error) {\n      this.logger.error('mercury: error occurred in close handler', error);\n    }\n  },\n  _onmessage: function _onmessage(event) {\n    var _this6 = this;\n\n    var envelope = event.data;\n\n    if (process.env.ENABLE_MERCURY_LOGGING) {\n      this.logger.debug('mercury: message envelope: ', envelope);\n    }\n\n    var data = envelope.data;\n\n    this._applyOverrides(data);\n\n    return this._getEventHandlers(data.eventType).reduce(function (promise, handler) {\n      return promise.then(function () {\n        var namespace = handler.namespace,\n            name = handler.name;\n        return new _promise2.default(function (resolve) {\n          return resolve((_this6.webex[namespace] || _this6.webex.internal[namespace])[name](data));\n        }).catch(function (reason) {\n          return _this6.logger.error('mercury: error occurred in autowired event handler for ' + data.eventType, reason);\n        });\n      });\n    }, _promise2.default.resolve()).then(function () {\n      _this6._emit('event', event.data);\n\n      var _data$eventType$split = data.eventType.split('.'),\n          _data$eventType$split2 = (0, _slicedToArray3.default)(_data$eventType$split, 1),\n          namespace = _data$eventType$split2[0];\n\n      if (namespace === data.eventType) {\n        _this6._emit('event:' + namespace, envelope);\n      } else {\n        _this6._emit('event:' + namespace, envelope);\n\n        _this6._emit('event:' + data.eventType, envelope);\n      }\n    }).catch(function (reason) {\n      _this6.logger.error('mercury: error occurred processing socket message', reason);\n    });\n  },\n  _reconnect: function _reconnect(webSocketUrl) {\n    this.logger.info('mercury: reconnecting');\n    return this.connect(webSocketUrl);\n  },\n  version: '1.69.1'\n}, (_applyDecoratedDescriptor(_obj, 'connect', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'connect'), _obj), _applyDecoratedDescriptor(_obj, 'disconnect', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'disconnect'), _obj), _applyDecoratedDescriptor(_obj, 'listen', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'listen'), _obj), _applyDecoratedDescriptor(_obj, 'stopListening', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'stopListening'), _obj)), _obj)));\n\nexports.default = Mercury;","map":null,"metadata":{},"sourceType":"script"}