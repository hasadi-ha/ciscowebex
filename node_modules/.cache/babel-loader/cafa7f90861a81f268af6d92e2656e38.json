{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DESYNC = exports.LESS_THAN = exports.GREATER_THAN = exports.FETCH = exports.EQUAL = exports.USE_CURRENT = exports.USE_INCOMING = undefined;\n\nvar _values = require('babel-runtime/core-js/object/values');\n\nvar _values2 = _interopRequireDefault(_values);\n\nvar _map = require('babel-runtime/core-js/map');\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _set = require('babel-runtime/core-js/set');\n\nvar _set2 = _interopRequireDefault(_set);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _memoize2 = require('lodash/memoize');\n\nvar _memoize3 = _interopRequireDefault(_memoize2);\n\nvar _last2 = require('lodash/last');\n\nvar _last3 = _interopRequireDefault(_last2);\n\nvar _first2 = require('lodash/first');\n\nvar _first3 = _interopRequireDefault(_first2);\n\nvar _difference2 = require('lodash/difference');\n\nvar _difference3 = _interopRequireDefault(_difference2);\n\nvar _cloneDeep2 = require('lodash/cloneDeep');\n\nvar _cloneDeep3 = _interopRequireDefault(_cloneDeep2);\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _uuid = require('uuid');\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar USE_INCOMING = exports.USE_INCOMING = 'USE_INCOMING';\nvar USE_CURRENT = exports.USE_CURRENT = 'USE_CURRENT';\nvar EQUAL = exports.EQUAL = 'EQUAL';\nvar FETCH = exports.FETCH = 'FETCH';\nvar GREATER_THAN = exports.GREATER_THAN = 'GREATER_THAN';\nvar LESS_THAN = exports.LESS_THAN = 'LESS_THAN';\nvar DESYNC = exports.DESYNC = 'DESYNC';\n/**\n * Transates the result of a sequence comparison into an intended behavior\n * @param {string} result\n * @private\n * @returns {string}\n */\n\nfunction compareToAction(result) {\n  switch (result) {\n    case EQUAL:\n    case GREATER_THAN:\n      return USE_CURRENT;\n\n    case LESS_THAN:\n      return USE_INCOMING;\n\n    case DESYNC:\n      return FETCH;\n\n    default:\n      throw new Error(result + ' is not a recognized sequence comparison result');\n  }\n}\n/**\n * @class\n */\n\n\nvar Locus = _webexCore.WebexPlugin.extend({\n  namespace: 'Locus',\n\n  /**\n   * Alert the specified locus that the local user has been notified of the\n   * locus's active state\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} locus\n   * @returns {Promise}\n   */\n  alert: function alert(locus) {\n    return this.request({\n      method: 'PUT',\n      uri: locus.url + '/participant/alert',\n      body: {\n        deviceUrl: this.webex.internal.device.url,\n        sequence: locus.sequence\n      }\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * Compares two loci to determine which one contains the most recent state\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @returns {string} one of USE_INCOMING, USE_CURRENT, or FETCH\n   */\n  compare: function compare(current, incoming) {\n    /**\n     * Determines if a paricular locus's sequence is empty\n     * @param {Types~Locus} locus\n     * @private\n     * @returns {bool}\n     */\n    function isEmpty(locus) {\n      var sequence = locus.sequence;\n      return (!sequence.entries || !sequence.entries.length) && sequence.rangeStart === 0 && sequence.rangeEnd === 0;\n    }\n\n    if (isEmpty(current) || isEmpty(incoming)) {\n      return USE_INCOMING;\n    }\n\n    if (incoming.baseSequence) {\n      return this.compareDelta(current, incoming);\n    }\n\n    return compareToAction(this.compareSequence(current.sequence, incoming.sequence));\n  },\n\n  /**\n   * Compares two loci sequences (with delta params) and indicates what action\n   * to take.\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} current\n   * @param {Types~Locus} incoming\n   * @private\n   * @returns {string} one of USE_INCOMING, USE_CURRENT, or FETCH\n   */\n  compareDelta: function compareDelta(current, incoming) {\n    var ret = this.compareSequence(current.sequence, incoming.sequence);\n\n    if (ret !== LESS_THAN) {\n      return compareToAction(ret);\n    }\n\n    ret = this.compareSequence(current.sequence, incoming.baseSequence);\n\n    switch (ret) {\n      case GREATER_THAN:\n      case EQUAL:\n        return USE_INCOMING;\n\n      default:\n        return FETCH;\n    }\n  },\n\n  /**\n   * Compares two Locus sequences\n   * @instance\n   * @memberof Locus\n   * @param {LocusSequence} current\n   * @param {LocusSequence} incoming\n   * @returns {string} one of LESS_THAN, GREATER_THAN, EQUAL, or DESYNC\n   */\n  compareSequence: function compareSequence(current, incoming) {\n    if (!current) {\n      throw new Error('`current` is required');\n    }\n\n    if (!incoming) {\n      throw new Error('`incoming` is required');\n    } // complexity here is unavoidable\n\n    /* eslint complexity: [0] */\n\n    /* eslint max-statements: [0] */\n    // must pick one of arrow-body-style or no-confusing-arrow to disable\n\n    /* eslint arrow-body-style: [0] */\n    // after running the #compare() test suite in a loop, there doesn't seem to\n    // be any appreciable difference when used with or without memoize; since\n    // real locus sequences are likely to contain more sequence numbers than\n    // those in the test suite, I have to assume memoize can only help and the\n    // overhead of memoizing these methods is not a problem.\n\n\n    var getEntriesFirstValue = (0, _memoize3.default)(function (sequence) {\n      return sequence.entries.length === 0 ? 0 : (0, _first3.default)(sequence.entries);\n    });\n    var getEntriesLastValue = (0, _memoize3.default)(function (sequence) {\n      return sequence.entries.length === 0 ? 0 : (0, _last3.default)(sequence.entries);\n    });\n    var getCompareFirstValue = (0, _memoize3.default)(function (sequence) {\n      return sequence.rangeStart || getEntriesFirstValue(sequence);\n    });\n    var getCompareLastValue = (0, _memoize3.default)(function (sequence) {\n      return getEntriesLastValue(sequence) || sequence.rangeEnd;\n    });\n    /**\n     * @param {number} entry\n     * @param {LocusSequence} sequence\n     * @private\n     * @returns {Boolean}\n     */\n\n    function inRange(entry, sequence) {\n      return entry >= sequence.rangeStart && entry <= sequence.rangeEnd;\n    }\n\n    if (getCompareFirstValue(current) > getCompareLastValue(incoming)) {\n      return GREATER_THAN;\n    }\n\n    if (getCompareLastValue(current) < getCompareFirstValue(incoming)) {\n      return LESS_THAN;\n    }\n\n    var currentOnlyEntries = (0, _difference3.default)(current.entries, incoming.entries);\n    var incomingOnlyEntries = (0, _difference3.default)(incoming.entries, current.entries);\n    var currentOnly = [];\n    var incomingOnly = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = (0, _getIterator3.default)(currentOnlyEntries), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var i = _step.value;\n\n        if (!inRange(i, incoming)) {\n          currentOnly.push(i);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = (0, _getIterator3.default)(incomingOnlyEntries), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _i = _step2.value;\n\n        if (!inRange(_i, current)) {\n          incomingOnly.push(_i);\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    if (!currentOnly.length && !incomingOnly.length) {\n      if (current.rangeEnd - getCompareFirstValue(current) > incoming.rangeEnd - getCompareFirstValue(incoming)) {\n        return GREATER_THAN;\n      }\n\n      if (current.rangeEnd - getCompareFirstValue(current) < incoming.rangeEnd - getCompareFirstValue(incoming)) {\n        return LESS_THAN;\n      }\n\n      return EQUAL;\n    }\n\n    if (currentOnly.length && !incomingOnly.length) {\n      return GREATER_THAN;\n    }\n\n    if (!currentOnly.length && incomingOnly.length) {\n      return LESS_THAN;\n    }\n\n    if (!current.rangeStart && !current.rangeEnd && !incoming.rangeStart && !incoming.rangeEnd) {\n      return DESYNC;\n    }\n\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = (0, _getIterator3.default)(currentOnly), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _i2 = _step3.value;\n\n        if (getCompareFirstValue(incoming) < _i2 && _i2 < getCompareLastValue(incoming)) {\n          return DESYNC;\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = (0, _getIterator3.default)(incomingOnly), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _i3 = _step4.value;\n\n        if (getCompareFirstValue(current) < _i3 && _i3 < getCompareLastValue(current)) {\n          return DESYNC;\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    if (currentOnly[0] > incomingOnly[0]) {\n      return GREATER_THAN;\n    }\n\n    return LESS_THAN;\n  },\n\n  /**\n   * Calls the specified invitee and offers the specified media via\n   * options.localSdp\n   * @instance\n   * @memberof Locus\n   * @param {string} invitee\n   * @param {Object} options\n   * @param {Object} options.localSdp\n   * @returns {Promise<Types~Locus>}\n   */\n  create: function create(invitee) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var correlationId = options.correlationId;\n\n    if (!correlationId) {\n      throw new Error('options.correlationId is required');\n    }\n\n    return this.request({\n      method: 'POST',\n      service: 'locus',\n      resource: 'loci/call',\n      body: {\n        correlationId: correlationId,\n        deviceUrl: this.webex.internal.device.url,\n        invitee: {\n          invitee: invitee\n        },\n        localMedias: [{\n          localSdp: (0, _stringify2.default)({\n            type: 'SDP',\n            sdp: options.localSdp\n          })\n        }],\n        sequence: {\n          entries: [],\n          rangeStart: 0,\n          rangeEnd: 0\n        }\n      }\n    }) // res.body.mediaConnections is deprecated so just return the locus\n    .then(function (res) {\n      res.body.locus.self.devices.map(function (item, index) {\n        item.mediaConnections = [res.body.mediaConnections[index]];\n        return item;\n      });\n      return res.body.locus;\n    });\n  },\n\n  /**\n   * This is mostly an internal function to simplify the phone plugin. Decides\n   * which path to call based on the type of the thing being joined.\n   * @instance\n   * @memberof Locus\n   * @param {Object|Types~Locus} target\n   * @param {Object} options\n   * @private\n   * @returns {Promise<Types~Locus>}\n   */\n  createOrJoin: function createOrJoin(target, options) {\n    if (target.url) {\n      return this.join(target, options);\n    }\n\n    return this.create(target, options);\n  },\n\n  /**\n   * Decline to join the specified Locus\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} locus\n   * @returns {Promise<Types~Locus>}\n   */\n  decline: function decline(locus) {\n    var _this = this;\n\n    return this.request({\n      method: 'PUT',\n      uri: locus.url + '/participant/decline',\n      body: {\n        deviceUrl: this.webex.internal.device.url,\n        sequence: locus.sequence\n      }\n    }).then(function (res) {\n      return res.body;\n    }).catch(function (reason) {\n      if (reason instanceof _webexCore.WebexHttpError.Conflict) {\n        return _this.get(locus);\n      }\n\n      return _promise2.default.reject(reason);\n    });\n  },\n\n  /**\n   * Retrieves a single Locus\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} locus\n   * @returns {Types~Locus}\n   */\n  get: function get(locus) {\n    return this.request({\n      method: 'GET',\n      uri: '' + locus.url\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * Retrieves the call history for the current user\n   * @instance\n   * @memberof Locus\n   * @param {Object} options\n   * @param {Date|number} options.from\n   * @returns {Promise<Object>}\n   */\n  getCallHistory: function getCallHistory() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var from = new Date(options.from || Date.now()).toISOString();\n    return this.request({\n      method: 'GET',\n      service: 'janus',\n      resource: 'history/userSessions',\n      qs: {\n        from: from\n      }\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * Join the specified Locus and offer to send it media\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} locus\n   * @param {Object} options\n   * @param {Object} options.localSdp\n   * @returns {Types~Locus}\n   */\n  join: function join(locus) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var correlationId = locus.correlationId || options.correlationId;\n\n    if (!correlationId) {\n      throw new Error('locus.correlationId or options.correlationId is required');\n    }\n\n    return this.request({\n      method: 'POST',\n      uri: locus.url + '/participant',\n      body: {\n        correlationId: correlationId,\n        deviceUrl: this.webex.internal.device.url,\n        localMedias: [{\n          localSdp: (0, _stringify2.default)({\n            type: 'SDP',\n            sdp: options.localSdp\n          })\n        }],\n        sequence: locus.sequence || {\n          entries: [],\n          rangeStart: 0,\n          rangeEnd: 0\n        }\n      }\n    }) // The mediaConnections object is deprecated, so just return the locus\n    .then(function (res) {\n      res.body.locus.self.devices.map(function (item, index) {\n        item.mediaConnections = [res.body.mediaConnections[index]];\n        return item;\n      });\n      return res.body.locus;\n    });\n  },\n\n  /**\n   * Leave the specified Locus\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} locus\n   * @returns {Promise<Types~Locus>}\n   */\n  leave: function leave(locus) {\n    var _this2 = this;\n\n    return this.request({\n      method: 'PUT',\n      uri: locus.self.url + '/leave',\n      body: {\n        deviceUrl: this.webex.internal.device.url,\n        sequence: locus.sequence\n      }\n    }).then(function (res) {\n      return res.body.locus;\n    }).catch(function (reason) {\n      if (reason instanceof _webexCore.WebexHttpError.Conflict) {\n        return _this2.get(locus);\n      }\n\n      return _promise2.default.reject(reason);\n    });\n  },\n\n  /**\n   * Lists active loci\n   * @instance\n   * @memberof Locus\n   * @returns {Promise<Array<Types~Locus>>}\n   */\n  list: function list() {\n    return this.request({\n      method: 'GET',\n      service: 'locus',\n      resource: 'loci'\n    }).then(function (res) {\n      return res.body.loci;\n    });\n  },\n\n  /**\n   * Merges two locus DTOs (for the same locus)\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} current\n   * @param {Types~Locus|Types~LocusDelta} incoming\n   * @returns {Type~Locus}\n   */\n  merge: function merge(current, incoming) {\n    // if incoming is not a delta event, treat it as a new full locus.\n    if (!incoming.baseSequence) {\n      return incoming;\n    }\n\n    var next = (0, _cloneDeep3.default)(current); // 1. All non-null elements in the delta event except the \"baseSequence\" and\n    // the \"participants\" collection should be used to replace their existing\n    // values.\n\n    (0, _keys2.default)(incoming).forEach(function (key) {\n      if (key === 'baseSequence' || key === 'participants') {\n        return;\n      }\n\n      next[key] = incoming[key] || next[key];\n    }); // 2. The \"baseSequence\" in the delta event can be discarded (it doesn't\n    // need to be maintained in the local working copy).\n\n    if (incoming.participants || incoming.participants.length) {\n      var toRemove = new _set2.default();\n      var toUpsert = new _map2.default();\n      incoming.participants.forEach(function (p) {\n        if (p.removed) {\n          // Elements of the delta event's \"participants\" list with the\n          // attribute `removed=true` should be removed from the working copy's\n          // \"participants\" collection.\n          toRemove.add(p.url);\n        } else {\n          // Elements of the delta events \"participants\" list that are absent\n          // from the local working copy should be added to that collection.\n          toUpsert.set(p.url, p);\n        }\n      }); // The \"participants\" collection in the delta event should be merged with\n      // that of the local working copy of the Locus such that elements in the\n      // delta event's \"participants\" replace those with the same url value in\n      // the working copy \"participants\" collection.\n\n      var participants = next.participants.reduce(function (acc, p) {\n        if (!toRemove.has(p.url)) {\n          acc[p.url] = p;\n        }\n\n        return acc;\n      }, {});\n      toUpsert.forEach(function (value, key) {\n        participants[key] = value;\n      });\n      next.participants = (0, _values2.default)(participants);\n    }\n\n    return next;\n  },\n\n  /**\n   * Signals to locus that the current user is done sharing their additional\n   * media stream\n   * @param {Types~Locus} locus\n   * @param {Types~MediaShare} share\n   * @returns {Promise}\n   */\n  releaseFloorGrant: function releaseFloorGrant(locus, share) {\n    return this.webex.request({\n      uri: share.url,\n      method: 'PUT',\n      body: {\n        floor: {\n          disposition: 'RELEASED'\n        }\n      }\n    }).then(function (_ref) {\n      var body = _ref.body;\n      return body;\n    });\n  },\n\n  /**\n   * Signals to locus that the current user would like to share an additional\n   * media stream\n   * @param {Types~Locus} locus\n   * @param {Types~MediaShare} share\n   * @returns {Promise}\n   */\n  requestFloorGrant: function requestFloorGrant(locus, share) {\n    return this.webex.request({\n      uri: share.url,\n      method: 'PUT',\n      body: {\n        floor: {\n          beneficiary: {\n            url: locus.self.url,\n            devices: [{\n              url: this.webex.internal.device.url\n            }]\n          },\n          disposition: 'GRANTED'\n        }\n      }\n    }).then(function (_ref2) {\n      var body = _ref2.body;\n      return body;\n    });\n  },\n\n  /**\n   * Sends a string of DTMF tones to the locus\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} locus\n   * @param {string} tones\n   * @returns {Promise}\n   */\n  sendDtmf: function sendDtmf(locus, tones) {\n    return this.request({\n      method: 'POST',\n      uri: locus.self.url + '/sendDtmf',\n      body: {\n        deviceUrl: this.webex.internal.device.url,\n        dtmf: {\n          correlationId: _uuid2.default.v4(),\n          tones: tones\n        }\n      }\n    });\n  },\n\n  /**\n   * Fetches the delta for the locus from its syncUrl. *Does not merge*\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} locus\n   * @returns {Types~LocusDelta}\n   */\n  sync: function sync(locus) {\n    return this.request({\n      method: 'GET',\n      uri: locus.syncUrl\n    }) // the api may return a 204 no content, so we'll give back an empty\n    // object in that case.\n    .then(function (res) {\n      return res.body || {};\n    });\n  },\n\n  /**\n   * Send a new sdp to Linus via the Locus API to update media state (e.g. to\n   * start or stop sending audio or video)\n   * @instance\n   * @memberof Locus\n   * @param {Types~Locus} locus\n   * @param {Object} options\n   * @param {string} options.localSdp\n   * @param {string} options.mediaId\n   * @param {Boolean} options.audioMuted\n   * @param {Boolean} options.videoMuted\n   * @returns {Promise<Types~Locus>}\n   */\n  updateMedia: function updateMedia(locus, _ref3) {\n    var sdp = _ref3.sdp,\n        audioMuted = _ref3.audioMuted,\n        videoMuted = _ref3.videoMuted,\n        mediaId = _ref3.mediaId;\n    var localSdp = {\n      audioMuted: audioMuted,\n      videoMuted: videoMuted\n    };\n\n    if (sdp) {\n      localSdp.type = 'SDP';\n      localSdp.sdp = sdp;\n    }\n\n    return this.request({\n      method: 'PUT',\n      uri: locus.self.url + '/media',\n      body: {\n        deviceUrl: this.webex.internal.device.url,\n        localMedias: [{\n          localSdp: (0, _stringify2.default)(localSdp),\n          mediaId: mediaId\n        }],\n        sequence: locus.sequence\n      }\n    }).then(function (res) {\n      return res.body.locus;\n    });\n  },\n  version: '1.69.1'\n});\n\nexports.default = Locus;","map":null,"metadata":{},"sourceType":"script"}