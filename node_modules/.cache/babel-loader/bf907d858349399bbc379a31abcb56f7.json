{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _pick2 = require('lodash/pick');\n\nvar _pick3 = _interopRequireDefault(_pick2);\n\nvar _dec, _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar _common = require('@webex/common');\n\nvar _commonTimers = require('@webex/common-timers');\n\nvar _webexHttpError = require('../webex-http-error');\n\nvar _webexHttpError2 = _interopRequireDefault(_webexHttpError);\n\nvar _webexPlugin = require('../webex-plugin');\n\nvar _webexPlugin2 = _interopRequireDefault(_webexPlugin);\n\nvar _scope = require('./scope');\n\nvar _grantErrors = require('./grant-errors');\n\nvar _grantErrors2 = _interopRequireDefault(_grantErrors);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n/* eslint-disable camelcase */\n\n/**\n * Parse response from CI and converts to structured error when appropriate\n * @param {WebexHttpError} res\n * @private\n * @returns {GrantError}\n */\n\n\nfunction processGrantError(res) {\n  if (res.statusCode !== 400) {\n    return _promise2.default.reject(res);\n  }\n\n  var ErrorConstructor = _grantErrors2.default.select(res.body.error);\n\n  if (ErrorConstructor === _grantErrors.OAuthError && res instanceof _webexHttpError2.default) {\n    return _promise2.default.reject(res);\n  }\n\n  if (!ErrorConstructor) {\n    return _promise2.default.reject(res);\n  }\n\n  return _promise2.default.reject(new ErrorConstructor(res._res || res));\n}\n/**\n * @class\n */\n\n\nvar Token = _webexPlugin2.default.extend((_dec = (0, _common.oneFlight)({\n  keyFactory: function keyFactory(scope) {\n    return scope;\n  }\n}), (_obj = {\n  derived: {\n    /**\n     * Indicates if this token can be used in an auth header. `true` iff\n     * {@link Token#access_token} is defined and {@link Token#isExpired} is\n     * false.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canAuthorize: {\n      deps: ['access_token', 'isExpired'],\n      fn: function fn() {\n        return !!this.access_token && !this.isExpired;\n      }\n    },\n\n    /**\n     * Indicates that this token can be downscoped. `true` iff\n     * {@link config.credentials.client_id} is defined and if\n     * {@link Token#canAuthorize} is true\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.client_id}. As such,\n     * {@link config.credentials.client_id} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canDownscope: {\n      deps: ['canAuthorize'],\n      fn: function fn() {\n        return this.canAuthorize && !!this.config.client_id;\n      }\n    },\n\n    /**\n     * Indicates if this token can be refreshed. `true` iff\n     * {@link Token@refresh_token} is defined and\n     * {@link config.credentials.refreshCallback()} is defined\n     *\n     * Note: since {@link config} is not evented, we can't listen for changes to\n     * {@link config.credentials.refreshCallback()}. As such,\n     * {@link config.credentials.refreshCallback()} must always be set before\n     * instantiating a {@link Token}\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    canRefresh: {\n      deps: ['refresh_token'],\n      fn: function fn() {\n        if (_common.inBrowser) {\n          return !!this.refresh_token && !!this.config.refreshCallback;\n        }\n\n        return !!this.refresh_token && !!this.config.client_secret;\n      }\n    },\n\n    /**\n     * Indicates if this `Token` is expired. `true` iff {@link Token#expires} is\n     * defined and is less than {@link Date.now()}.\n     * @instance\n     * @memberof Token\n     * @readonly\n     * @type {boolean}\n     */\n    isExpired: {\n      deps: ['expires', '_isExpired'],\n      fn: function fn() {\n        // in order to avoid setting `cache:false`, we'll use a private property\n        // and a timer rather than comparing to `Date.now()`;\n        return !!this.expires && this._isExpired;\n      }\n    },\n\n    /**\n     * Cache for toString()\n     * @instance\n     * @memberof Token\n     * @private\n     * @readonly\n     * @type {string}\n     */\n    _string: {\n      deps: ['access_token', 'token_type'],\n      fn: function fn() {\n        if (!this.access_token || !this.token_type) {\n          return '';\n        }\n\n        return this.token_type + ' ' + this.access_token;\n      }\n    }\n  },\n  namespace: 'Credentials',\n  props: {\n    /**\n     * Used for indexing in the credentials userTokens collection\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {string}\n     */\n    scope: 'string',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    access_token: 'string',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires: 'number',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    expires_in: 'number',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    refresh_token: 'string',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires: 'number',\n\n    /**\n     * @instance\n     * @memberof Token\n     * @type {number}\n     */\n    refresh_token_expires_in: 'number',\n\n    /**\n     * @default \"Bearer\"\n     * @instance\n     * @memberof Token\n     * @type {string}\n     */\n    token_type: {\n      default: 'Bearer',\n      type: 'string'\n    }\n  },\n  session: {\n    /**\n     * Used by {@link Token#isExpired} to avoid doing a Date comparison.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {boolean}\n     */\n    _isExpired: {\n      default: false,\n      type: 'boolean'\n    },\n\n    /**\n     * Handle to the previous token that we'll revoke when we refresh this\n     * token. The idea is to keep allow two valid tokens when a refresh occurs;\n     * we don't want revoke a token that's in the middle of being used, so when\n     * we do a token refresh, we won't revoke the token being refreshed, but\n     * we'll revoke the previous one.\n     * @instance\n     * @memberof Token\n     * @private\n     * @type {Object}\n     */\n    previousToken: {\n      type: 'state'\n    }\n  },\n\n  /**\n   * Uses this token to request a new Token with a subset of this Token's scopes\n   * @instance\n   * @memberof Token\n   * @param {string} scope\n   * @returns {Promise<Token>}\n   */\n  downscope: function downscope(scope) {\n    var _this = this;\n\n    this.logger.info('token: downscoping token to ' + scope);\n\n    if (this.isExpired) {\n      this.logger.info('token: request received to downscope expired access_token');\n      return _promise2.default.reject(new Error('cannot downscope expired access token'));\n    }\n\n    if (!this.canDownscope) {\n      if (this.config.client_id) {\n        this.logger.info('token: request received to downscope invalid access_token');\n      } else {\n        this.logger.trace('token: cannot downscope without client_id');\n      }\n\n      return _promise2.default.reject(new Error('cannot downscope access token'));\n    } // Since we're going to use scope as the index in our token collection, it's\n    // important scopes are always deterministically specified.\n\n\n    if (scope) {\n      scope = (0, _scope.sortScope)(scope);\n    } // Ideally, we could depend on the service to communicate this error, but\n    // all we get is \"invalid scope\", which, to the lay person, implies\n    // something wrong with *one* of the scopes, not the whole thing.\n\n\n    if (scope === (0, _scope.sortScope)(this.config.scope)) {\n      return _promise2.default.reject(new Error('token: scope reduction requires a reduced scope'));\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      addAuthHeader: false,\n      form: {\n        grant_type: 'urn:cisco:oauth:grant-type:scope-reduction',\n        token: this.access_token,\n        scope: scope,\n        client_id: this.config.client_id\n      }\n    }).then(function (res) {\n      _this.logger.info('token: downscoped token to ' + scope);\n\n      return new Token((0, _assign2.default)(res.body, {\n        scope: scope\n      }), {\n        parent: _this.parent\n      });\n    });\n  },\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Token\n   * @param {Object} [attrs={}]\n   * @param {Object} [options={}]\n   * @see {@link WebexPlugin#initialize()}\n   * @returns {Token}\n   */\n  initialize: function initialize() {\n    var _this2 = this;\n\n    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _apply2.default)(_webexPlugin2.default.prototype.initialize, this, [attrs, options]);\n\n    if (typeof attrs === 'string') {\n      this.access_token = attrs;\n    }\n\n    if (!this.access_token) {\n      throw new Error('`access_token` is required');\n    } // We don't want the derived property `isExpired` to need {cache:false}, so\n    // we'll set up a timer the runs when this token should expire.\n\n\n    if (this.expires) {\n      if (this.expires < Date.now()) {\n        this._isExpired = true;\n      } else {\n        (0, _commonTimers.safeSetTimeout)(function () {\n          _this2._isExpired = true;\n        }, this.expires - Date.now());\n      }\n    }\n  },\n\n  /**\n   * Refreshes this Token. Relies on\n   * {@link config.credentials.refreshCallback()}\n   * @instance\n   * @memberof Token\n   * @returns {Promise<Token>}\n   */\n  refresh: function refresh() {\n    var _this3 = this;\n\n    if (!this.canRefresh) {\n      throw new Error('Not enough information available to refresh this access token');\n    }\n\n    var promise = void 0;\n\n    if (_common.inBrowser) {\n      if (!this.config.refreshCallback) {\n        throw new Error('Cannot refresh access token without refreshCallback');\n      }\n\n      promise = _promise2.default.resolve(this.config.refreshCallback(this.webex, this));\n    }\n\n    return (promise || this.webex.request({\n      method: 'POST',\n      uri: this.config.tokenUrl,\n      form: {\n        grant_type: 'refresh_token',\n        redirect_uri: this.config.redirect_uri,\n        refresh_token: this.refresh_token\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    }).then(function (res) {\n      return res.body;\n    })).then(function (obj) {\n      if (!obj) {\n        throw new Error('token: refreshCallback() did not produce an object');\n      } // If the authentication server did not send back a refresh token, copy\n      // the current refresh token and related values to the response (note:\n      // at time of implementation, CI never sends a new refresh token)\n\n\n      if (!obj.refresh_token) {\n        (0, _assign2.default)(obj, (0, _pick3.default)(_this3, 'refresh_token', 'refresh_token_expires', 'refresh_token_expires_in'));\n      } // If the new token is the same as the previous token, then we may have\n      // found a bug in CI; log the details and reject the Promise\n\n\n      if (_this3.access_token === obj.access_token) {\n        _this3.logger.error('token: new token matches current token'); // log the tokens if it is not production\n\n\n        if (process.env.NODE_ENV !== 'production') {\n          _this3.logger.error('token: current token:', _this3.access_token);\n\n          _this3.logger.error('token: new token:', obj.access_token);\n        }\n\n        return _promise2.default.reject(new Error('new token matches current token'));\n      }\n\n      if (_this3.previousToken) {\n        _this3.previousToken.revoke();\n\n        _this3.unset('previousToken');\n      }\n\n      obj.previousToken = _this3;\n      obj.scope = _this3.scope;\n      return new Token(obj, {\n        parent: _this3.parent\n      });\n    }).catch(processGrantError);\n  },\n\n  /**\n   * Revokes this token and unsets its local properties\n   * @instance\n   * @memberof Token\n   * @returns {Promise}\n   */\n  revoke: function revoke() {\n    var _this4 = this;\n\n    if (this.isExpired) {\n      this.logger.info('token: already expired, not making making revocation request');\n      return _promise2.default.resolve();\n    }\n\n    if (!this.canAuthorize) {\n      this.logger.info('token: no longer valid, not making revocation request');\n      return _promise2.default.resolve();\n    } // FIXME we need to use the user token revocation endpoint to revoke a token\n    // without a client_secret, but it doesn't current support using a token to\n    // revoke itself\n    // Note: I'm not making a canRevoke property because there should be changes\n    // coming to the user token revocation endpoint that allow us to do this\n    // correctly.\n\n\n    if (!this.config.client_secret) {\n      this.logger.info('token: no client secret available, not making revocation request');\n      return _promise2.default.resolve();\n    }\n\n    this.logger.info('token: revoking access token');\n    return this.webex.request({\n      method: 'POST',\n      uri: this.config.revokeUrl,\n      form: {\n        token: this.access_token,\n        token_type_hint: 'access_token'\n      },\n      auth: {\n        user: this.config.client_id,\n        pass: this.config.client_secret,\n        sendImmediately: true\n      },\n      shouldRefreshAccessToken: false\n    }).then(function () {\n      _this4.unset(['access_token', 'expires', 'expires_in', 'token_type']);\n\n      _this4.logger.info('token: access token revoked');\n    }).catch(processGrantError);\n  },\n  set: function set() {\n    // eslint-disable-next-line prefer-const\n    var _filterSetParameters = this._filterSetParameters.apply(this, arguments),\n        _filterSetParameters2 = (0, _slicedToArray3.default)(_filterSetParameters, 2),\n        attrs = _filterSetParameters2[0],\n        options = _filterSetParameters2[1];\n\n    if (!attrs.token_type && attrs.access_token && attrs.access_token.includes(' ')) {\n      var _attrs$access_token$s = attrs.access_token.split(' '),\n          _attrs$access_token$s2 = (0, _slicedToArray3.default)(_attrs$access_token$s, 2),\n          token_type = _attrs$access_token$s2[0],\n          access_token = _attrs$access_token$s2[1];\n\n      attrs = (0, _assign2.default)({}, attrs, {\n        access_token: access_token,\n        token_type: token_type\n      });\n    }\n\n    var now = Date.now();\n\n    if (!attrs.expires && attrs.expires_in) {\n      attrs.expires = now + attrs.expires_in * 1000;\n    }\n\n    if (!attrs.refresh_token_expires && attrs.refresh_token_expires_in) {\n      attrs.refresh_token_expires = now + attrs.refresh_token_expires_in * 1000;\n    }\n\n    if (attrs.scope) {\n      attrs.scope = (0, _scope.sortScope)(attrs.scope);\n    }\n\n    return (0, _apply2.default)(_webexPlugin2.default.prototype.set, this, [attrs, options]);\n  },\n\n  /**\n   * Renders the token object as an HTTP Header Value\n   * @instance\n   * @memberof Token\n   * @returns {string}\n   * @see {@link Object#toString()}\n   */\n  toString: function toString() {\n    if (!this._string) {\n      throw new Error('cannot stringify Token');\n    }\n\n    return this._string;\n  },\n\n  /**\n   * Uses a non-producation api to return information about this token. This\n   * method is primarily for tests and will throw if NODE_ENV === production\n   * @instance\n   * @memberof Token\n   * @private\n   * @returns {Promise}\n   */\n  validate: function validate() {\n    var _this5 = this;\n\n    if (process.env.NODE_ENV === 'production') {\n      throw new Error('Token#validate() must not be used in production');\n    }\n\n    return this.webex.request({\n      method: 'POST',\n      service: 'conversation',\n      resource: 'users/validateAuthToken',\n      body: {\n        token: this.access_token\n      }\n    }).catch(function (reason) {\n      if ('statusCode' in reason) {\n        return _promise2.default.reject(reason);\n      }\n\n      _this5.logger.info('REMINDER: If you\\'re investigating a network error here, it\\'s normal'); // If we got an error that isn't a WebexHttpError, assume the problem is\n      // that we don't have the wdm plugin loaded and service/resource isn't\n      // a valid means of identifying a request.\n\n\n      var convApi = process.env.CONVERSATION_SERVICE || process.env.CONVERSATION_SERVICE_URL || 'https://conv-a.wbx2.com/conversation/api/v1';\n      return _this5.webex.request({\n        method: 'POST',\n        uri: convApi + '/users/validateAuthToken',\n        body: {\n          token: _this5.access_token\n        },\n        headers: {\n          authorization: 'Bearer ' + _this5.access_token\n        }\n      });\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n  version: '1.69.1'\n}, (_applyDecoratedDescriptor(_obj, 'downscope', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'downscope'), _obj), _applyDecoratedDescriptor(_obj, 'refresh', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'refresh'), _obj), _applyDecoratedDescriptor(_obj, 'revoke', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'revoke'), _obj)), _obj)));\n\nexports.default = Token;","map":null,"metadata":{},"sourceType":"script"}