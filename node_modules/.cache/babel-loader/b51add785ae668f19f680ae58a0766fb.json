{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _symbol = require('babel-runtime/core-js/symbol');\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _commonTimers = require('@webex/common-timers');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar sym = (0, _symbol2.default)('metric id');\n\nvar MetricsBatcher = _webexCore.Batcher.extend({\n  namespace: 'Metrics',\n  prepareItem: function prepareItem(item) {\n    // Keep non-prod data out of metrics\n    var env = process.env.NODE_ENV === 'production' ? null : 'TEST';\n    item.appType = item.appType || this.config.appType;\n    item.env = item.env || env;\n    item.time = item.time || Date.now();\n    item.version = item.version || this.spark.version;\n    return _promise2.default.resolve(item);\n  },\n  prepareRequest: function prepareRequest(queue) {\n    return _promise2.default.resolve(queue.map(function (item) {\n      item.postTime = item.postTime || Date.now();\n      return item;\n    }));\n  },\n  submitHttpRequest: function submitHttpRequest(payload) {\n    return this.spark.request({\n      method: 'POST',\n      service: 'metrics',\n      resource: 'metrics',\n      body: {\n        metrics: payload\n      }\n    });\n  },\n  handleHttpSuccess: function handleHttpSuccess(res) {\n    var _this = this;\n\n    return _promise2.default.all(res.options.body.metrics.map(function (item) {\n      return _this.acceptItem(item);\n    }));\n  },\n  handleHttpError: function handleHttpError(reason) {\n    var _this2 = this;\n\n    if (reason instanceof _webexCore.SparkHttpError.NetworkOrCORSError) {\n      this.logger.warn('metrics-batcher: received network error submitting metrics, reenqueuing payload');\n      return _promise2.default.all(reason.options.body.metrics.map(function (item) {\n        return new _promise2.default(function (resolve) {\n          var delay = item[sym].nextDelay;\n\n          if (delay < _this2.config.batcherRetryPlateau) {\n            item[sym].nextDelay *= 2;\n          }\n\n          (0, _commonTimers.safeSetTimeout)(function () {\n            resolve(_this2.rerequest(item));\n          }, delay);\n        });\n      }));\n    }\n\n    return (0, _apply2.default)(_webexCore.Batcher.prototype.handleHttpError, this, [reason]);\n  },\n  rerequest: function rerequest(item) {\n    var _this3 = this;\n\n    return _promise2.default.all([this.getDeferredForRequest(item), this.prepareItem(item)]).then(function (_ref) {\n      var _ref2 = (0, _slicedToArray3.default)(_ref, 2),\n          defer = _ref2[0],\n          req = _ref2[1];\n\n      _this3.enqueue(req).then(function () {\n        return _this3.bounce();\n      }).catch(function (reason) {\n        return defer.reject(reason);\n      });\n    });\n  },\n  fingerprintRequest: function fingerprintRequest(item) {\n    item[sym] = item[sym] || {\n      nextDelay: 1000\n    };\n    return _promise2.default.resolve(item[sym]);\n  },\n  fingerprintResponse: function fingerprintResponse(item) {\n    return _promise2.default.resolve(item[sym]);\n  }\n});\n\nexports.default = MetricsBatcher;","map":null,"metadata":{},"sourceType":"script"}