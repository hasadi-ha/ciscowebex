{"ast":null,"code":"/*!\n * jwk/basekey.js - JWK Key Base Class Implementation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar assign = require(\"lodash.assign\"),\n    clone = require(\"lodash.clone\"),\n    flatten = require(\"lodash.flatten\"),\n    intersection = require(\"lodash.intersection\"),\n    merge = require(\"../util/merge\"),\n    omit = require(\"lodash.omit\"),\n    pick = require(\"lodash.pick\"),\n    uniq = require(\"lodash.uniq\"),\n    uuid = require(\"uuid\");\n\nvar ALGORITHMS = require(\"../algorithms\"),\n    CONSTANTS = require(\"./constants.js\"),\n    HELPERS = require(\"./helpers.js\"),\n    UTIL = require(\"../util\");\n/**\n * @class JWK.Key\n * @classdesc\n * Represents a JSON Web Key instance.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call\n * {@link JWK.asKey}, {@link JWK.KeyStore#add}, or\n * {@link JWK.KeyStore#generate}.\n */\n\n\nvar JWKBaseKeyObject = function (kty, ks, props, cfg) {\n  // ### validate/coerce arguments ###\n  if (!kty) {\n    throw new Error(\"kty cannot be null\");\n  }\n\n  if (!ks) {\n    throw new Error(\"keystore cannot be null\");\n  }\n\n  if (!props) {\n    throw new Error(\"props cannot be null\");\n  } else if (\"string\" === typeof props) {\n    props = JSON.parse(props);\n  }\n\n  if (!cfg) {\n    throw new Error(\"cfg cannot be null\");\n  }\n\n  var excluded = [];\n  var keys = {},\n      json = {},\n      prints,\n      kid;\n  props = clone(props); // strip thumbprints if present\n\n  prints = assign({}, props[HELPERS.INTERNALS.THUMBPRINT_KEY] || {});\n  delete props[HELPERS.INTERNALS.THUMBPRINT_KEY];\n  Object.keys(prints).forEach(function (a) {\n    var h = prints[a];\n\n    if (!kid) {\n      kid = h;\n\n      if (Buffer.isBuffer(kid)) {\n        kid = UTIL.base64url.encode(kid);\n      }\n    }\n\n    if (!Buffer.isBuffer(h)) {\n      h = UTIL.base64url.decode(h);\n      prints[a] = h;\n    }\n  }); // force certain values\n\n  props.kty = kty;\n  props.kid = props.kid || kid || uuid(); // setup base info\n\n  var included = Object.keys(HELPERS.COMMON_PROPS).map(function (p) {\n    return HELPERS.COMMON_PROPS[p].name;\n  });\n  json.base = pick(props, included);\n  excluded = excluded.concat(Object.keys(json.base)); // setup public information\n\n  json.public = clone(props);\n  keys.public = cfg.publicKey(json.public);\n\n  if (keys.public) {\n    // exclude public values from extra\n    excluded = excluded.concat(Object.keys(json.public));\n  } // setup private information\n\n\n  json.private = clone(props);\n  keys.private = cfg.privateKey(json.private);\n\n  if (keys.private) {\n    // exclude private values from extra\n    excluded = excluded.concat(Object.keys(json.private));\n  } // setup extra information\n\n\n  json.extra = omit(props, excluded); // TODO: validate 'alg' against supported algorithms\n  // setup calculated values\n\n  var keyLen;\n\n  if (keys.public && \"length\" in keys.public) {\n    keyLen = keys.public.length;\n  } else if (keys.private && \"length\" in keys.private) {\n    keyLen = keys.private.length;\n  } else {\n    keyLen = NaN;\n  } // ### Public Properties ###\n\n  /**\n   * @member {JWK.KeyStore} JWK.Key#keystore\n   * @description\n   * The owning keystore.\n   */\n\n\n  Object.defineProperty(this, \"keystore\", {\n    value: ks,\n    enumerable: true\n  });\n  /**\n   * @member {Number} JWK.Key#length\n   * @description\n   * The size of this Key, in bits.\n   */\n\n  Object.defineProperty(this, \"length\", {\n    value: keyLen,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#kty\n   * @description\n   * The type of Key.\n   */\n\n  Object.defineProperty(this, \"kty\", {\n    value: kty,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#kid\n   * @description\n   * The identifier for this Key.\n   */\n\n  Object.defineProperty(this, \"kid\", {\n    value: json.base.kid,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#use\n   * @description\n   * The usage for this Key.\n   */\n\n  Object.defineProperty(this, \"use\", {\n    value: json.base.use || \"\",\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#alg\n   * @description\n   * The sole algorithm this key can be used for.\n   */\n\n  Object.defineProperty(this, \"alg\", {\n    value: json.base.alg || \"\",\n    enumerable: true\n  }); // ### Public Methods ###\n\n  /**\n   * Generates the thumbprint of this Key.\n   *\n   * @param {String} [] The hash algorithm to use\n   * @returns {Promise} The promise for the thumbprint generation.\n   */\n\n  Object.defineProperty(this, \"thumbprint\", {\n    value: function (hash) {\n      hash = (hash || HELPERS.INTERNALS.THUMBPRINT_HASH).toUpperCase();\n\n      if (prints[hash]) {\n        // return cached value\n        return Promise.resolve(prints[hash]);\n      }\n\n      var p = HELPERS.thumbprint(cfg, json, hash);\n      p = p.then(function (result) {\n        if (result) {\n          prints[hash] = result;\n        }\n\n        return result;\n      });\n      return p;\n    }\n  });\n  /**\n   * @method JWK.Key#algorithms\n   * @description\n   * The possible algorithms this Key can be used for. The returned\n   * list is not any particular order, but is filtered based on the\n   * Key's intended usage.\n   *\n   * @param {String} mode The operation mode\n   * @returns {String[]} The list of supported algorithms\n   * @see JWK.Key#supports\n   */\n\n  Object.defineProperty(this, \"algorithms\", {\n    value: function (mode) {\n      var modes = [];\n\n      if (!this.use || this.use === \"sig\") {\n        if (!mode || CONSTANTS.MODE_SIGN === mode) {\n          modes.push(CONSTANTS.MODE_SIGN);\n        }\n\n        if (!mode || CONSTANTS.MODE_VERIFY === mode) {\n          modes.push(CONSTANTS.MODE_VERIFY);\n        }\n      }\n\n      if (!this.use || this.use === \"enc\") {\n        if (!mode || CONSTANTS.MODE_ENCRYPT === mode) {\n          modes.push(CONSTANTS.MODE_ENCRYPT);\n        }\n\n        if (!mode || CONSTANTS.MODE_DECRYPT === mode) {\n          modes.push(CONSTANTS.MODE_DECRYPT);\n        }\n\n        if (!mode || CONSTANTS.MODE_WRAP === mode) {\n          modes.push(CONSTANTS.MODE_WRAP);\n        }\n\n        if (!mode || CONSTANTS.MODE_UNWRAP === mode) {\n          modes.push(CONSTANTS.MODE_UNWRAP);\n        }\n      }\n\n      var self = this;\n      var algs = modes.map(function (m) {\n        return cfg.algorithms.call(self, keys, m);\n      });\n      algs = flatten(algs);\n      algs = uniq(algs);\n\n      if (this.alg) {\n        // TODO: fix this correctly\n        var valid;\n\n        if (\"oct\" === kty) {\n          valid = [this.alg, \"dir\"];\n        } else {\n          valid = [this.alg];\n        }\n\n        algs = intersection(algs, valid);\n      }\n\n      return algs;\n    }\n  });\n  /**\n   * @method JWK.Key#supports\n   * @description\n   * Determines if the given algorithm is supported.\n   *\n   * @param {String} alg The algorithm in question\n   * @param {String} [mode] The operation mode\n   * @returns {Boolean} `true` if {alg} is supported, and `false` otherwise.\n   * @see JWK.Key#algorithms\n   */\n\n  Object.defineProperty(this, \"supports\", {\n    value: function (alg, mode) {\n      return this.algorithms(mode).indexOf(alg) !== -1;\n    }\n  });\n  /**\n   * @method JWK.Key#has\n   * @description\n   * Determines if this Key contains the given parameter.\n   *\n   * @param {String} name The name of the parameter\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        checked.\n   * @returns {Boolean} `true` if the given parameter is present; `false`\n   *          otherwise.\n   */\n\n  Object.defineProperty(this, \"has\", {\n    value: function (name, isPrivate) {\n      var contains = false;\n      contains = contains || !!(json.base && name in json.base);\n      contains = contains || !!(keys.public && name in keys.public);\n      contains = contains || !!(json.extra && name in json.extra);\n      contains = contains || !!(isPrivate && keys.private && name in keys.private); // TODO: check for export restrictions\n\n      return contains;\n    }\n  });\n  /**\n   * @method JWK.Key#get\n   * @description\n   * Retrieves the value of the given parameter. The value returned by this\n   * method is in its natural format, which might not exactly match its\n   * JSON encoding (e.g., a binary string rather than a base64url-encoded\n   * string).\n   *\n   * **NOTE:** This method can return `false`. Call\n   * {@link JWK.Key#has} to determine if the parameter is present.\n   *\n   * @param {String} name The name of the parameter\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should\n   *        be checked.\n   * @returns {any} The value of the named parameter, or undefined if\n   *          it is not present.\n   */\n\n  Object.defineProperty(this, \"get\", {\n    value: function (name, isPrivate) {\n      var src;\n\n      if (json.base && name in json.base) {\n        src = json.base;\n      } else if (keys.public && name in keys.public) {\n        src = keys.public;\n      } else if (json.extra && name in json.extra) {\n        src = json.extra;\n      } else if (isPrivate && keys.private && name in keys.private) {\n        // TODO: check for export restrictions\n        src = keys.private;\n      }\n\n      return src && src[name] || null;\n    }\n  });\n  /**\n   * @method JWK.Key#toJSON\n   * @description\n   * Returns the JSON representation of this Key.  All properties of the\n   * returned JSON object are properly encoded (e.g., base64url encoding for\n   * any binary strings).\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @param {String[]} [excluded] The list of parameters to exclude from\n   *        the returned JSON.\n   * @returns {Object} The plain JSON object\n   */\n\n  Object.defineProperty(this, \"toJSON\", {\n    value: function (isPrivate, excluded) {\n      // coerce arguments\n      if (Array.isArray(isPrivate)) {\n        excluded = isPrivate;\n        isPrivate = false;\n      }\n\n      var result = {}; // TODO: check for export restrictions\n\n      result = merge(result, json.base, json.public, \"boolean\" === typeof isPrivate && isPrivate ? json.private : {}, json.extra);\n      result = omit(result, excluded || []);\n      return result;\n    }\n  });\n  /**\n   * @method JWK.Key#toPEM\n   * @description\n   * Returns the PEM representation of this Key as a string.\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @returns {string} The PEM-encoded string\n   */\n\n  Object.defineProperty(this, \"toPEM\", {\n    value: function (isPrivate) {\n      if (isPrivate === null) {\n        isPrivate = false;\n      }\n\n      if (!cfg.convertToPEM) {\n        throw new Error(\"Unsupported key type for PEM encoding\");\n      }\n\n      var k = isPrivate ? keys.private : keys.public;\n\n      if (!k) {\n        throw new Error(\"Invalid key\");\n      }\n\n      return cfg.convertToPEM.call(this, k, isPrivate);\n    }\n  });\n  /**\n   * @method JWK.Key#toObject\n   * @description\n   * Returns the plain object representing this Key.  All properties of the\n   * returned object are in their natural encoding (e.g., binary strings\n   * instead of base64url encoded).\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @param {String[]} [excluded] The list of parameters to exclude from\n   *        the returned object.\n   * @returns {Object} The plain Object.\n   */\n\n  Object.defineProperty(this, \"toObject\", {\n    value: function (isPrivate, excluded) {\n      // coerce arguments\n      if (Array.isArray(isPrivate)) {\n        excluded = isPrivate;\n        isPrivate = false;\n      }\n\n      var result = {}; // TODO: check for export restrictions\n\n      result = merge(result, json.base, keys.public, \"boolean\" === typeof isPrivate && isPrivate ? keys.private : {}, json.extra);\n      result = omit(result, (excluded || []).concat(\"length\"));\n      return result;\n    }\n  });\n  /**\n   * @method JWK.Key#sign\n   * @description\n   * Sign the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive signing operation; the output is\n   * _**NOT**_ a JSON Web Signature (JWS) object.\n   *\n   * The Promise, when fulfilled, returns an Object with the following\n   * properties:\n   *\n   * + **data**: The data that was signed (and should be equal to {data}).\n   * + **mac**: The signature or message authentication code (MAC).\n   *\n   * @param {String} alg The signing algorithm\n   * @param {String|Buffer} data The data to sign\n   * @param {Object} [props] Additional properties for the signing\n   *        algorithm.\n   * @returns {Promise} The promise for the signing operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n\n  Object.defineProperty(this, \"sign\", {\n    value: function (alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"sign\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n\n      var k = cfg.signKey.call(this, alg, keys);\n\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      } // prepare properties (if any)\n\n\n      props = props ? clone(props) : {};\n\n      if (cfg.signProps) {\n        props = merge(props, cfg.signProps.call(this, alg, props));\n      }\n\n      return ALGORITHMS.sign(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#verify\n   * @description\n   * Verify the given data and signature using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive verification operation; the input is\n   * _**NOT**_ a JSON Web Signature.</p>\n   *\n   * The Promise, when fulfilled, returns an Object with the following\n   * properties:\n   *\n   * + **data**: The data that was verified (and should be equal to\n   *   {data}).\n   * + **mac**: The signature or MAC that was verified (and should be equal\n   *   to {mac}).\n   * + **valid**: `true` if {mac} is valid for {data}.\n   *\n   * @param {String} alg The verification algorithm\n   * @param {String|Buffer} data The data to verify\n   * @param {String|Buffer} mac The signature or MAC to verify\n   * @param {Object} [props] Additional properties for the verification\n   *        algorithm.\n   * @returns {Promise} The promise for the verification operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n\n  Object.defineProperty(this, \"verify\", {\n    value: function (alg, data, mac, props) {\n      // validate appropriateness\n      if (this.algorithms(\"verify\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n\n      var k = cfg.verifyKey.call(this, alg, keys);\n\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      } // prepare properties (if any)\n\n\n      props = props ? clone(props) : {};\n\n      if (cfg.verifyProps) {\n        props = merge(props, cfg.verifyProps.call(this, alg, props));\n      }\n\n      return ALGORITHMS.verify(alg, k, data, mac, props);\n    }\n  });\n  /**\n   * @method JWK.Key#encrypt\n   * @description\n   * Encrypts the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive encryption operation; the output is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#wrap}, as different algorithms and properties are often\n   * used for wrapping a key versues encrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns an object with the following\n   * properties:\n   *\n   * + **data**: The ciphertext data\n   * + **mac**: The associated message authentication code (MAC).\n   *\n   * @param {String} alg The encryption algorithm\n   * @param {Buffer|String} data The data to encrypt\n   * @param {Object} [props] Additional properties for the encryption\n   *        algorithm.\n   * @returns {Promise} The promise for the encryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n\n  Object.defineProperty(this, \"encrypt\", {\n    value: function (alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"encrypt\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n\n      var k = cfg.encryptKey.call(this, alg, keys);\n\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      } // prepare properties (if any)\n\n\n      props = props ? clone(props) : {};\n\n      if (cfg.encryptProps) {\n        props = merge(props, cfg.encryptProps.call(this, alg, props));\n      }\n\n      return ALGORITHMS.encrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#decrypt\n   * @description\n   * Decrypts the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive decryption operation; the input is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#unwrap}, as different algorithms and properties are often used\n   * for unwrapping a key versues decrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns the plaintext data.\n   *\n   * @param {String} alg The decryption algorithm.\n   * @param {Buffer|String} data The data to decypt.\n   * @param {Object} [props] Additional data for the decryption operation.\n   * @returns {Promise} The promise for the decryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n\n  Object.defineProperty(this, \"decrypt\", {\n    value: function (alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"decrypt\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n\n      var k = cfg.decryptKey.call(this, alg, keys);\n\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      } // prepare properties (if any)\n\n\n      props = props ? clone(props) : {};\n\n      if (cfg.decryptProps) {\n        props = merge(props, cfg.decryptProps.call(this, alg, props));\n      }\n\n      return ALGORITHMS.decrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#wrap\n   * @description\n   * Wraps the given key using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive encryption operation; the output is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#encrypt}, as different algorithms and properties are\n   * often used for wrapping a key versues encrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns an object with the following\n   * properties:\n   *\n   * + **data**: The ciphertext data\n   * + **headers**: The additional header parameters to apply to a JWE.\n   *\n   * @param {String} alg The encryption algorithm\n   * @param {Buffer|String} data The data to encrypt\n   * @param {Object} [props] Additional properties for the encryption\n   *        algorithm.\n   * @returns {Promise} The promise for the encryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n\n  Object.defineProperty(this, \"wrap\", {\n    value: function (alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"wrap\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n\n      var k = cfg.wrapKey.call(this, alg, keys);\n\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      } // prepare properties (if any)\n\n\n      props = props ? clone(props) : {};\n\n      if (cfg.wrapProps) {\n        props = merge(props, cfg.wrapProps.call(this, alg, props));\n      }\n\n      return ALGORITHMS.encrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#unwrap\n   * @description\n   * Unwraps the given key using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive unwrap operation; the input is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#decrypt}, as different algorithms and properties are often used\n   * for unwrapping a key versues decrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns the unwrapped key.\n   *\n   * @param {String} alg The unwrap algorithm.\n   * @param {Buffer|String} data The data to unwrap.\n   * @param {Object} [props] Additional data for the unwrap operation.\n   * @returns {Promise} The promise for the unwrap operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n\n  Object.defineProperty(this, \"unwrap\", {\n    value: function (alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"unwrap\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n\n      var k = cfg.unwrapKey.call(this, alg, keys);\n\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      } // prepare properties (if any)\n\n\n      props = props ? clone(props) : {};\n\n      if (cfg.unwrapProps) {\n        props = merge(props, cfg.unwrapProps.call(this, alg, props));\n      }\n\n      return ALGORITHMS.decrypt(alg, k, data, props);\n    }\n  });\n};\n\nmodule.exports = JWKBaseKeyObject;","map":null,"metadata":{},"sourceType":"script"}