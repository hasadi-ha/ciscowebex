{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _defineProperty2 = require('babel-runtime/helpers/defineProperty');\n\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _set = require('babel-runtime/core-js/set');\n\nvar _set2 = _interopRequireDefault(_set);\n\nvar _map = require('babel-runtime/core-js/map');\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _wrap2 = require('lodash/wrap');\n\nvar _wrap3 = _interopRequireDefault(_wrap2);\n\nvar _result2 = require('lodash/result');\n\nvar _result3 = _interopRequireDefault(_result2);\n\nvar _identity2 = require('lodash/identity');\n\nvar _identity3 = _interopRequireDefault(_identity2);\n\nvar _debounce2 = require('lodash/debounce');\n\nvar _debounce3 = _interopRequireDefault(_debounce2);\n\nvar _curry2 = require('lodash/curry');\n\nvar _curry3 = _interopRequireDefault(_curry2);\n\nexports.persist = persist;\nexports.waitForValue = waitForValue;\n\nvar _errors = require('./errors');\n\nvar _common = require('@webex/common');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Stores the result of fn before returning it\n * @param  {string} key\n * @private\n * @returns {Promise} resolves with the result of fn\n */\n\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint no-invalid-this: [0] */\n\n\nfunction persist() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (args.length === 3) {\n    return persist('@').apply(undefined, args);\n  }\n\n  var key = args[0],\n      decider = args[1];\n  return function persistDecorator(target, prop, descriptor) {\n    if (prop !== 'initialize') {\n      // Once we have class-based alternative to AmpersandState, it should be\n      // detected here.\n      throw new TypeError('@persist can only currently be applied to AmpersandState objects or their derivatives and must be applied to the initialize method');\n    }\n\n    descriptor.value = (0, _wrap3.default)(descriptor.value, function persistExecutor(fn) {\n      var _this = this;\n\n      for (var _len2 = arguments.length, initializeArgs = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        initializeArgs[_key2 - 1] = arguments[_key2];\n      }\n\n      var ret = (0, _apply2.default)(fn, this, initializeArgs);\n      var changeEvent = key === '@' ? 'change' : 'change:' + key; // Some scenarios will lead to lots of change events on a single tick; we\n      // really only care about writing once things have stopped changing. with\n      // a debounce of zero, we're effectively coalescing all the changes\n      // triggered by a single call to set() and commiting them on the next tick\n      // eslint-disable-next-line no-invalid-this\n\n      this.on(changeEvent, (0, _debounce3.default)(function () {\n        var shouldPersist = !decider || _apply2.default.apply(Reflect, [decider, _this].concat(initializeArgs));\n\n        if (!shouldPersist) {\n          return _promise2.default.resolve();\n        }\n\n        if (key === '@') {\n          // eslint-disable-next-line no-invalid-this\n          return _this.boundedStorage.put(key, _this);\n        } // eslint-disable-next-line no-invalid-this\n\n\n        return _this.boundedStorage.put(key, _this[key]);\n      }, 0));\n      return ret;\n    });\n    prepareInitialize(target, prop);\n  };\n}\n\nvar M = _map2.default;\nvar S = _set2.default;\nvar BlockingKeyMap = (0, _common.make)(M, M, S);\nvar blockingKeys = new BlockingKeyMap();\n/**\n * Prevents fn from executing until key has been (attempted to be) loaded\n * @param {string} key\n * @param {Function} fn\n * @private\n * @returns {Promise} result of fn\n */\n\nfunction waitForValue(key) {\n  if (!key) {\n    throw new Error('`key` is required');\n  }\n\n  return function waitForValueDecorator(target, prop, descriptor) {\n    blockingKeys.add(target, prop, key);\n    descriptor.value = (0, _wrap3.default)(descriptor.value, function waitForValueExecutor(fn) {\n      var _this2 = this;\n\n      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      var keys = blockingKeys.get(target, prop);\n      return _promise2.default.all([].concat((0, _toConsumableArray3.default)(keys)).map(function (k) {\n        return _this2.boundedStorage.waitFor(k);\n      })).then(function () {\n        return (0, _apply2.default)(fn, _this2, args);\n      });\n    }); // This *should* make decorators compatible with AmpersandState class\n    // definitions\n\n    if ((typeof target === 'undefined' ? 'undefined' : (0, _typeof3.default)(target)) === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    prepareInitialize(target, prop);\n    return descriptor;\n  };\n}\n\nvar inited = new _set2.default();\n/**\n * finds a means of identitying the `target` param passed to\n * `prepareInitialize()`. When possible, avoids duplicate `init()` calls if\n * namespaces collide\n *\n * @param {Object|Constructor} target\n * @private\n * @returns {String|Constructor}\n */\n\nfunction identifyTarget(target) {\n  if (target.namespace) {\n    return target.namespace;\n  }\n\n  return target;\n}\n\nvar stack = new _set2.default();\n/**\n * @param {Function} target\n * @param {string} prop\n * @private\n * @returns {undefined}\n */\n\nfunction prepareInitialize(target, prop) {\n  var id = identifyTarget(target);\n\n  if (!inited.has(id)) {\n    inited.add(id);\n\n    if (target.initialize) {\n      target.initialize = (0, _wrap3.default)(target.initialize, function applyInit(fn) {\n        for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n          args[_key4 - 1] = arguments[_key4];\n        }\n\n        var ret = (0, _apply2.default)(fn, this, args);\n        (0, _apply2.default)(init, this, args);\n        return ret;\n      });\n      return;\n    }\n\n    target.initialize = init;\n  }\n  /**\n   * @private\n   * @returns {undefined}\n   */\n\n\n  function init() {\n    var self = this;\n    var namespace = this.getNamespace();\n    this.spark.initialize = (0, _wrap3.default)(this.spark.initialize || _identity3.default, function applyInit(fn) {\n      var _this3 = this; // Call spark's initalize method first\n      // Reminder: in order for MockSpark to accept initial storage data, the\n      // wrapped initialize() must be invoked before attempting to load data.\n      // Reminder: context here is `spark`, not `self`.\n\n\n      stack.add(namespace);\n\n      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        args[_key5 - 1] = arguments[_key5];\n      }\n\n      (0, _apply2.default)(fn, this, args); // Then prepare a function for setting values retrieved from storage\n\n      var set = (0, _curry3.default)(function (key, value) {\n        _this3.logger.debug('storage:(' + namespace + '): got `' + key + '` for first time');\n\n        if (key === '@') {\n          self.parent.set((0, _defineProperty3.default)({}, namespace.toLowerCase(), value));\n        } else if ((0, _result3.default)(self[key], 'isState')) {\n          self[key].set(value);\n        } else {\n          self.set(key, value);\n        }\n\n        _this3.logger.debug('storage:(' + namespace + '): set `' + key + '` for first time');\n      }); // And prepare an error handler for when those keys can't be found\n\n      var handle = (0, _curry3.default)(function (key, reason) {\n        if (reason instanceof _errors.NotFoundError || process.env.NODE_ENV !== 'production' && reason.toString().includes('MockNotFoundError')) {\n          _this3.logger.debug('storage(' + namespace + '): no data for `' + key + '`, continuing');\n\n          return _promise2.default.resolve();\n        }\n\n        _this3.logger.error('storage(' + namespace + '): failed to init `' + key + '`', reason);\n\n        return _promise2.default.reject(reason);\n      }); // Iterate over the list of keys marked as blocking via `@waitForValue`\n\n      var keys = blockingKeys.get(target, prop);\n      var promises = [];\n      keys.forEach(function (key) {\n        promises.push(_this3.boundedStorage.get(namespace, key).then(set(key)).catch(handle(key)));\n      });\n\n      _promise2.default.all(promises).then(function () {\n        stack.delete(namespace);\n\n        if (stack.size === 0) {\n          _this3.loaded = true;\n        }\n      });\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"script"}