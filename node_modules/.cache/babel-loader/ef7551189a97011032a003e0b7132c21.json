{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _weakMap = require('babel-runtime/core-js/weak-map');\n\nvar _weakMap2 = _interopRequireDefault(_weakMap);\n\nvar _stream = require('stream');\n\nvar _events = require('events');\n\nvar _commonTimers = require('@webex/common-timers');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar emittersByPc = new _weakMap2.default();\n/* eslint-disable require-jsdoc */\n\nvar pcsByEmitter = new _weakMap2.default();\nvar emittersByStream = new _weakMap2.default();\nvar timersByEmitter = new _weakMap2.default();\n/**\n * Helper function that ensures no matter how many stats streams we create, we\n * don't poll the PeerConnection more than once per interval.\n * @param {EventEmitter} emitter\n * @private\n * @returns {undefined}\n */\n\nfunction schedule(emitter) {\n  var timer = (0, _commonTimers.safeSetTimeout)(function () {\n    var pc = pcsByEmitter.get(emitter);\n    pc.getStats().then(function (stats) {\n      emitter.emit('data', stats); // \"closed\" is supposed to be part of the {@link RTCPeerConnectionState}\n      // enum according to spec, but at time of writing, was still implemented\n      // in the {@link RTCSignalingState} enum.\n\n      if (!(pc.signalingState === 'closed' || pc.connectionState === 'closed')) {\n        schedule(emitter);\n      }\n    }).catch(function (err) {\n      emitter.emit('error', err);\n    });\n  }, 1000);\n  timersByEmitter.set(emitter, timer);\n}\n/**\n * Polls an {@link RTCPeerConnection} once per second and emits its\n * {@link RTCStatsReport}\n */\n\n\nvar StatsStream = function (_Readable) {\n  (0, _inherits3.default)(StatsStream, _Readable);\n  /**\n   * @private\n   * @param {RTCPeerConnection} pc\n   */\n\n  function StatsStream(pc) {\n    (0, _classCallCheck3.default)(this, StatsStream);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (StatsStream.__proto__ || (0, _getPrototypeOf2.default)(StatsStream)).call(this, {\n      objectMode: true\n    }));\n\n    if (!emittersByPc.has(pc)) {\n      emittersByPc.set(pc, new _events.EventEmitter());\n    }\n\n    var emitter = emittersByPc.get(pc);\n\n    if (!emittersByStream.has(_this)) {\n      emittersByStream.set(_this, emitter);\n    }\n\n    if (!pcsByEmitter.has(emitter)) {\n      pcsByEmitter.set(emitter, pc);\n    }\n\n    emitter.once('error', function (err) {\n      _this.emit('error', err);\n    });\n    return _this;\n  }\n  /**\n   * See NodeJS Docs\n   * @private\n   * @returns {undefined}\n   */\n\n\n  (0, _createClass3.default)(StatsStream, [{\n    key: '_read',\n    value: function _read() {\n      var _this2 = this;\n\n      var emitter = emittersByStream.get(this);\n      emitter.once('data', function (data) {\n        if (!_this2.isPaused()) {\n          _this2.push(data);\n        }\n      });\n\n      if (!timersByEmitter.has(emitter)) {\n        schedule(emitter);\n      }\n    }\n  }]);\n  return StatsStream;\n}(_stream.Readable);\n\nexports.default = StatsStream;","map":null,"metadata":{},"sourceType":"script"}