{"ast":null,"code":"/*!\n * algorithms/hmac.js - HMAC-based \"signatures\"\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar CONSTANTS = require(\"./constants\"),\n    forge = require(\"../deps/forge.js\"),\n    DataBuffer = require(\"../util/databuffer.js\"),\n    helpers = require(\"./helpers.js\");\n\nfunction hmacSignFN(name) {\n  var md = name.replace(\"HS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"HS\", \"SHA-\");\n\n  function checkKeyLength(len, key) {\n    len = (len || CONSTANTS.HASHLENGTH[hash]) / 8;\n\n    if (len > key.length) {\n      return Promise.reject(new Error(\"invalid key length\"));\n    }\n\n    return Promise.resolve(key);\n  } // ### Fallback Implementation -- uses forge\n\n\n  var fallback = function (key, pdata, props) {\n    props = props || {};\n    var promise;\n    promise = checkKeyLength(props.length, key);\n    promise = promise.then(function () {\n      var sig = forge.hmac.create();\n      sig.start(md, key.toString(\"binary\"));\n      sig.update(pdata);\n      sig = sig.digest().native();\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n    return promise;\n  }; // ### WebCryptoAPI Implementation\n\n\n  var webcrypto = function (key, pdata, props) {\n    props = props || {};\n    var alg = {\n      name: \"HMAC\",\n      hash: {\n        name: hash\n      }\n    };\n    var promise;\n    promise = checkKeyLength(props.length, key);\n    promise = promise.then(function () {\n      return helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"sign\"]);\n    });\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function (result) {\n      var sig = new Buffer(result);\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n    return promise;\n  }; // ### NodeJS implementation\n\n\n  var nodejs = function (key, pdata, props) {\n    props = props || {};\n    var promise;\n    promise = checkKeyLength(props.length, key);\n    promise = promise.then(function () {\n      var hmac = helpers.nodeCrypto.createHmac(md, key);\n      hmac.update(pdata);\n      var sig = hmac.digest();\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction hmacVerifyFN(name) {\n  var md = name.replace(\"HS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"HS\", \"SHA-\");\n\n  function compare(len, expected, actual) {\n    len = (len || CONSTANTS.HASHLENGTH[hash]) / 8;\n    var valid = true;\n\n    for (var idx = 0; len > idx; idx++) {\n      valid = valid && expected[idx] === actual[idx];\n    }\n\n    return valid;\n  } // ### Fallback Implementation -- uses forge\n\n\n  var fallback = function (key, pdata, mac, props) {\n    props = props || {};\n    var vrfy = forge.hmac.create();\n    vrfy.start(md, new DataBuffer(key));\n    vrfy.update(pdata);\n    vrfy = vrfy.digest().native();\n\n    if (compare(props.length, mac, vrfy)) {\n      return Promise.resolve({\n        data: pdata,\n        mac: mac,\n        valid: true\n      });\n    } else {\n      return Promise.reject(new Error(\"verification failed\"));\n    }\n  };\n\n  var webcrypto = function (key, pdata, mac, props) {\n    props = props || {};\n    var alg = {\n      name: \"HMAC\",\n      hash: {\n        name: hash\n      }\n    };\n    var promise;\n\n    if (props.length) {\n      promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"sign\"]);\n      promise = promise.then(function (key) {\n        return helpers.subtleCrypto.sign(alg, key, pdata);\n      });\n      promise = promise.then(function (result) {\n        var sig = new Buffer(result);\n        return compare(props.length, mac, sig);\n      });\n    } else {\n      promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"verify\"]);\n      promise = promise.then(function (key) {\n        return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n      });\n    }\n\n    promise = promise.then(function (result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verifaction failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  var nodejs = function (key, pdata, mac, props) {\n    props = props || {};\n    var hmac = helpers.nodeCrypto.createHmac(md, key);\n    hmac.update(pdata);\n    var sig = hmac.digest();\n\n    if (!compare(props.length, mac, sig)) {\n      throw new Error(\"verification failed\");\n    }\n\n    return {\n      data: pdata,\n      mac: sig,\n      valid: true\n    };\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n} // ### Public API\n// * [name].sign\n// * [name].verify\n\n\nvar hmac = {};\n[\"HS1\", \"HS256\", \"HS384\", \"HS512\"].forEach(function (alg) {\n  hmac[alg] = {\n    sign: hmacSignFN(alg),\n    verify: hmacVerifyFN(alg)\n  };\n});\nmodule.exports = hmac;","map":null,"metadata":{},"sourceType":"script"}