{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FILE_SYMBOL = exports.EMITTER_SYMBOL = undefined;\n\nvar _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');\n\nvar _deleteProperty2 = _interopRequireDefault(_deleteProperty);\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _defineProperty2 = require('babel-runtime/helpers/defineProperty');\n\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _map2 = require('babel-runtime/core-js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _symbol = require('babel-runtime/core-js/symbol');\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _some2 = require('lodash/some');\n\nvar _some3 = _interopRequireDefault(_some2);\n\nvar _pick2 = require('lodash/pick');\n\nvar _pick3 = _interopRequireDefault(_pick2);\n\nvar _map4 = require('lodash/map');\n\nvar _map5 = _interopRequireDefault(_map4);\n\nvar _filter2 = require('lodash/filter');\n\nvar _filter3 = _interopRequireDefault(_filter2);\n\nvar _events = require('events');\n\nvar _common = require('@webex/common');\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _helperImage = require('@webex/helper-image');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar EMITTER_SYMBOL = exports.EMITTER_SYMBOL = (0, _symbol2.default)('EMITTER_SYMBOL');\nvar FILE_SYMBOL = exports.FILE_SYMBOL = (0, _symbol2.default)('FILE_SYMBOL');\nvar PROMISE_SYMBOL = (0, _symbol2.default)('PROMISE_SYMBOL');\n/**\n * @class\n */\n\nvar ShareActivity = _webexCore.SparkPlugin.extend({\n  getSymbols: function getSymbols() {\n    return {\n      file: FILE_SYMBOL,\n      emitter: EMITTER_SYMBOL\n    };\n  },\n  namespace: 'Conversation',\n  derived: {\n    target: {\n      deps: ['conversation'],\n      fn: function fn() {\n        return this.conversation;\n      }\n    }\n  },\n  session: {\n    conversation: {\n      required: true,\n      type: 'object'\n    },\n    content: 'string',\n    clientTempId: 'string',\n    displayName: 'string',\n    enableThumbnails: {\n      default: true,\n      type: 'boolean'\n    },\n    hiddenSpaceUrl: 'object',\n    mentions: 'object',\n    spaceUrl: 'object',\n    uploads: {\n      type: 'object',\n      default: function _default() {\n        return new _map3.default();\n      }\n    }\n  },\n  initialize: function initialize(attrs, options) {\n    (0, _apply2.default)(_webexCore.SparkPlugin.prototype.initialize, this, [attrs, options]);\n\n    if (attrs && attrs.conversation) {\n      this.spaceUrl = _promise2.default.resolve(attrs.conversation._spaceUrl || this._retrieveSpaceUrl(attrs.conversation.url + '/space').then(function (url) {\n        attrs.conversation._spaceUrl = url;\n        return url;\n      }));\n      this.hiddenSpaceUrl = _promise2.default.resolve(attrs.conversation._hiddenSpaceUrl || this._retrieveSpaceUrl(attrs.conversation.url + '/space/hidden').then(function (url) {\n        attrs.conversation._hiddenSpaceUrl = url;\n        return url;\n      }));\n    }\n  },\n\n  /**\n   * Adds an additional file to the share and begins submitting it to spark\n   * files\n   * @param {File} file\n   * @param {Object} options\n   * @param {Object} options.actions\n   * @returns {EventEmittingPromise}\n   */\n  add: function add(file, options) {\n    var _Object$assign2,\n        _this = this;\n\n    options = options || {};\n    var upload = this.uploads.get(file);\n\n    if (upload) {\n      return upload[PROMISE_SYMBOL];\n    }\n\n    var emitter = new _events.EventEmitter();\n    upload = (0, _assign2.default)((_Object$assign2 = {\n      displayName: file.name,\n      fileSize: file.size || file.byteLength || file.length,\n      mimeType: file.type,\n      objectType: 'file'\n    }, (0, _defineProperty3.default)(_Object$assign2, EMITTER_SYMBOL, emitter), (0, _defineProperty3.default)(_Object$assign2, FILE_SYMBOL, file), _Object$assign2), (0, _pick3.default)(options, 'actions'));\n    this.uploads.set(file, upload);\n    var promise = (0, _helperImage.detectFileType)(file, this.logger).then(function (type) {\n      upload.mimeType = type;\n      return (0, _helperImage.processImage)({\n        file: file,\n        type: type,\n        thumbnailMaxWidth: _this.config.thumbnailMaxWidth,\n        thumbnailMaxHeight: _this.config.thumbnailMaxHeight,\n        enableThumbnails: _this.enableThumbnails,\n        logger: _this.logger\n      });\n    }).then(function (imageData) {\n      var main = _this.spark.internal.encryption.encryptBinary(file).then(function (_ref) {\n        var scr = _ref.scr,\n            cdata = _ref.cdata;\n        upload.scr = scr;\n        return _promise2.default.all([cdata, _this.spaceUrl]);\n      }).then(function (_ref2) {\n        var _ref3 = (0, _slicedToArray3.default)(_ref2, 2),\n            cdata = _ref3[0],\n            spaceUrl = _ref3[1];\n\n        var uploadPromise = _this._upload(cdata, spaceUrl + '/upload_sessions');\n\n        (0, _common.transferEvents)('progress', uploadPromise, emitter);\n        return uploadPromise;\n      }).then(function (metadata) {\n        upload.url = upload.scr.loc = metadata.downloadUrl;\n      });\n\n      var thumb = void 0;\n\n      if (imageData) {\n        var _imageData = (0, _slicedToArray3.default)(imageData, 3),\n            thumbnail = _imageData[0],\n            fileDimensions = _imageData[1],\n            thumbnailDimensions = _imageData[2];\n\n        (0, _assign2.default)(upload, fileDimensions);\n\n        if (thumbnail && thumbnailDimensions) {\n          upload.image = thumbnailDimensions;\n          thumb = _this.spark.internal.encryption.encryptBinary(thumbnail).then(function (_ref4) {\n            var scr = _ref4.scr,\n                cdata = _ref4.cdata;\n            upload.image.scr = scr;\n            return _promise2.default.all([cdata, _this.hiddenSpaceUrl]);\n          }).then(function (_ref5) {\n            var _ref6 = (0, _slicedToArray3.default)(_ref5, 2),\n                cdata = _ref6[0],\n                spaceUrl = _ref6[1];\n\n            return _this._upload(cdata, spaceUrl + '/upload_sessions');\n          }).then(function (metadata) {\n            upload.image.url = upload.image.scr.loc = metadata.downloadUrl;\n          });\n        }\n      }\n\n      return _promise2.default.all([main, thumb]);\n    });\n    upload[PROMISE_SYMBOL] = promise;\n    (0, _common.proxyEvents)(emitter, promise);\n    return promise;\n  },\n\n  /**\n   * Fetches the files from the share\n   * @returns {Array}\n   */\n  getFiles: function getFiles() {\n    var files = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = (0, _getIterator3.default)(this.uploads), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref7 = _step.value;\n\n        var _ref8 = (0, _slicedToArray3.default)(_ref7, 1);\n\n        var key = _ref8[0];\n        files.push(this.uploads.get(key)[FILE_SYMBOL]);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return files;\n  },\n\n  /**\n   * @param {File} file\n   * @param {string} uri\n   * @private\n   * @returns {Promise}\n   */\n  _upload: function _upload(file, uri) {\n    var fileSize = file.length || file.size || file.byteLength;\n    return this.spark.upload({\n      uri: uri,\n      file: file,\n      qs: {\n        transcode: true\n      },\n      phases: {\n        initialize: {\n          fileSize: fileSize\n        },\n        upload: {\n          $url: function $url(session) {\n            return session.uploadUrl;\n          }\n        },\n        finalize: {\n          $uri: function $uri(session) {\n            return session.finishUploadUrl;\n          },\n          body: {\n            fileSize: fileSize\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Removes the specified file from the share (Does not currently delete the\n   * uploaded file)\n   * @param {File} file\n   * @returns {Promise}\n   */\n  remove: function remove(file) {\n    this.uploads.delete(file); // Returns a promise for future-proofiness.\n\n    return _promise2.default.resolve();\n  },\n\n  /**\n   * @private\n   * @returns {Promise<Object>}\n   */\n  prepare: function prepare() {\n    if (!this.uploads.size) {\n      throw new Error('Cannot submit a share activity without atleast one file');\n    }\n\n    var activity = {\n      verb: 'share',\n      object: {\n        objectType: 'content',\n        displayName: this.object && this.object.displayName ? this.object.displayName : undefined,\n        content: this.object && this.object.content ? this.object.content : undefined,\n        mentions: this.object && this.object.mentions ? this.object.mentions : undefined,\n        files: {\n          items: []\n        }\n      },\n      clientTempId: this.clientTempId\n    };\n    var promises = [];\n    this.uploads.forEach(function (item) {\n      activity.object.files.items.push(item);\n      promises.push(item[PROMISE_SYMBOL]);\n    });\n    activity.object.contentCategory = this._determineContentCategory(activity.object.files.items);\n    return _promise2.default.all(promises).then(function () {\n      return activity;\n    });\n  },\n\n  /**\n   * @param {Array} items\n   * @param {string} mimeType\n   * @private\n   * @returns {boolean}\n   */\n  _itemContainsActionWithMimeType: function _itemContainsActionWithMimeType(items, mimeType) {\n    return (0, _some3.default)(items.map(function (item) {\n      return (0, _some3.default)(item.actions, {\n        mimeType: mimeType\n      });\n    }));\n  },\n\n  /**\n   * @param {Array} items\n   * @private\n   * @returns {string}\n   */\n  _determineContentCategory: function _determineContentCategory(items) {\n    // determine if the items contain an image\n    if (this._itemContainsActionWithMimeType(items, 'application/x-cisco-spark-whiteboard')) {\n      return 'documents';\n    }\n\n    var mimeTypes = (0, _filter3.default)((0, _map5.default)(items, 'mimeType'));\n\n    if (mimeTypes.length !== items.length) {\n      return 'documents';\n    }\n\n    var contentCategory = mimeTypes[0].split('/').shift();\n\n    if (contentCategory !== 'video' && contentCategory !== 'image') {\n      return 'documents';\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = (0, _getIterator3.default)(mimeTypes), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var mimeType = _step2.value;\n\n        if (mimeType.split('/').shift() !== contentCategory) {\n          return 'documents';\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return contentCategory + 's';\n  },\n\n  /**\n   * @param {string} uri\n   * @returns {Promise}\n   */\n  _retrieveSpaceUrl: function _retrieveSpaceUrl(uri) {\n    return this.spark.request({\n      method: 'PUT',\n      uri: uri\n    }).then(function (res) {\n      return res.body.spaceUrl;\n    });\n  },\n  version: '1.59.0'\n});\n/**\n * Instantiates a ShareActivity\n * @param {Object} conversation\n * @param {ShareActivity|Object|array} object\n * @param {ProxySpark} spark\n * @returns {ShareActivity}\n */\n\n\nShareActivity.create = function create(conversation, object, spark) {\n  if (object instanceof ShareActivity) {\n    return object;\n  }\n\n  var files = void 0;\n\n  if (object && object.object && object.object.files) {\n    files = object.object.files;\n    (0, _deleteProperty2.default)(object.object, 'files');\n  }\n\n  var share = new ShareActivity((0, _assign2.default)({\n    conversation: conversation\n  }, object), {\n    parent: spark\n  });\n  files = files && files.items || files;\n\n  if (files) {\n    files.forEach(function (file) {\n      return share.add(file);\n    });\n  }\n\n  return share;\n};\n\nexports.default = ShareActivity;","map":null,"metadata":{},"sourceType":"script"}