{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _values = require('babel-runtime/core-js/object/values');\n\nvar _values2 = _interopRequireDefault(_values);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _find2 = require('lodash/find');\n\nvar _find3 = _interopRequireDefault(_find2);\n\nvar _omit2 = require('lodash/omit');\n\nvar _omit3 = _interopRequireDefault(_omit2);\n\nvar _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar _common = require('@webex/common');\n\nvar _commonTimers = require('@webex/common-timers');\n\nvar _util = require('util');\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _featuresModel = require('./features-model');\n\nvar _featuresModel2 = _interopRequireDefault(_featuresModel);\n\nvar _serviceCollection = require('./service-collection');\n\nvar _serviceCollection2 = _interopRequireDefault(_serviceCollection);\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n/**\n * Decides if this device should be persisted to boundedStorage, based on\n * this.config.ephemeral.\n * @returns {Boolean}\n */\n\n\nfunction decider() {\n  return !this.config.ephemeral;\n}\n\nvar Device = _webexCore.WebexPlugin.extend((_dec = (0, _webexCore.waitForValue)('@'), _dec2 = (0, _webexCore.waitForValue)('@'), _dec3 = (0, _webexCore.persist)('@', decider), _dec4 = (0, _webexCore.waitForValue)('@'), _dec5 = (0, _webexCore.waitForValue)('@'), _dec6 = (0, _webexCore.waitForValue)('@'), _dec7 = (0, _webexCore.waitForValue)('@'), _dec8 = (0, _webexCore.waitForValue)('@'), _dec9 = (0, _webexCore.waitForValue)('@'), (_obj = {\n  children: {\n    features: _featuresModel2.default\n  },\n  collections: {\n    serviceCatalog: _serviceCollection2.default\n  },\n  idAttribute: 'url',\n  namespace: 'Device',\n  props: {\n    /**\n     * Notifies the client if giphys are enabled.\n     * Currently, the values for it are:\n     * - ALLOW\n     * - BLOCK\n     * @instance\n     * @memberof Device\n     * @type {string}\n     */\n    clientMessagingGiphy: 'string',\n    customerCompanyName: 'string',\n    customerLogoUrl: 'string',\n    // deviceType doesn't have any real value, but we need to send it during\n    // device refresh to make sure we don't get back an ios device url\n    deviceType: 'string',\n    helpUrl: 'string',\n    intranetInactivityDuration: 'number',\n    intranetInactivityCheckUrl: 'string',\n    inNetworkInactivityDuration: 'number',\n    // Newly added duration for internal network inactivity\n\n    /**\n     * Is ECM (external content management) enabled for the whole org\n     * @instance\n     * @memberof Device\n     * @type {boolean}\n     */\n    ecmEnabledForAllUsers: {\n      type: 'boolean',\n      default: function _default() {\n        return false;\n      }\n    },\n\n    /**\n     * What ECM providers are available\n     * @instance\n     * @memberof Device\n     * @type {string[]}\n     */\n    ecmSupportedStorageProviders: {\n      type: 'array',\n      default: function _default() {\n        return [];\n      }\n    },\n    modificationTime: 'string',\n    partnerCompanyName: 'string',\n    partnerLogoUrl: 'string',\n    peopleInsightsEnabled: 'boolean',\n    reportingSiteDesc: 'string',\n    reportingSiteUrl: 'string',\n    searchEncryptionKeyUrl: 'string',\n    // services is obsoleted and will be deprecated\n    services: {\n      // Even though @jodykstr will tell you the docs claim you don't need to\n      // initialize `object` properties, the docs lie.\n      default: function _default() {\n        return {};\n      },\n      type: 'object'\n    },\n    serviceHostMap: {\n      default: function _default() {\n        return {\n          serviceLinks: {},\n          hostCatalog: {}\n        };\n      },\n      type: 'object'\n    },\n    showSupportText: 'boolean',\n    supportProviderCompanyName: 'string',\n    supportProviderLogoUrl: 'string',\n    url: 'string',\n    userId: 'string',\n\n    /**\n     * Notifies the client if file sharing is disabled.\n     * Currently, the values for it are:\n     * - BLOCK_BOTH\n     * - BLOCK_UPLOAD\n     * @instance\n     * @memberof Device\n     * @type {string}\n     */\n    webFileShareControl: 'string',\n    webSocketUrl: 'string',\n\n    /**\n     * Notifies the client if whiteboarding should be allowed\n     * regardless of webFileShareControl settings.\n     * Currently, the values for it are:\n     * - ALLOW\n     * - BLOCK\n     * @instance\n     * @memberof Device\n     * @type {string}\n     */\n    whiteboardFileShareControl: 'string'\n  },\n  derived: {\n    registered: {\n      deps: ['url'],\n      fn: function fn() {\n        return Boolean(this.url);\n      }\n    }\n  },\n  session: {\n    // Fun Fact: setTimeout returns a Timer object instead of a Number in Node 6\n    // or later\n    logoutTimer: 'any',\n    lastUserActivityDate: 'number',\n    isReachabilityChecked: 'boolean',\n    // To prevent url reachabilty from being called more than once on successful check.\n    isInMeeting: 'boolean',\n    // Boolean for checking user is in meeting to prevent in advertent timeout due to inactivity\n    isInNetwork: 'boolean' // Boolean to ensure _resetLogoutTimer isn't called repeatedly once its known client is connected to org's internal network\n\n  },\n  determineService: function determineService(url) {\n    var feature = this.features.developer.get('web-high-availability');\n\n    if (feature && feature.value) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(this.serviceHostMap.serviceLinks)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n          var serviceUrl = this.serviceHostMap.serviceLinks[key];\n\n          if (url.startsWith(serviceUrl)) {\n            return _promise2.default.resolve(key);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } else {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(this.services)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _key = _step2.value;\n          var _serviceUrl = this.services[_key];\n\n          if (url.startsWith(_serviceUrl)) {\n            // \"ServiceUrl\" is 10 characters\n            return _promise2.default.resolve(_key.substr(0, _key.length - 10));\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    return _promise2.default.reject(new Error(url + ' does not reflect a known service'));\n  },\n  getServiceUrl: function getServiceUrl(service) {\n    var _this = this;\n\n    var feature = this.features.developer.get('web-high-availability');\n\n    if (feature && feature.value) {\n      return this._getServiceUrl(this.serviceHostMap.serviceLinks, service).then(function (isServiceUrl) {\n        return isServiceUrl || _this.getPreDiscoveryServiceUrl(service);\n      });\n    }\n\n    return this._getServiceUrl(this.services, service).then(function (isServiceUrl) {\n      return isServiceUrl || _this.getPreDiscoveryServiceUrl(service);\n    });\n  },\n  getPreDiscoveryServiceUrl: function getPreDiscoveryServiceUrl(service) {\n    // The Promise.resolve here is temporary. A future PR will make the\n    // corresponding _ method async to allow for lazy device registration\n    return _promise2.default.resolve(this._getServiceUrl(this.config.preDiscoveryServices, service));\n  },\n  getWebSocketUrl: function getWebSocketUrl() {\n    return this.useServiceCatalogUrl(this.webSocketUrl);\n  },\n  useServiceCatalogUrl: function useServiceCatalogUrl(uri) {\n    return this.serviceCatalog.inferServiceFromUrl(uri).then(function (s) {\n      return s.replaceUrlWithCurrentHost(uri);\n    });\n  },\n  markUrlFailedAndGetNew: function markUrlFailedAndGetNew(url) {\n    var _this2 = this;\n\n    if (!url) {\n      return _promise2.default.reject(new Error('`url` is a required parameter'));\n    }\n\n    this.logger.info('device: marking ' + url + ' as failed');\n    return this.serviceCatalog.markFailedAndCycleUrl(url).then(function (uri) {\n      _this2.webex.internal.metrics.submitClientMetrics('web-ha', {\n        tags: {\n          action: 'replace_url',\n          failedUrl: url,\n          newUrl: uri\n        }\n      });\n\n      return uri;\n    }) // it's likely we fail here because we've cycled though all hosts,\n    // reset all hosts and then retry connecting\n    .catch(function () {\n      return _this2._resetAllAndRetry(url);\n    });\n  },\n  _resetAllAndRetry: function _resetAllAndRetry(url) {\n    if (!url) {\n      return _promise2.default.reject(new Error('`url` is a required parameter'));\n    }\n\n    this.logger.info('device: reset available hosts and retry ' + url);\n    return this.serviceCatalog.resetAllAndRetry(url);\n  },\n  // this function is exposed beyond the device file\n  fetchNewUrls: function fetchNewUrls(url) {\n    var _this3 = this; // we want to get the current service first, just in case the\n    // refreshed catalog has different host names\n\n\n    return new _promise2.default(function (resolve) {\n      return _this3.serviceCatalog.inferServiceFromUrl(url).then(function (s) {\n        _this3.logger.info('device: refresh to ' + s.service + ' get new urls');\n\n        _this3.refresh();\n\n        _this3.on('serviceCatalogUpdated', function () {\n          return resolve(s.url);\n        });\n      });\n    });\n  },\n  initialize: function initialize() {\n    var _this4 = this;\n\n    for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    (0, _apply2.default)(_webexCore.WebexPlugin.prototype.initialize, this, args); // Propagate change(:[attribute]) events from collections\n\n    ['developer', 'entitlement', 'user'].forEach(function (collectionName) {\n      _this4.features.on('change:' + collectionName, function (model, value, options) {\n        _this4.trigger('change', _this4, options);\n\n        _this4.trigger('change:features', _this4, _this4.features, options);\n      });\n    }); // Initialize it to false.\n\n    this.isReachabilityChecked = false;\n    this.on('change:serviceHostMap', this._updateServiceCatalog);\n    this.listenToAndRun(this, 'change:intranetInactivityCheckUrl', function () {\n      _this4.testNetworkReachability();\n    });\n    this.listenToAndRun(this, 'change:intranetInactivityDuration', function () {\n      _this4.testNetworkReachability();\n    });\n    this.listenToAndRun(this, 'change:inNetworkInactivityDuration', function () {\n      _this4.testNetworkReachability();\n    });\n    this.listenTo(this.webex, 'user-activity', function () {\n      _this4.lastUserActivityDate = Date.now();\n    });\n    /**\n    * Meeting started and ended event listenrs\n    * When client enters into the meeting set isInMeeting to true\n    * This tells also triggers both the timers inturn un-setting the timers until meeting ends\n    * On meeting end/clean-up the timers are reset.\n    */\n\n    this.listenTo(this.webex, 'meeting started', function () {\n      _this4.isInMeeting = true;\n\n      _this4._resetLogoutTimer();\n    });\n    this.listenTo(this.webex, 'meeting ended', function () {\n      _this4.isInMeeting = false;\n\n      _this4._resetLogoutTimer();\n    });\n  },\n\n  /**\n  * Don't log the features object\n  * @param {number} depth\n  * @returns {Object}\n  */\n  inspect: function inspect(depth) {\n    return _util2.default.inspect((0, _omit3.default)(this.serialize(), 'features'), {\n      depth: depth\n    });\n  },\n  isPreDiscoveryService: function isPreDiscoveryService(service) {\n    // The Promise.resolve here is temporary. A future PR will make the\n    // corresponding _ method async to allow for lazy device registration\n    return _promise2.default.resolve(this._isService(this.config.preDiscoveryServices, service));\n  },\n\n  /**\n  * Meeting started and Meeting Ended\n  * These are device.internal functions that can be accessible from web-client\n  * These are used to trigger the events for meeting start/end from within web client.\n  * @returns {boolean}\n  */\n  meetingStarted: function meetingStarted() {\n    this.webex.trigger('meeting started');\n  },\n\n  /**\n  * Meeting started and Meeting Ended\n  * These are device.internal functions that can be accessible from web-client\n  * These are used to trigger the events for meeting start/end from within web client.\n  * @returns {boolean}\n  */\n  meetingEnded: function meetingEnded() {\n    this.webex.trigger('meeting ended');\n  },\n  testNetworkReachability: function testNetworkReachability() {\n    var _this5 = this;\n\n    if (this.isReachabilityChecked) {\n      return this._resetLogoutTimer();\n    }\n\n    if (!this.intranetInactivityCheckUrl) {\n      this.isInNetwork = false;\n      return this._resetLogoutTimer();\n    }\n\n    this.isReachabilityChecked = true;\n    this.webex.request({\n      headers: {\n        'cisco-no-http-redirect': null,\n        'spark-user-agent': null,\n        trackingid: null\n      },\n      method: 'GET',\n      uri: this.intranetInactivityCheckUrl\n    }).then(function () {\n      _this5.isInNetwork = true;\n      return _this5._resetLogoutTimer();\n    }).catch(function () {\n      _this5.logger.info('device: did not reach internal ping endpoint; Setting off-network timer');\n\n      _this5.isInNetwork = false;\n      return _this5._resetLogoutTimer();\n    }); // Added due to eslint error.\n\n    return true;\n  },\n  isPreDiscoveryServiceUrl: function isPreDiscoveryServiceUrl(uri) {\n    if (!uri) {\n      return _promise2.default.reject(new Error('`uri` is a required parameter'));\n    } // The Promise.resolve here is temporary. A future PR will make the\n    // corresponding _ method async to allow for lazy device registration\n\n\n    return _promise2.default.resolve(this._isServiceUrl(this.config.preDiscoveryServices, uri));\n  },\n  isService: function isService(service) {\n    var _this6 = this;\n\n    if (service === 'idbroker') {\n      return _promise2.default.resolve(false);\n    }\n\n    var feature = this.features.developer.get('web-high-availability');\n\n    if (feature && feature.value) {\n      return this._isService(this.serviceHostMap.serviceLinks, service).then(function (_isService) {\n        return _isService || _this6.isPreDiscoveryService(service);\n      });\n    }\n\n    return this._isService(this.services, service).then(function (_isService) {\n      return _isService || _this6.isPreDiscoveryService(service);\n    });\n  },\n  isServiceUrl: function isServiceUrl(uri) {\n    // The Promise.resolve here is temporary. A future PR will make the\n    // corresponding _ method async to allow for lazy device registration\n    if (!uri) {\n      return _promise2.default.reject(new Error('`uri` is a required parameter'));\n    }\n\n    var feature = this.features.developer.get('web-high-availability');\n\n    if (feature && feature.value) {\n      if (this._isServiceUrl(this.serviceHostMap.serviceLinks, uri) || this._isServiceUrlFromCatalog(this.serviceHostMap.hostCatalog, uri)) {\n        return _promise2.default.resolve(true);\n      }\n\n      return _promise2.default.resolve(false);\n    }\n\n    return _promise2.default.resolve(this._isServiceUrl(this.services, uri));\n  },\n  isSpecificService: function isSpecificService(service, key) {\n    if (key === service) {\n      return _promise2.default.resolve(true);\n    }\n\n    return this.getServiceUrl(service).then(function (serviceUrl) {\n      return key.includes(serviceUrl);\n    });\n  },\n  _getServiceUrl: function _getServiceUrl(target, service) {\n    /* istanbul ignore if */\n    if (!service) {\n      return _promise2.default.reject(new Error('`service` is a required parameter'));\n    }\n\n    var feature = this.features.developer.get('web-high-availability');\n\n    if (feature && feature.value) {\n      var s = this.serviceCatalog.get(service);\n\n      if (s) {\n        return _promise2.default.resolve(s.url);\n      }\n    }\n\n    if (!target) {\n      return _promise2.default.reject(new Error('`target` is a required parameter'));\n    }\n\n    return _promise2.default.resolve(target[service + 'ServiceUrl']);\n  },\n  _isService: function _isService(target, service) {\n    return this._getServiceUrl(target, service).then(function (url) {\n      return Boolean(url);\n    });\n  },\n  _isServiceUrl: function _isServiceUrl(target, uri) {\n    var feature = this.features.developer.get('web-high-availability');\n\n    if (feature && feature.value) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = (0, _getIterator3.default)((0, _keys2.default)(target)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var key = _step3.value;\n          var serviceUrl = target[key];\n\n          if (key !== 'idbroker' && uri.startsWith(serviceUrl)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    } else {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = (0, _getIterator3.default)((0, _values2.default)(target)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var value = _step4.value;\n\n          if (value && uri.startsWith(value)) {\n            return _promise2.default.resolve(true);\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n\n    return false;\n  },\n  _isServiceUrlFromCatalog: function _isServiceUrlFromCatalog(hostCatalog, uri) {\n    var hostName = _url2.default.parse(uri).hostname;\n\n    if (hostName && !hostName.includes('idbroker') && (0, _find3.default)(hostCatalog, function (service) {\n      return (0, _find3.default)(service, function (availableHost) {\n        return availableHost.host === hostName;\n      });\n    })) {\n      return true;\n    }\n\n    return false;\n  },\n  refresh: function refresh() {\n    var _this7 = this;\n\n    this.logger.info('device: refreshing');\n\n    if (!this.registered) {\n      this.logger.info('device: device not registered, registering');\n      return this.register();\n    }\n\n    var body = (0, _omit3.default)(this.serialize(), 'features', 'mediaClusters');\n\n    if (this.config.ephemeral) {\n      body.ttl = this.config.ephemeralDeviceTTL;\n    }\n\n    return this.request({\n      method: 'PUT',\n      uri: this.url,\n      body: body\n    }).then(function (res) {\n      return _this7._processRegistrationSuccess(res);\n    }).catch(function (reason) {\n      if (reason.statusCode === 404) {\n        // If we get a 404, it means the device is no longer valid and we need\n        // to register a new one.\n        _this7.logger.info('device: refresh failed with 404, attempting to register new device');\n\n        _this7.clear();\n\n        return _this7.register();\n      }\n\n      return _promise2.default.reject(reason);\n    });\n  },\n  register: function register() {\n    var _this8 = this;\n    /* eslint no-invalid-this: [0] */\n\n\n    this.logger.info('device: registering');\n\n    if (this.registered) {\n      this.logger.info('device: device already registered, refreshing');\n      return this.refresh();\n    }\n\n    var body = this.config.defaults;\n\n    if (this.config.ephemeral) {\n      body.ttl = this.config.ephemeralDeviceTTL;\n    }\n\n    return this.request({\n      method: 'POST',\n      service: 'wdm',\n      resource: 'devices',\n      body: body\n    }).then(function (res) {\n      return _this8._processRegistrationSuccess(res);\n    });\n  },\n  unregister: function unregister() {\n    var _this9 = this;\n\n    this.logger.info('device: unregistering');\n\n    if (!this.url) {\n      this.logger.warn('device: not registered');\n      return _promise2.default.resolve();\n    }\n\n    return this.request({\n      uri: this.url,\n      method: 'DELETE'\n    }).then(function () {\n      return _this9.clear();\n    });\n  },\n  clear: function clear() {\n    clearTimeout(this.refreshTimer);\n\n    for (var _len2 = arguments.length, args = Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    (0, _apply2.default)(_webexCore.WebexPlugin.prototype.clear, this, args);\n  },\n  _processRegistrationSuccess: function _processRegistrationSuccess(res) {\n    var _this10 = this;\n\n    this.logger.info('device: received registration payload');\n    this.set(res.body);\n\n    if (this.config.ephemeral) {\n      this.logger.info('device: enqueing device refresh');\n      var delay = (this.config.ephemeralDeviceTTL / 2 + 60) * 1000;\n      this.refreshTimer = (0, _commonTimers.safeSetTimeout)(function () {\n        return _this10.refresh();\n      }, delay);\n    }\n  },\n  _updateServiceCatalog: function _updateServiceCatalog(newRegistration) {\n    var _this11 = this;\n\n    var feature = this.features.developer.get('web-high-availability');\n\n    if (feature && feature.value) {\n      if (newRegistration.serviceHostMap && newRegistration.serviceHostMap.serviceLinks && newRegistration.serviceHostMap.hostCatalog) {\n        (0, _keys2.default)(newRegistration.serviceHostMap.serviceLinks).forEach(function (key) {\n          var hostName = _url2.default.parse(newRegistration.serviceHostMap.serviceLinks[key]).hostname;\n\n          var hosts = newRegistration.serviceHostMap.hostCatalog[hostName];\n\n          _this11.serviceCatalog.set({\n            service: key,\n            defaultUrl: newRegistration.serviceHostMap.serviceLinks[key],\n            availableHosts: hosts || []\n          }, {\n            remove: false\n          });\n        });\n        this.trigger('serviceCatalogUpdated');\n      } else {\n        // if user has old device in localStorage, refresh device\n        this.refresh();\n      }\n    }\n  },\n  _resetLogoutTimer: function _resetLogoutTimer() {\n    // Clear any previously set timers and listeners\n    clearTimeout(this.logoutTimer);\n    this.off('change:lastUserActivityDate'); // removes previous event listener\n\n    this.unset('logoutTimer');\n\n    if (!this.isInMeeting && this.config.enableInactivityEnforcement && this.isReachabilityChecked) {\n      if (this.isInNetwork) {\n        this._setLogoutTimer(this.inNetworkInactivityDuration);\n      } else {\n        this._setLogoutTimer(this.intranetInactivityDuration);\n      }\n    }\n  },\n  _setLogoutTimer: function _setLogoutTimer(duration) {\n    var _this12 = this;\n\n    if (!duration || duration && duration === -1) {\n      return;\n    }\n\n    this.on('change:lastUserActivityDate', function () {\n      _this12._resetLogoutTimer();\n    });\n    var timer = (0, _commonTimers.safeSetTimeout)(function () {\n      _this12.webex.logout();\n    }, duration * 1000);\n    this.logoutTimer = timer;\n  },\n  version: '1.69.1'\n}, (_applyDecoratedDescriptor(_obj, 'determineService', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'determineService'), _obj), _applyDecoratedDescriptor(_obj, 'getServiceUrl', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'getServiceUrl'), _obj), _applyDecoratedDescriptor(_obj, 'initialize', [_dec3], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initialize'), _obj), _applyDecoratedDescriptor(_obj, 'isService', [_dec4], (0, _getOwnPropertyDescriptor2.default)(_obj, 'isService'), _obj), _applyDecoratedDescriptor(_obj, 'isServiceUrl', [_dec5], (0, _getOwnPropertyDescriptor2.default)(_obj, 'isServiceUrl'), _obj), _applyDecoratedDescriptor(_obj, 'isSpecificService', [_dec6], (0, _getOwnPropertyDescriptor2.default)(_obj, 'isSpecificService'), _obj), _applyDecoratedDescriptor(_obj, 'refresh', [_common.oneFlight, _dec7], (0, _getOwnPropertyDescriptor2.default)(_obj, 'refresh'), _obj), _applyDecoratedDescriptor(_obj, 'register', [_common.oneFlight, _dec8], (0, _getOwnPropertyDescriptor2.default)(_obj, 'register'), _obj), _applyDecoratedDescriptor(_obj, 'unregister', [_common.oneFlight, _dec9], (0, _getOwnPropertyDescriptor2.default)(_obj, 'unregister'), _obj)), _obj)));\n\nexports.default = Device;","map":null,"metadata":{},"sourceType":"script"}