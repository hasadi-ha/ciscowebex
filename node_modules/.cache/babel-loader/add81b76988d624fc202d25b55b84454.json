{"ast":null,"code":"/*!\n * algorithms/helpers.js - Internal functions and fields used in Cryptographic\n * Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nif (typeof Promise === \"undefined\") {\n  require(\"es6-promise\").polyfill();\n} // ###\n\n\nexports.int32ToBuffer = function (v, b) {\n  b = b || new Buffer(4);\n  b[0] = v >>> 24 & 0xff;\n  b[1] = v >>> 16 & 0xff;\n  b[2] = v >>> 8 & 0xff;\n  b[3] = v & 0xff;\n  return b;\n};\n\nvar MAX_INT32 = Math.pow(2, 32);\n\nexports.int64ToBuffer = function (v, b) {\n  b = b || new Buffer(8);\n  var hi = Math.floor(v / MAX_INT32),\n      lo = v % MAX_INT32;\n  hi = exports.int32ToBuffer(hi);\n  lo = exports.int32ToBuffer(lo);\n  b = Buffer.concat([hi, lo]);\n  return b;\n}; // ### crypto and DOMException in browsers ###\n\n/* global crypto:false, DOMException:false */\n\n\nfunction getCryptoSubtle() {\n  if (\"undefined\" !== typeof crypto) {\n    if (\"undefined\" !== typeof crypto.subtle) {\n      return crypto.subtle;\n    }\n  }\n\n  return undefined;\n}\n\nfunction getCryptoNodeJS() {\n  var crypto;\n\n  try {\n    crypto = require(\"crypto\");\n  } catch (err) {\n    return undefined;\n  }\n\n  if (!Object.keys(crypto).length) {\n    // treat empty the same as missing\n    return undefined;\n  }\n\n  return crypto;\n}\n\nvar supported = {};\nObject.defineProperty(exports, \"subtleCrypto\", {\n  get: function () {\n    var result;\n\n    if (\"subtleCrypto\" in supported) {\n      result = supported.subtleCrypto;\n    } else {\n      result = supported.subtleCrypto = getCryptoSubtle();\n    }\n\n    return result;\n  },\n  enumerable: true\n});\nObject.defineProperty(exports, \"nodeCrypto\", {\n  get: function () {\n    var result;\n\n    if (\"nodeCrypto\" in supported) {\n      result = supported.nodeCrypto;\n    } else {\n      result = supported.nodeCrypto = getCryptoNodeJS();\n    }\n\n    return result;\n  },\n  enumerable: true\n});\n\nexports.setupFallback = function (nodejs, webcrypto, fallback) {\n  var impl;\n\n  if (nodejs && exports.nodeCrypto) {\n    impl = function main() {\n      var args = arguments,\n          promise;\n\n      function check(err) {\n        if (0 === err.message.indexOf(\"unsupported algorithm:\")) {\n          impl = fallback;\n          return impl.apply(null, args);\n        }\n\n        return Promise.reject(err);\n      }\n\n      try {\n        promise = Promise.resolve(nodejs.apply(null, args));\n      } catch (err) {\n        promise = check(err);\n      }\n\n      return promise;\n    };\n  } else if (webcrypto && exports.subtleCrypto) {\n    impl = function main() {\n      var args = arguments,\n          promise;\n\n      function check(err) {\n        if (err.code === DOMException.NOT_SUPPORTED_ERR || // Firefox rejects some operations erroneously complaining about inputs\n        err.message === \"Only ArrayBuffer and ArrayBufferView objects can be passed as CryptoOperationData\" || // MS Edge rejects with not an Error\n        !(err instanceof Error)) {\n          // not actually supported -- always use fallback\n          impl = fallback;\n          return impl.apply(null, args);\n        }\n\n        return Promise.reject(err);\n      }\n\n      try {\n        promise = webcrypto.apply(null, args);\n        promise = promise.catch(check);\n      } catch (err) {\n        promise = check(err);\n      }\n\n      return promise;\n    };\n  } else {\n    impl = fallback;\n  }\n\n  return impl;\n};","map":null,"metadata":{},"sourceType":"script"}