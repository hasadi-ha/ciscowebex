{"ast":null,"code":"var uniqueId = require('lodash/uniqueId');\n\nvar eventSplitter = /\\s+/; // A difficult-to-believe, but optimized internal dispatch function for\n// triggering events. Tries to keep the usual cases speedy.\n\nexports.triggerEvents = function triggerEvents(events, args) {\n  var ev;\n  var i = -1;\n  var l = events.length;\n  var a1 = args[0];\n  var a2 = args[1];\n  var a3 = args[2];\n\n  switch (args.length) {\n    case 0:\n      while (++i < l) (ev = events[i]).callback.call(ev.ctx);\n\n      return;\n\n    case 1:\n      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);\n\n      return;\n\n    case 2:\n      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n      return;\n\n    case 3:\n      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n      return;\n\n    default:\n      while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\n\n      return;\n  }\n}; // Implement fancy features of the Events API such as multiple event\n// names `\"change blur\"` and jQuery-style event maps `{change: action}`\n// in terms of the existing API.\n\n\nexports.eventsApi = function eventsApi(obj, action, name, rest) {\n  if (!name) return true; // Handle event maps.\n\n  if (typeof name === 'object') {\n    for (var key in name) {\n      obj[action].apply(obj, [key, name[key]].concat(rest));\n    }\n\n    return false;\n  } // Handle space separated event names.\n\n\n  if (eventSplitter.test(name)) {\n    var names = name.split(eventSplitter);\n\n    for (var i = 0, l = names.length; i < l; i++) {\n      obj[action].apply(obj, [names[i]].concat(rest));\n    }\n\n    return false;\n  }\n\n  return true;\n}; // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n// listen to an event in another object ... keeping track of what it's\n// listening to.\n\n\nexports.createListenMethod = function createListenMethod(implementation) {\n  return function listenMethod(obj, name, callback) {\n    if (!obj) {\n      throw new Error('Trying to listenTo event: \\'' + name + '\\' but the target object is undefined');\n    }\n\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var id = obj._listenId || (obj._listenId = uniqueId('l'));\n    listeningTo[id] = obj;\n    if (!callback && typeof name === 'object') callback = this;\n\n    if (typeof obj[implementation] !== 'function') {\n      throw new Error('Trying to listenTo event: \\'' + name + '\\' on object: ' + obj.toString() + ' but it does not have an \\'on\\' method so is unbindable');\n    }\n\n    obj[implementation](name, callback, this);\n    return this;\n  };\n};","map":null,"metadata":{},"sourceType":"script"}