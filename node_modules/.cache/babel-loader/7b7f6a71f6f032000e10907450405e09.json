{"ast":null,"code":"/*!\n * algorithms/aes-cbc-hmac-sha2.js - AES-CBC-HMAC-SHA2 Composited Encryption\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar helpers = require(\"./helpers.js\"),\n    HMAC = require(\"./hmac.js\"),\n    sha = require(\"./sha.js\"),\n    forge = require(\"../deps/forge.js\"),\n    DataBuffer = require(\"../util/databuffer.js\"),\n    util = require(\"../util\");\n\nfunction checkIv(iv) {\n  if (16 !== iv.length) {\n    throw new Error(\"invalid iv\");\n  }\n}\n\nfunction commonCbcEncryptFN(size) {\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function (encKey, pdata, iv) {\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n    promise = promise.then(function () {\n      var cipher = forge.cipher.createCipher(\"AES-CBC\", new DataBuffer(encKey));\n      cipher.start({\n        iv: new DataBuffer(iv)\n      }); // TODO: chunk data\n\n      cipher.update(new DataBuffer(pdata));\n\n      if (!cipher.finish()) {\n        return Promise.reject(new Error(\"encryption failed\"));\n      }\n\n      var cdata = cipher.output.native();\n      return cdata;\n    });\n    return promise;\n  }; // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n\n\n  var webcrypto = function (encKey, pdata, iv) {\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n    promise = promise.then(function () {\n      var alg = {\n        name: \"AES-CBC\"\n      };\n      return helpers.subtleCrypto.importKey(\"raw\", encKey, alg, true, [\"encrypt\"]);\n    });\n    promise = promise.then(function (key) {\n      var alg = {\n        name: \"AES-CBC\",\n        iv: iv\n      };\n      return helpers.subtleCrypto.encrypt(alg, key, pdata);\n    });\n    promise = promise.then(function (cdata) {\n      cdata = new Buffer(cdata);\n      return cdata;\n    });\n    return promise;\n  }; // ### NodeJS implementation\n\n\n  var nodejs = function (encKey, pdata, iv) {\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve(pdata);\n    promise = promise.then(function (pdata) {\n      var name = \"AES-\" + size + \"-CBC\";\n      var cipher = helpers.nodeCrypto.createCipheriv(name, encKey, iv);\n      var cdata = Buffer.concat([cipher.update(pdata), cipher.final()]);\n      return cdata;\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction commonCbcDecryptFN(size) {\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function (encKey, cdata, iv) {\n    // validate inputs\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n    promise = promise.then(function () {\n      var cipher = forge.cipher.createDecipher(\"AES-CBC\", new DataBuffer(encKey));\n      cipher.start({\n        iv: new DataBuffer(iv)\n      }); // TODO: chunk data\n\n      cipher.update(new DataBuffer(cdata));\n\n      if (!cipher.finish()) {\n        return Promise.reject(new Error(\"encryption failed\"));\n      }\n\n      var pdata = cipher.output.native();\n      return pdata;\n    });\n    return promise;\n  }; // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n\n\n  var webcrypto = function (encKey, cdata, iv) {\n    // validate inputs\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n    promise = promise.then(function () {\n      var alg = {\n        name: \"AES-CBC\"\n      };\n      return helpers.subtleCrypto.importKey(\"raw\", encKey, alg, true, [\"decrypt\"]);\n    });\n    promise = promise.then(function (key) {\n      var alg = {\n        name: \"AES-CBC\",\n        iv: iv\n      };\n      return helpers.subtleCrypto.decrypt(alg, key, cdata);\n    });\n    promise = promise.then(function (pdata) {\n      pdata = new Buffer(pdata);\n      return pdata;\n    });\n    return promise;\n  }; // ### NodeJS implementation\n\n\n  var nodejs = function (encKey, cdata, iv) {\n    // validate inputs\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n    promise = promise.then(function () {\n      var name = \"AES-\" + size + \"-CBC\";\n      var cipher = helpers.nodeCrypto.createDecipheriv(name, encKey, iv);\n      var pdata = Buffer.concat([cipher.update(cdata), cipher.final()]);\n      return pdata;\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction checkKey(key, size) {\n  if (size << 1 !== key.length << 3) {\n    throw new Error(\"invalid encryption key size\");\n  }\n}\n\nfunction cbcHmacEncryptFN(size) {\n  var commonEncrypt = commonCbcEncryptFN(size);\n  return function (key, pdata, props) {\n    // validate inputs\n    try {\n      checkKey(key, size);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var eKey = key.slice(size / 8),\n        iKey = key.slice(0, size / 8),\n        iv = props.iv || new Buffer(0),\n        adata = props.aad || props.adata || new Buffer(0); // STEP 1 -- Encrypt\n\n    var promise = commonEncrypt(eKey, pdata, iv); // STEP 2 -- MAC\n\n    promise = promise.then(function (cdata) {\n      var mdata = Buffer.concat([adata, iv, cdata, helpers.int64ToBuffer(adata.length * 8)]);\n      var promise;\n      promise = HMAC[\"HS\" + size * 2].sign(iKey, mdata, {\n        length: size\n      });\n      promise = promise.then(function (result) {\n        // TODO: move slice to hmac.js\n        var tag = result.mac.slice(0, size / 8);\n        return {\n          data: cdata,\n          tag: tag\n        };\n      });\n      return promise;\n    });\n    return promise;\n  };\n}\n\nfunction cbcHmacDecryptFN(size) {\n  var commonDecrypt = commonCbcDecryptFN(size);\n  return function (key, cdata, props) {\n    // validate inputs\n    try {\n      checkKey(key, size);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var eKey = key.slice(size / 8),\n        iKey = key.slice(0, size / 8),\n        iv = props.iv || new Buffer(0),\n        adata = props.aad || props.adata || new Buffer(0),\n        tag = props.tag || props.mac || new Buffer(0);\n    var promise = Promise.resolve(); // STEP 1 -- MAC\n\n    promise = promise.then(function () {\n      var promise; // construct MAC input\n\n      var mdata = Buffer.concat([adata, iv, cdata, helpers.int64ToBuffer(adata.length * 8)]);\n      promise = HMAC[\"HS\" + size * 2].verify(iKey, mdata, tag, {\n        length: size\n      });\n      promise = promise.then(function () {\n        return cdata;\n      }, function () {\n        // failure -- invalid tag error\n        throw new Error(\"mac check failed\");\n      });\n      return promise;\n    }); // STEP 2 -- Decrypt\n\n    promise = promise.then(function () {\n      return commonDecrypt(eKey, cdata, iv);\n    });\n    return promise;\n  };\n}\n\nvar EncryptionLabel = new Buffer(\"Encryption\", \"utf8\");\nvar IntegrityLabel = new Buffer(\"Integrity\", \"utf8\");\nvar DotLabel = new Buffer(\".\", \"utf8\");\n\nfunction generateCek(masterKey, alg, epu, epv) {\n  var masterSize = masterKey.length * 8;\n  var cekSize = masterSize / 2;\n  var promise = Promise.resolve();\n  promise = promise.then(function () {\n    var input = Buffer.concat([helpers.int32ToBuffer(1), masterKey, helpers.int32ToBuffer(cekSize), new Buffer(alg, \"utf8\"), epu, epv, EncryptionLabel]);\n    return input;\n  });\n  promise = promise.then(function (input) {\n    return sha[\"SHA-\" + masterSize].digest(input).then(function (digest) {\n      return digest.slice(0, cekSize / 8);\n    });\n  });\n  promise = Promise.resolve(promise);\n  return promise;\n}\n\nfunction generateCik(masterKey, alg, epu, epv) {\n  var masterSize = masterKey.length * 8;\n  var cikSize = masterSize;\n  var promise = Promise.resolve();\n  promise = promise.then(function () {\n    var input = Buffer.concat([helpers.int32ToBuffer(1), masterKey, helpers.int32ToBuffer(cikSize), new Buffer(alg, \"utf8\"), epu, epv, IntegrityLabel]);\n    return input;\n  });\n  promise = promise.then(function (input) {\n    return sha[\"SHA-\" + masterSize].digest(input).then(function (digest) {\n      return digest.slice(0, cikSize / 8);\n    });\n  });\n  promise = Promise.resolve(promise);\n  return promise;\n}\n\nfunction concatKdfCbcHmacEncryptFN(size, alg) {\n  var commonEncrypt = commonCbcEncryptFN(size);\n  return function (key, pdata, props) {\n    var epu = props.epu || helpers.int32ToBuffer(0),\n        epv = props.epv || helpers.int32ToBuffer(0),\n        iv = props.iv || new Buffer(0),\n        adata = props.aad || props.adata || new Buffer(0),\n        kdata = props.kdata || new Buffer(0); // Pre Step 1 -- Generate Keys\n\n    var promises = [generateCek(key, alg, epu, epv), generateCik(key, alg, epu, epv)];\n    var cek, cik;\n    var promise = Promise.all(promises).then(function (keys) {\n      cek = keys[0];\n      cik = keys[1];\n    }); // STEP 1 -- Encrypt\n\n    promise = promise.then(function () {\n      return commonEncrypt(cek, pdata, iv);\n    }); // STEP 2 -- Mac\n\n    promise = promise.then(function (cdata) {\n      var mdata = Buffer.concat([adata, DotLabel, new Buffer(kdata), DotLabel, new Buffer(util.base64url.encode(iv), \"utf8\"), DotLabel, new Buffer(util.base64url.encode(cdata), \"utf8\")]);\n      return Promise.all([Promise.resolve(cdata), HMAC[\"HS\" + size * 2].sign(cik, mdata, {\n        length: size\n      })]);\n    });\n    promise = promise.then(function (result) {\n      return {\n        data: result[0],\n        tag: result[1].mac\n      };\n    });\n    return promise;\n  };\n}\n\nfunction concatKdfCbcHmacDecryptFN(size, alg) {\n  var commonDecrypt = commonCbcDecryptFN(size);\n  return function (key, cdata, props) {\n    var epu = props.epu || helpers.int32ToBuffer(0),\n        epv = props.epv || helpers.int32ToBuffer(0),\n        iv = props.iv || new Buffer(0),\n        adata = props.aad || props.adata || new Buffer(0),\n        kdata = props.kdata || new Buffer(0),\n        tag = props.tag || props.mac || new Buffer(0); // Pre Step 1 -- Generate Keys\n\n    var promises = [generateCek(key, alg, epu, epv), generateCik(key, alg, epu, epv)];\n    var cek, cik;\n    var promise = Promise.all(promises).then(function (keys) {\n      cek = keys[0];\n      cik = keys[1];\n    }); // STEP 1 -- MAC\n\n    promise = promise.then(function () {\n      // construct MAC input\n      var mdata = Buffer.concat([adata, DotLabel, new Buffer(kdata), DotLabel, new Buffer(util.base64url.encode(iv), \"utf8\"), DotLabel, new Buffer(util.base64url.encode(cdata), \"utf8\")]);\n\n      try {\n        return HMAC[\"HS\" + size * 2].verify(cik, mdata, tag, {\n          loose: false\n        });\n      } catch (e) {\n        throw new Error(\"mac check failed\");\n      }\n    }); // STEP 2 -- Decrypt\n\n    promise = promise.then(function () {\n      return commonDecrypt(cek, cdata, iv);\n    });\n    return promise;\n  };\n} // ### Public API\n// * [name].encrypt\n// * [name].decrypt\n\n\nvar aesCbcHmacSha2 = {};\n[\"A128CBC-HS256\", \"A192CBC-HS384\", \"A256CBC-HS512\"].forEach(function (alg) {\n  var size = parseInt(/A(\\d+)CBC-HS(\\d+)?/g.exec(alg)[1]);\n  aesCbcHmacSha2[alg] = {\n    encrypt: cbcHmacEncryptFN(size),\n    decrypt: cbcHmacDecryptFN(size)\n  };\n});\n[\"A128CBC+HS256\", \"A192CBC+HS384\", \"A256CBC+HS512\"].forEach(function (alg) {\n  var size = parseInt(/A(\\d+)CBC\\+HS(\\d+)?/g.exec(alg)[1]);\n  aesCbcHmacSha2[alg] = {\n    encrypt: concatKdfCbcHmacEncryptFN(size, alg),\n    decrypt: concatKdfCbcHmacDecryptFN(size, alg)\n  };\n});\nmodule.exports = aesCbcHmacSha2;","map":null,"metadata":{},"sourceType":"script"}