{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _defineProperty = require('babel-runtime/core-js/object/define-property');\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _weakMap = require('babel-runtime/core-js/weak-map');\n\nvar _weakMap2 = _interopRequireDefault(_weakMap);\n\nvar _desc, _value, _class, _descriptor;\n\nvar _coreDecorators = require('core-decorators');\n\nvar _ampersandEvents = require('ampersand-events');\n\nvar _ampersandEvents2 = _interopRequireDefault(_ampersandEvents);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _initDefineProp(target, property, descriptor, context) {\n  if (!descriptor) return;\n  (0, _defineProperty2.default)(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nfunction _initializerWarningHelper(descriptor, context) {\n  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');\n} // hold onto weak references to parent' Sparks to help avoid retain cycles\n\n\nvar sparks = new _weakMap2.default();\n/**\n * Base plugin class. Doesn't depend on Ampersand State\n */\n\nvar StatelessSparkPlugin = (_class = function () {\n  (0, _createClass3.default)(StatelessSparkPlugin, [{\n    key: 'config',\n\n    /**\n     * The config for this plugin's namespace. If no namespace has been set\n     * returns all of spark's config.\n     * @type {Object}\n     */\n    get: function get() {\n      var namespace = this.getNamespace ? this.getNamespace() : this.namespace;\n\n      if (namespace) {\n        namespace = namespace.toLowerCase();\n        return this.spark.config[namespace];\n      }\n\n      return this.spark.config;\n    }\n    /**\n     * A reference to the spark logger.\n     * @type {Logger}\n     */\n\n  }, {\n    key: 'logger',\n    get: function get() {\n      return this.spark.logger;\n    }\n    /**\n     * A reference to the main sdk instance\n     * @type {SparkCore}\n     */\n\n  }, {\n    key: 'spark',\n    get: function get() {\n      return sparks.get(this);\n    }\n    /**\n     * Mostly here for compatibility with legacy SparkPlugins.\n     * StatelessSparkPlugins will never have a state other than ready, however, if\n     * we implement stateful SparkPlugins as es6 classes, they may have the option\n     * to have ready be false\n     * @private\n     * @type {boolean}\n     */\n\n  }]);\n  /**\n   * Constructor. One of attrs.spark or options.parent is required\n   * @param {Object} attrs\n   * @param {SparkCore} [attrs.spark]\n   * @param {Object} options\n   * @param {SparkCore} [options.parent]\n   */\n\n  function StatelessSparkPlugin() {\n    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck3.default)(this, StatelessSparkPlugin);\n\n    _initDefineProp(this, 'ready', _descriptor, this);\n\n    var spark = attrs.spark || options.parent;\n\n    if (!spark) {\n      throw new Error('One of `attrs.spark` or `options.parent` must be supplied when initializing a StatelessSparkPlugin');\n    }\n\n    while (spark.parent || spark.collection) {\n      spark = spark.parent || spark.collection;\n    }\n\n    sparks.set(this, spark);\n  }\n  /**\n   * Proxies to {@link SparkPlugin#spark}'s `request()` method.\n   * @see SparkCore#request\n   * @param {Array<mixed>} args\n   * @returns {Promise}\n   */\n\n\n  (0, _createClass3.default)(StatelessSparkPlugin, [{\n    key: 'request',\n    value: function request() {\n      var _spark;\n\n      return (_spark = this.spark).request.apply(_spark, arguments);\n    }\n    /**\n     * Proxies to {@link SparkPlugin#spark}'s `upload()` method.\n     * @see SparkCore#upload\n     * @param {Array<mixed>} args\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'upload',\n    value: function upload() {\n      var _spark2;\n\n      return (_spark2 = this.spark).upload.apply(_spark2, arguments);\n    }\n  }]);\n  return StatelessSparkPlugin;\n}(), _descriptor = _applyDecoratedDescriptor(_class.prototype, 'ready', [_coreDecorators.readonly], {\n  enumerable: true,\n  initializer: function initializer() {\n    return true;\n  }\n}), _class);\nexports.default = StatelessSparkPlugin;\n(0, _assign2.default)(StatelessSparkPlugin.prototype, _ampersandEvents2.default);","map":null,"metadata":{},"sourceType":"script"}