{"ast":null,"code":"var AmpersandEvents = require('ampersand-events');\n\nvar classExtend = require('ampersand-class-extend');\n\nvar isArray = require('lodash/isArray');\n\nvar bind = require('lodash/bind');\n\nvar assign = require('lodash/assign');\n\nvar slice = [].slice;\n\nfunction Collection(models, options) {\n  options || (options = {});\n  if (options.model) this.model = options.model;\n  if (options.comparator) this.comparator = options.comparator;\n  if (options.parent) this.parent = options.parent;\n\n  if (!this.mainIndex) {\n    var idAttribute = this.model && this.model.prototype && this.model.prototype.idAttribute;\n    this.mainIndex = idAttribute || 'id';\n  }\n\n  this._reset();\n\n  this.initialize.apply(this, arguments);\n  if (models) this.reset(models, assign({\n    silent: true\n  }, options));\n}\n\nassign(Collection.prototype, AmpersandEvents, {\n  initialize: function () {},\n  isModel: function (model) {\n    return this.model && model instanceof this.model;\n  },\n  add: function (models, options) {\n    return this.set(models, assign({\n      merge: false,\n      add: true,\n      remove: false\n    }, options));\n  },\n  // overridable parse method\n  parse: function (res, options) {\n    return res;\n  },\n  // overridable serialize method\n  serialize: function () {\n    return this.map(function (model) {\n      if (model.serialize) {\n        return model.serialize();\n      } else {\n        var out = {};\n        assign(out, model);\n        delete out.collection;\n        return out;\n      }\n    });\n  },\n  toJSON: function () {\n    return this.serialize();\n  },\n  set: function (models, options) {\n    options = assign({\n      add: true,\n      remove: true,\n      merge: true\n    }, options);\n    if (options.parse) models = this.parse(models, options);\n    var singular = !isArray(models);\n    models = singular ? models ? [models] : [] : models.slice();\n    var id, model, attrs, existing, sort, i, length;\n    var at = options.at;\n    var sortable = this.comparator && at == null && options.sort !== false;\n    var sortAttr = 'string' === typeof this.comparator ? this.comparator : null;\n    var toAdd = [],\n        toRemove = [],\n        modelMap = {};\n    var add = options.add,\n        merge = options.merge,\n        remove = options.remove;\n    var order = !sortable && add && remove ? [] : false;\n    var targetProto = this.model && this.model.prototype || Object.prototype; // Turn bare objects into model references, and prevent invalid models\n    // from being added.\n\n    for (i = 0, length = models.length; i < length; i++) {\n      attrs = models[i] || {};\n\n      if (this.isModel(attrs)) {\n        id = model = attrs;\n      } else if (targetProto.generateId) {\n        id = targetProto.generateId(attrs);\n      } else {\n        id = attrs[this.mainIndex];\n\n        if (id === undefined && this._isDerivedIndex(targetProto)) {\n          id = targetProto._derived[this.mainIndex].fn.call(attrs);\n        }\n      } // If a duplicate is found, prevent it from being added and\n      // optionally merge it into the existing model.\n\n\n      if (existing = this.get(id)) {\n        if (remove) modelMap[existing.cid || existing[this.mainIndex]] = true;\n\n        if (merge) {\n          attrs = attrs === model ? model.attributes : attrs;\n          if (options.parse) attrs = existing.parse(attrs, options); // if this is model\n\n          if (existing.set) {\n            existing.set(attrs, options);\n            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;\n          } else {\n            // if not just update the properties\n            assign(existing, attrs);\n          }\n        }\n\n        models[i] = existing; // If this is a new, valid model, push it to the `toAdd` list.\n      } else if (add) {\n        model = models[i] = this._prepareModel(attrs, options);\n        if (!model) continue;\n        toAdd.push(model);\n\n        this._addReference(model, options);\n      } // Do not add multiple models with the same `id`.\n\n\n      model = existing || model;\n      if (!model) continue;\n      if (order && (model.isNew && model.isNew() || !model[this.mainIndex] || !modelMap[model.cid || model[this.mainIndex]])) order.push(model);\n      modelMap[model[this.mainIndex]] = true;\n    } // Remove nonexistent models if appropriate.\n\n\n    if (remove) {\n      for (i = 0, length = this.length; i < length; i++) {\n        model = this.models[i];\n        if (!modelMap[model.cid || model[this.mainIndex]]) toRemove.push(model);\n      }\n\n      if (toRemove.length) this.remove(toRemove, options); // Add indexes again to make sure they were not removed above.\n\n      for (i = 0, length = toAdd.length; i < length; i++) {\n        this._index(toAdd[i]);\n      }\n    } // See if sorting is needed, update `length` and splice in new models.\n\n\n    if (toAdd.length || order && order.length) {\n      if (sortable) sort = true;\n\n      if (at != null) {\n        for (i = 0, length = toAdd.length; i < length; i++) {\n          this.models.splice(at + i, 0, toAdd[i]);\n        }\n      } else {\n        var orderedModels = order || toAdd;\n\n        for (i = 0, length = orderedModels.length; i < length; i++) {\n          this.models.push(orderedModels[i]);\n        }\n      }\n    } // Silently sort the collection if appropriate.\n\n\n    if (sort) this.sort({\n      silent: true\n    }); // Unless silenced, it's time to fire all appropriate add/sort events.\n\n    if (!options.silent) {\n      for (i = 0, length = toAdd.length; i < length; i++) {\n        model = toAdd[i];\n\n        if (model.trigger) {\n          model.trigger('add', model, this, options);\n        } else {\n          this.trigger('add', model, this, options);\n        }\n      }\n\n      if (sort || order && order.length) this.trigger('sort', this, options);\n    } // Return the added (or merged) model (or models).\n\n\n    return singular ? models[0] : models;\n  },\n  get: function (query, indexName) {\n    if (query == null) return;\n    var collectionMainIndex = this.mainIndex;\n    var index = this._indexes[indexName || collectionMainIndex];\n    return index && (index[query] || query[collectionMainIndex] !== undefined && index[query[collectionMainIndex]]) || this._indexes.cid[query] || this._indexes.cid[query.cid];\n  },\n  // Get the model at the given index.\n  at: function (index) {\n    return this.models[index];\n  },\n  remove: function (models, options) {\n    var singular = !isArray(models);\n    var i, length, model, index;\n    models = singular ? [models] : slice.call(models);\n    options || (options = {});\n\n    for (i = 0, length = models.length; i < length; i++) {\n      model = models[i] = this.get(models[i]);\n      if (!model) continue;\n\n      this._deIndex(model);\n\n      index = this.models.indexOf(model);\n      this.models.splice(index, 1);\n\n      if (!options.silent) {\n        options.index = index;\n\n        if (model.trigger) {\n          model.trigger('remove', model, this, options);\n        } else {\n          this.trigger('remove', model, this, options);\n        }\n      }\n\n      this._removeReference(model, options);\n    }\n\n    return singular ? models[0] : models;\n  },\n  // When you have more items than you want to add or remove individually,\n  // you can reset the entire set with a new list of models, without firing\n  // any granular `add` or `remove` events. Fires `reset` when finished.\n  // Useful for bulk operations and optimizations.\n  reset: function (models, options) {\n    options || (options = {});\n\n    for (var i = 0, length = this.models.length; i < length; i++) {\n      this._removeReference(this.models[i], options);\n    }\n\n    options.previousModels = this.models;\n\n    this._reset();\n\n    models = this.add(models, assign({\n      silent: true\n    }, options));\n    if (!options.silent) this.trigger('reset', this, options);\n    return models;\n  },\n  sort: function (options) {\n    var self = this;\n    if (!this.comparator) throw new Error('Cannot sort a set without a comparator');\n    options || (options = {});\n\n    if (typeof this.comparator === 'string') {\n      this.models.sort(function (left, right) {\n        if (left.get) {\n          left = left.get(self.comparator);\n          right = right.get(self.comparator);\n        } else {\n          left = left[self.comparator];\n          right = right[self.comparator];\n        }\n\n        if (left > right || left === void 0) return 1;\n        if (left < right || right === void 0) return -1;\n        return 0;\n      });\n    } else if (this.comparator.length === 1) {\n      this.models.sort(function (left, right) {\n        left = self.comparator(left);\n        right = self.comparator(right);\n        if (left > right || left === void 0) return 1;\n        if (left < right || right === void 0) return -1;\n        return 0;\n      });\n    } else {\n      this.models.sort(bind(this.comparator, this));\n    }\n\n    if (!options.silent) this.trigger('sort', this, options);\n    return this;\n  },\n  // Private method to reset all internal state. Called when the collection\n  // is first initialized or reset.\n  _reset: function () {\n    var list = slice.call(this.indexes || []);\n    var i = 0;\n    list.push(this.mainIndex);\n    list.push('cid');\n    var l = list.length;\n    this.models = [];\n    this._indexes = {};\n\n    for (; i < l; i++) {\n      this._indexes[list[i]] = {};\n    }\n  },\n  _prepareModel: function (attrs, options) {\n    // if we haven't defined a constructor, skip this\n    if (!this.model) return attrs;\n\n    if (this.isModel(attrs)) {\n      if (!attrs.collection) attrs.collection = this;\n      return attrs;\n    } else {\n      options = options ? assign({}, options) : {};\n      options.collection = this;\n      var model = new this.model(attrs, options);\n      if (!model.validationError) return model;\n      this.trigger('invalid', this, model.validationError, options);\n      return false;\n    }\n  },\n  _deIndex: function (model, attribute, value) {\n    var indexVal;\n\n    if (attribute !== undefined) {\n      if (undefined === this._indexes[attribute]) throw new Error('Given attribute is not an index');\n      delete this._indexes[attribute][value];\n      return;\n    } // Not a specific attribute\n\n\n    for (var indexAttr in this._indexes) {\n      indexVal = model.hasOwnProperty(indexAttr) ? model[indexAttr] : model.get && model.get(indexAttr);\n      delete this._indexes[indexAttr][indexVal];\n    }\n  },\n  _index: function (model, attribute) {\n    var indexVal;\n\n    if (attribute !== undefined) {\n      if (undefined === this._indexes[attribute]) throw new Error('Given attribute is not an index');\n      indexVal = model[attribute] || model.get && model.get(attribute);\n      if (indexVal) this._indexes[attribute][indexVal] = model;\n      return;\n    } // Not a specific attribute\n\n\n    for (var indexAttr in this._indexes) {\n      indexVal = model.hasOwnProperty(indexAttr) ? model[indexAttr] : model.get && model.get(indexAttr);\n      if (indexVal != null) this._indexes[indexAttr][indexVal] = model;\n    }\n  },\n  _isDerivedIndex: function (proto) {\n    if (!proto || typeof proto._derived !== 'object') {\n      return false;\n    }\n\n    return Object.keys(proto._derived).indexOf(this.mainIndex) >= 0;\n  },\n  // Internal method to create a model's ties to a collection.\n  _addReference: function (model, options) {\n    this._index(model);\n\n    if (!model.collection) model.collection = this;\n    if (model.on) model.on('all', this._onModelEvent, this);\n  },\n  // Internal method to sever a model's ties to a collection.\n  _removeReference: function (model, options) {\n    if (this === model.collection) delete model.collection;\n\n    this._deIndex(model);\n\n    if (model.off) model.off('all', this._onModelEvent, this);\n  },\n  _onModelEvent: function (event, model, collection, options) {\n    var eventName = event.split(':')[0];\n    var attribute = event.split(':')[1];\n    if ((eventName === 'add' || eventName === 'remove') && collection !== this) return;\n    if (eventName === 'destroy') this.remove(model, options);\n\n    if (model && eventName === 'change' && attribute && this._indexes[attribute]) {\n      this._deIndex(model, attribute, model.previousAttributes()[attribute]);\n\n      this._index(model, attribute);\n    }\n\n    this.trigger.apply(this, arguments);\n  }\n});\nObject.defineProperties(Collection.prototype, {\n  length: {\n    get: function () {\n      return this.models.length;\n    }\n  },\n  isCollection: {\n    get: function () {\n      return true;\n    }\n  }\n});\nvar arrayMethods = ['indexOf', 'lastIndexOf', 'every', 'some', 'forEach', 'map', 'filter', 'reduce', 'reduceRight'];\narrayMethods.forEach(function (method) {\n  Collection.prototype[method] = function () {\n    return this.models[method].apply(this.models, arguments);\n  };\n}); // alias each/forEach for maximum compatibility\n\nCollection.prototype.each = Collection.prototype.forEach;\nCollection.extend = classExtend;\nmodule.exports = Collection;","map":null,"metadata":{},"sourceType":"script"}