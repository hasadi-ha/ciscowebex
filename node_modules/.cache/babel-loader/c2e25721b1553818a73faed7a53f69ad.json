{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TIMEOUT_SYMBOL = undefined;\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _symbol = require('babel-runtime/core-js/symbol');\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _commonTimers = require('@webex/common-timers');\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _kmsErrors = require('./kms-errors');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar TIMEOUT_SYMBOL = exports.TIMEOUT_SYMBOL = (0, _symbol2.default)('TIMEOUT_SYMBOL');\n/**\n * @class\n */\n\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\nvar KmsBatcher = _webexCore.Batcher.extend({\n  namespace: 'Encryption',\n\n  /**\n   * Accepts a kmsMessage event and passes its contents to acceptItem\n   * @param {Object} event\n   * @returns {Promise}\n   */\n  processKmsMessageEvent: function processKmsMessageEvent(event) {\n    var _this = this;\n\n    this.logger.info('kms-batcher: received kms message');\n    return _promise2.default.all(event.encryption.kmsMessages.map(function (kmsMessage) {\n      return new _promise2.default(function (resolve) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n          _this.logger.info('kms-batcher:', kmsMessage.body);\n        }\n\n        resolve(_this.acceptItem(kmsMessage));\n      });\n    }));\n  },\n\n  /**\n   * Attaches a timeout to the given KMS message\n   * @param {Object} item\n   * @returns {Promise<Object>}\n   */\n  prepareItem: function prepareItem(item) {\n    var _this2 = this;\n\n    return this.getDeferredForRequest(item).then(function (defer) {\n      var timeout = item[TIMEOUT_SYMBOL];\n      /* istanbul ignore if */\n\n      if (!timeout) {\n        throw new Error('timeout is required');\n      }\n\n      var timer = (0, _commonTimers.safeSetTimeout)(function () {\n        _this2.logger.warn('kms: request timed out; request id: ' + item.requestId + '; timeout: ' + timeout);\n\n        _this2.handleItemFailure(item, new _kmsErrors.KmsTimeoutError({\n          timeout: timeout,\n          request: item\n        }));\n      }, timeout); // Reminder: reassign `promise` is not a viable means of inserting into\n      // the Promise chain\n\n      defer.promise.then(function () {\n        return clearTimeout(timer);\n      });\n      defer.promise.catch(function () {\n        return clearTimeout(timer);\n      });\n      return item;\n    });\n  },\n\n  /**\n   * Attaches the final bits of cluster info to the payload\n   * @param {Array} queue\n   * @returns {Promise<Array>}\n   */\n  prepareRequest: function prepareRequest(queue) {\n    return this.spark.internal.encryption.kms._getKMSCluster().then(function (cluster) {\n      return {\n        destination: cluster,\n        kmsMessages: queue.map(function (req) {\n          return req.wrapped;\n        })\n      };\n    });\n  },\n\n  /**\n   * @param {Object} payload\n   * @returns {Promise<HttpResponseObject>}\n   */\n  submitHttpRequest: function submitHttpRequest(payload) {\n    this.logger.info('kms: batched-request-length', payload.kmsMessages.length);\n    return this.spark.request({\n      method: 'POST',\n      service: 'encryption',\n      resource: '/kms/messages',\n      body: payload\n    });\n  },\n\n  /**\n   * Does nothing; the http response doesn't carry our response data\n   * @returns {Promise}\n   */\n  handleHttpSuccess: function handleHttpSuccess() {\n    return _promise2.default.resolve();\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise<boolean>}\n   */\n  didItemFail: function didItemFail(item) {\n    return _promise2.default.resolve(item.status >= 400);\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  handleItemSuccess: function handleItemSuccess(item) {\n    return this.getDeferredForResponse(item).then(function (defer) {\n      defer.resolve(item.body);\n    });\n  },\n\n  /**\n   * @param {Object} item\n   * @param {KmsError} [reason]\n   * @returns {Promise}\n   */\n  handleItemFailure: function handleItemFailure(item, reason) {\n    return this.getDeferredForResponse(item).then(function (defer) {\n      defer.reject(reason || new _kmsErrors.KmsError(item.body));\n    });\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  fingerprintRequest: function fingerprintRequest(item) {\n    return _promise2.default.resolve(item.requestId);\n  },\n\n  /**\n   * @param {Object} item\n   * @returns {Promise}\n   */\n  fingerprintResponse: function fingerprintResponse(item) {\n    return _promise2.default.resolve(item.requestId);\n  }\n});\n\nexports.default = KmsBatcher;","map":null,"metadata":{},"sourceType":"script"}