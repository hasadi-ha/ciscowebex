{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _wrap2 = require('lodash/wrap');\n\nvar _wrap3 = _interopRequireDefault(_wrap2);\n\nvar _isFunction2 = require('lodash/isFunction');\n\nvar _isFunction3 = _interopRequireDefault(_isFunction2);\n\nvar _defaults2 = require('lodash/defaults');\n\nvar _defaults3 = _interopRequireDefault(_defaults2);\n\nexports.default = retry;\n\nvar _events = require('events');\n\nvar _backoff = require('backoff');\n\nvar _backoff2 = _interopRequireDefault(_backoff);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint max-nested-callbacks: [0] */\n\n/**\n * Makes a promise-returning method retryable according to the specified backoff\n * pattern\n * @param {Object} options\n * @param {boolean} options.backoff\n * @param {number} options.delay\n * @param {number} options.initialDelay\n * @param {number} options.maxAttempts\n * @param {number} options.maxDelay\n *\n * @returns {Function}\n */\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nfunction retry() {\n  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {\n    params[_key] = arguments[_key];\n  }\n\n  var options = params[0] || {};\n  options = (0, _assign2.default)({}, options);\n  (0, _defaults3.default)(options, {\n    backoff: true,\n    delay: 1,\n    maxAttempts: 3\n  });\n  var strategyOptions = void 0;\n\n  if (options.backoff) {\n    strategyOptions = {\n      initialDelay: options.delay,\n      maxDelay: options.maxDelay\n    };\n  } else {\n    strategyOptions = {\n      initialDelay: 1,\n      maxDelay: 1\n    };\n  }\n\n  if (params.length === 3) {\n    return (0, _apply2.default)(retryDecorator, null, params);\n  }\n\n  return retryDecorator;\n  /**\n   * @param {Object} target\n   * @param {string} prop\n   * @param {Object} descriptor\n   * @private\n   * @returns {Object}\n   */\n\n  function retryDecorator(target, prop, descriptor) {\n    descriptor.value = (0, _wrap3.default)(descriptor.value, function retryExecutor(fn) {\n      var _this = this;\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      var emitter = new _events.EventEmitter();\n      var promise = new _promise2.default(function (resolve, reject) {\n        // backoff.call is not Function.prototype.call; it's an unfortunate naming\n        // collision.\n\n        /* eslint prefer-reflect: [0] */\n        var call = _backoff2.default.call(function (cb) {\n          /* eslint no-invalid-this: [0] */\n          var innerPromise = (0, _apply2.default)(fn, _this, args);\n\n          if ((0, _isFunction3.default)(innerPromise.on)) {\n            innerPromise.on('progress', emitter.emit.bind(emitter, 'progress'));\n            innerPromise.on('upload-progress', emitter.emit.bind(emitter, 'upload-progress'));\n            innerPromise.on('download-progress', emitter.emit.bind(emitter, 'download-progress'));\n          }\n\n          return innerPromise.then(function (res) {\n            cb(null, res);\n          }).catch(function (reason) {\n            if (!reason) {\n              reason = new Error('retryable method failed without providing an error object');\n            }\n\n            cb(reason);\n          });\n        }, function (err, res) {\n          if (err) {\n            return reject(err);\n          }\n\n          return resolve(res);\n        });\n\n        call.setStrategy(new _backoff2.default.ExponentialStrategy(strategyOptions));\n\n        if (options.maxAttempts) {\n          call.failAfter(options.maxAttempts - 1);\n        }\n\n        call.start();\n      });\n\n      promise.on = function on(key, callback) {\n        emitter.on(key, callback);\n        return promise;\n      };\n\n      return promise;\n    }); // This *should* make decorators compatible with AmpersandState class\n    // definitions\n\n    if ((typeof target === 'undefined' ? 'undefined' : (0, _typeof3.default)(target)) === 'object' && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    return descriptor;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}