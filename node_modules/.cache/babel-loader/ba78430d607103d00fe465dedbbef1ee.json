{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _map = require('babel-runtime/core-js/map');\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _has2 = require('lodash/has');\n\nvar _has3 = _interopRequireDefault(_has2);\n\nvar _sparkPlugin = require('./spark-plugin');\n\nvar _sparkPlugin2 = _interopRequireDefault(_sparkPlugin);\n\nvar _common = require('@webex/common');\n\nvar _sparkHttpError = require('./spark-http-error');\n\nvar _sparkHttpError2 = _interopRequireDefault(_sparkHttpError);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Base class for coalescing requests to batched APIs\n * @class Batcher\n */\n\n\nvar Batcher = _sparkPlugin2.default.extend({\n  session: {\n    deferreds: {\n      type: 'object',\n      default: function _default() {\n        return new _map2.default();\n      }\n    },\n    queue: {\n      type: 'array',\n      default: function _default() {\n        return [];\n      }\n    }\n  },\n  derived: {\n    bounce: {\n      fn: function fn() {\n        var _this = this;\n\n        return (0, _common.cappedDebounce)(function () {\n          return _this.executeQueue.apply(_this, arguments);\n        }, this.config.batcherWait, {\n          maxCalls: this.config.batcherMaxCalls,\n          maxWait: this.config.batcherMaxWait\n        });\n      }\n    }\n  },\n\n  /**\n   * Requests an item from a batched API\n   * @param {Object} item\n   * @returns {Promise<mixed>}\n   */\n  request: function request(item) {\n    var _this2 = this; // So far, I can't find a way to avoid three layers of nesting here.\n\n    /* eslint max-nested-callbacks: [0] */\n\n\n    var defer = new _common.Defer();\n    this.fingerprintRequest(item).then(function (idx) {\n      if (_this2.deferreds.has(idx)) {\n        defer.resolve(_this2.deferreds.get(idx).promise);\n        return;\n      }\n\n      _this2.deferreds.set(idx, defer);\n\n      _this2.prepareItem(item).then(function (req) {\n        defer.promise = defer.promise.then((0, _common.tap)(function () {\n          return _this2.deferreds.delete(idx);\n        })).catch(function (reason) {\n          _this2.deferreds.delete(idx);\n\n          return _promise2.default.reject(reason);\n        });\n\n        _this2.enqueue(req).then(function () {\n          return _this2.bounce();\n        }).catch(function (reason) {\n          return defer.reject(reason);\n        });\n      }).catch(function (reason) {\n        return defer.reject(reason);\n      });\n    }).catch(function (reason) {\n      return defer.reject(reason);\n    });\n    return defer.promise;\n  },\n\n  /**\n   * Adds an item to the queue.\n   * Intended to be overridden\n   * @param {mixed} req\n   * @returns {Promise<undefined>}\n   */\n  enqueue: function enqueue(req) {\n    this.queue.push(req);\n    return _promise2.default.resolve();\n  },\n\n  /**\n   * Transform the item before adding it to the queue\n   * Intended to be overridden\n   * @param {mixed} item\n   * @returns {Promise<mixed>}\n   */\n  prepareItem: function prepareItem(item) {\n    return _promise2.default.resolve(item);\n  },\n\n  /**\n   * Detaches the current queue, does any appropriate transforms, and submits it\n   * to the API.\n   * @returns {Promise<undefined>}\n   */\n  executeQueue: function executeQueue() {\n    var _this3 = this;\n\n    var queue = this.queue.splice(0, this.config.batcherMaxCalls);\n    return new _promise2.default(function (resolve) {\n      resolve(_this3.prepareRequest(queue).then(function (payload) {\n        return _this3.submitHttpRequest(payload).then(function (res) {\n          return _this3.handleHttpSuccess(res);\n        });\n      }).catch(function (reason) {\n        if (reason instanceof _sparkHttpError2.default) {\n          return _this3.handleHttpError(reason);\n        }\n\n        return _promise2.default.all(queue.map(function (item) {\n          return _this3.getDeferredForRequest(item).then(function (defer) {\n            defer.reject(reason);\n          });\n        }));\n      }));\n    }).catch(function (reason) {\n      _this3.logger.error(process.env.NODE_ENV === 'production' ? reason : reason.stack);\n\n      return _promise2.default.reject(reason);\n    });\n  },\n\n  /**\n   * Performs any final transforms on the queue before submitting it to the API\n   * Intended to be overridden\n   * @param {Object|Array} queue\n   * @returns {Promise<Object>}\n   */\n  prepareRequest: function prepareRequest(queue) {\n    return _promise2.default.resolve(queue);\n  },\n\n  /**\n   * Submits the prepared request body to the API.\n   * This method *must* be overridden\n   * @param {Object} payload\n   * @returns {Promise<HttpResponseObject>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  submitHttpRequest: function submitHttpRequest(payload) {\n    throw new Error('request() must be implemented');\n  },\n\n  /**\n   * Actions taken when the http request returns a success\n   * Intended to be overridden\n   * @param {Promise<HttpResponseObject>} res\n   * @returns {Promise<undefined>}\n   */\n  handleHttpSuccess: function handleHttpSuccess(res) {\n    var _this4 = this;\n\n    return _promise2.default.all((res.body && res.body.items || res.body).map(function (item) {\n      return _this4.acceptItem(item);\n    }));\n  },\n\n  /**\n   * Actions taken when the http request returns a failure. Typically, this\n   * means failing the entire queue, but could be overridden in some\n   * implementations to e.g. reenqueue.\n   * Intended to be overridden\n   * @param {SparkHttpError} reason\n   * @returns {Promise<undefined>}\n   */\n  handleHttpError: function handleHttpError(reason) {\n    var _this5 = this;\n\n    if (reason instanceof _sparkHttpError2.default) {\n      if ((0, _has3.default)(reason, 'options.body.map')) {\n        return _promise2.default.all(reason.options.body.map(function (item) {\n          return _this5.getDeferredForRequest(item).then(function (defer) {\n            defer.reject(reason);\n          });\n        }));\n      }\n    }\n\n    this.logger.error('http error handler called without a SparkHttpError object', reason);\n    return _promise2.default.reject(reason);\n  },\n\n  /**\n   * Determines if the item succeeded or failed and delegates accordingly\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  acceptItem: function acceptItem(item) {\n    var _this6 = this;\n\n    return this.didItemFail(item).then(function (didFail) {\n      if (didFail) {\n        return _this6.handleItemFailure(item);\n      }\n\n      return _this6.handleItemSuccess(item);\n    });\n  },\n\n  /**\n   * Indicates if the specified response item implies a success or a failure\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<Boolean>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  didItemFail: function didItemFail(item) {\n    return _promise2.default.resolve(false);\n  },\n\n  /**\n   * Finds the Defer for the specified item and rejects its promise\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  handleItemFailure: function handleItemFailure(item) {\n    return this.getDeferredForResponse(item).then(function (defer) {\n      defer.reject(item);\n    });\n  },\n\n  /**\n   * Finds the Defer for the specified item and resolves its promise\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  handleItemSuccess: function handleItemSuccess(item) {\n    return this.getDeferredForResponse(item).then(function (defer) {\n      defer.resolve(item);\n    });\n  },\n\n  /**\n   * Returns the Deferred for the specified request item\n   * @param {Object} item\n   * @returns {Promise<Defer>}\n   */\n  getDeferredForRequest: function getDeferredForRequest(item) {\n    var _this7 = this;\n\n    return this.fingerprintRequest(item).then(function (idx) {\n      var defer = _this7.deferreds.get(idx);\n      /* istanbul ignore if */\n\n\n      if (!defer) {\n        throw new Error('Could not find pending request for received response');\n      }\n\n      return defer;\n    });\n  },\n\n  /**\n   * Returns the Deferred for the specified response item\n   * @param {Object} item\n   * @returns {Promise<Defer>}\n   */\n  getDeferredForResponse: function getDeferredForResponse(item) {\n    var _this8 = this;\n\n    return this.fingerprintResponse(item).then(function (idx) {\n      var defer = _this8.deferreds.get(idx);\n      /* istanbul ignore if */\n\n\n      if (!defer) {\n        throw new Error('Could not find pending request for received response');\n      }\n\n      return defer;\n    });\n  },\n\n  /**\n   * Generates a unique identifier for the item in a request payload\n   * Intended to be overridden\n   * Note that overrides must return a primitive.\n   * @param {Object} item\n   * @returns {Promise<primitive>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  fingerprintRequest: function fingerprintRequest(item) {\n    throw new Error('fingerprintRequest() must be implemented');\n  },\n\n  /**\n   * Generates a unique identifier for the item in a response payload\n   * Intended to be overridden\n   * Note that overrides must return a primitive.\n   * @param {Object} item\n   * @returns {Promise<primitive>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  fingerprintResponse: function fingerprintResponse(item) {\n    throw new Error('fingerprintResponse() must be implemented');\n  },\n  version: '1.59.0'\n});\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nexports.default = Batcher;","map":null,"metadata":{},"sourceType":"script"}