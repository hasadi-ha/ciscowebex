{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _defineProperty = require('babel-runtime/core-js/object/define-property');\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');\n\nvar _deleteProperty2 = _interopRequireDefault(_deleteProperty);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _map = require('babel-runtime/core-js/map');\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _weakMap = require('babel-runtime/core-js/weak-map');\n\nvar _weakMap2 = _interopRequireDefault(_weakMap);\n\nvar _defaults2 = require('lodash/defaults');\n\nvar _defaults3 = _interopRequireDefault(_defaults2);\n\nvar _dec, _dec2, _desc, _value, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13;\n\nvar _bowser = require('bowser');\n\nvar _bowser2 = _interopRequireDefault(_bowser);\n\nvar _lodashDecorators = require('lodash-decorators');\n\nvar _coreDecorators = require('core-decorators');\n\nvar _common = require('@webex/common');\n\nvar _commonEvented = require('@webex/common-evented');\n\nvar _commonEvented2 = _interopRequireDefault(_commonEvented);\n\nvar _ampersandEvents = require('ampersand-events');\n\nvar _ampersandEvents2 = _interopRequireDefault(_ampersandEvents);\n\nvar _sdpTransform = require('sdp-transform');\n\nvar _grammar = require('sdp-transform/lib/grammar');\n\nvar _grammar2 = _interopRequireDefault(_grammar);\n\nvar _webrtcHelpers = require('./webrtc-helpers');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _initDefineProp(target, property, descriptor, context) {\n  if (!descriptor) return;\n  (0, _defineProperty2.default)(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nfunction _initializerWarningHelper(descriptor, context) {\n  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');\n} // Add support for our custom \"content\" attribute. Note: this seems to make\n// parse() work correctly, but I don't think I could get write() to work.\n\n\nif (!_grammar2.default.a.find(function (g) {\n  return g.name === 'content';\n})) {\n  _grammar2.default.a.unshift({\n    // name appears to be where we stick the value of this field in the parsed\n    // media object\n    name: 'content',\n    // reg determines whether or not this line should be handled by this rule\n    reg: /^content:(slides)/\n  });\n}\n\nvar DirectionContainer = (0, _common.make)(_weakMap2.default, _map2.default);\nvar targetMediaDirection = new DirectionContainer();\nvar capitalize = {\n  audio: 'Audio',\n  video: 'Video'\n};\n/**\n * Wrapper around targetMediaDirection.get which return `inactive` instead of\n * undefined\n * @param {WebRTCMediaEngine} target\n * @param {string} kind\n * @private\n * @returns {string}\n */\n\nfunction getTargetMediaDirection(target, kind) {\n  return targetMediaDirection.get(target, kind) || 'inactive';\n}\n/**\n * Interface for doing webrtc things\n * @protected\n */\n\n\nvar WebRTCMediaEngine = (_dec = (0, _common.whileInFlight)('gumming'), _dec2 = (0, _lodashDecorators.debounce)(500), (_class = function () {\n  (0, _createClass3.default)(WebRTCMediaEngine, [{\n    key: 'audioDirection',\n\n    /**\n     * Returns the current audio direction\n     * @returns {string}\n     */\n    get: function get() {\n      return (0, _webrtcHelpers.getMediaDirectionFromTracks)('audio', this.pc);\n    }\n    /**\n     * Returns the current video direction\n     * @returns {string}\n     */\n\n  }, {\n    key: 'videoDirection',\n    get: function get() {\n      return (0, _webrtcHelpers.getMediaDirectionFromTracks)('video', this.pc);\n    }\n    /**\n     * Returns the current screen direction\n     * @returns {string}\n     */\n\n  }, {\n    key: 'screenDirection',\n    get: function get() {\n      return !this.localScreenShare || this.localScreenShare.getTracks().length === 0 ? 'inactive' : 'sendonly';\n    }\n    /**\n     * Returns the current tracks attached to senders\n     * @returns {string}\n     */\n\n  }, {\n    key: 'senderTracks',\n    get: function get() {\n      return this.pc.getSenders().reduce(function (acc, s) {\n        if (s.track) {\n          acc.push(s.track);\n        }\n\n        return acc;\n      }, []);\n    }\n    /**\n     * Returns the current tracks attached to receivers\n     * @returns {string}\n     */\n\n  }, {\n    key: 'receiverTracks',\n    get: function get() {\n      return this.pc.getReceivers().reduce(function (acc, r) {\n        if (r.track) {\n          acc.push(r.track);\n        }\n\n        return acc;\n      }, []);\n    }\n    /**\n     * Constructor\n     * @param {Object} attrs\n     * @param {Object} options\n     * @param {Logger} options.logger (optional): defaults to console\n     * @returns {WebRTCMediaEngine}\n     */\n\n  }], [{\n    key: 'getUserMedia',\n\n    /**\n     * Wrapper around navigator.mediaDevices.getUserMedia\n     *\n     * @param {MediaStreamContraints} constraints\n     * @returns {Promise<MediaStream>}\n     */\n    value: function getUserMedia(constraints) {\n      var finalConstraints = (0, _defaults3.default)({}, constraints, {\n        fake: process.env.NODE_ENV === 'test'\n      });\n      return navigator.mediaDevices.getUserMedia(finalConstraints);\n    }\n    /**\n     * Represents the local party's outgoing stream. Instantiated when the class\n     * is instantiated.\n     * @type {MediaStream}\n     */\n\n    /**\n     * Represent the remote party's incoming media. Instantiated when the class is\n     * instantiated.\n     * @type {MediaStream}\n     */\n\n    /**\n     * Reserved for future use\n     * @type {MediaStream}\n     */\n\n    /**\n     * Peer Connection\n     * Explicitly set Plan B. RTCPeerConnections generate and expect the standards compliant SDP format\n     * called \"Unified Plan\", unless \"Plan B\" is explicitly specified by passing {sdpSemantics:'plan-b'}\n     * to the RTCPeerConnection constructor.\n     *\n     * chrome://flags/#webrtc-unified-plan-by-default\n     * https://docs.google.com/document/d/1-ZfikoUtoJa9k-GZG1daN0BU3IjIanQ_JSscHxQesvU/edit?usp=sharing\n     * @type {RTCPeerConnection}\n     */\n\n    /**\n     * The most-recently produced offer\n     * @private\n     */\n\n    /**\n     * The most-recently accepted answer\n     * @private\n     */\n\n  }]);\n\n  function WebRTCMediaEngine() {\n    var _this = this;\n\n    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck3.default)(this, WebRTCMediaEngine);\n    this.logger = console;\n\n    _initDefineProp(this, 'localMediaStream', _descriptor, this);\n\n    _initDefineProp(this, 'remoteMediaStream', _descriptor2, this);\n\n    _initDefineProp(this, 'localScreenShare', _descriptor3, this);\n\n    this.pc = new RTCPeerConnection({\n      iceServers: [],\n      bundlePolicy: 'max-compat',\n      sdpSemantics: 'plan-b'\n    });\n\n    _initDefineProp(this, 'offerSdp', _descriptor4, this);\n\n    _initDefineProp(this, 'answerSdp', _descriptor5, this);\n\n    _initDefineProp(this, 'sendingAudio', _descriptor6, this);\n\n    _initDefineProp(this, 'sendingVideo', _descriptor7, this);\n\n    _initDefineProp(this, 'receivingAudio', _descriptor8, this);\n\n    _initDefineProp(this, 'receivingVideo', _descriptor9, this);\n\n    _initDefineProp(this, 'ended', _descriptor10, this);\n\n    this.negotiationNeeded = false;\n    this.bandwidthLimit = {\n      audioBandwidthLimit: 60000,\n      videoBandwidthLimit: 1000000\n    };\n\n    _initDefineProp(this, 'constraints', _descriptor11, this);\n\n    _initDefineProp(this, 'offerOptions', _descriptor12, this);\n\n    _initDefineProp(this, 'gumming', _descriptor13, this);\n\n    if (options.parent) {\n      // This is a bit of weirdness to maintain amp-state compatibility\n      process.nextTick(function () {\n        if (options.parent.logger) {\n          _this.logger = options.parent.logger;\n        }\n      });\n    } else if (attrs.logger) {\n      this.logger = attrs.logger;\n    }\n\n    this.pc.onnegotiationneeded = function () {\n      _this.logger.info('peer connection emitted negotiationneeded');\n\n      if (_this.answerSdp && !_this.negotiationNeeded) {\n        _this.negotiationNeeded = true;\n\n        _this.triggerNegotiationNeeded();\n      }\n    }; // Note: adapter.js doesn't seem to fully shim the track event.\n    // addEventListener doesn't appear to work for it in chrome\n\n\n    this.pc.ontrack = function (event) {\n      _this.logger.info('peerConnection ontrack fired, updating remoteMediaStream');\n\n      _this.trigger('track');\n\n      var stream = _this.remoteMediaStream || new MediaStream();\n      event.streams[0].getTracks().forEach(function (track) {\n        _this.logger.info('adding ' + track.kind + ' track to remoteMediaStream');\n\n        if (stream && !stream.getTracks().includes(track)) {\n          stream.addTrack(track);\n        }\n\n        track.onended = function () {\n          _this.logger.info('remote ' + track.kind + ' has ended, removing track from remoteMediaStream');\n\n          stream.removeTrack(track);\n          track.onended = undefined;\n\n          try {\n            _this['receiving' + capitalize[track.kind]] = (0, _webrtcHelpers.getMediaDirectionFromTracks)(track.kind, _this.pc).includes('recv');\n          } catch (err) {\n            _this['receiving' + capitalize[track.kind]] = false;\n          }\n        };\n\n        _this['receiving' + capitalize[track.kind]] = (0, _webrtcHelpers.getMediaDirectionFromTracks)(track.kind, _this.pc).includes('recv');\n      });\n      _this.remoteMediaStream = stream;\n\n      _this.trigger('internalTrackUpdate');\n    };\n  }\n  /* eslint-disable complexity */\n\n  /**\n   * Determines if ice gathering is necessary and sends it up when appropriate\n   * @private\n   * @returns {Promise|undefined}\n   */\n\n\n  (0, _createClass3.default)(WebRTCMediaEngine, [{\n    key: '_prepareIceGatherer',\n    value: function _prepareIceGatherer() {\n      var _this2 = this;\n\n      var needsIce = false;\n\n      if (this.pc.iceGatheringState === 'new') {\n        this.logger.info('ice gathering is in state \"new\", definitely need to block for ice gathering');\n        needsIce = true;\n      } else {\n        var sdp = (0, _sdpTransform.parse)(this.pc.localDescription.sdp);\n        ['audio', 'video', 'screen'].forEach(function (kind) {\n          var directionKey = kind + 'Direction';\n\n          if (_this2[directionKey] !== 'inactive' || getTargetMediaDirection(_this2, kind) !== _this2[directionKey] && getTargetMediaDirection(_this2, kind) !== 'inactive') {\n            var media = sdp.media.find(function (m) {\n              return m.type === kind;\n            });\n\n            if (media) {\n              _this2.logger.info(kind + ' candidates already gathered');\n            } else {\n              _this2.logger.info('transitioning ' + kind + ' from inactive, ice needed');\n\n              needsIce = true;\n            }\n          }\n        });\n      }\n\n      var icePromise = void 0;\n\n      if (needsIce) {\n        icePromise = new _promise2.default(function (resolve) {\n          _this2.logger.info('configuring ice gathering');\n\n          _this2.pc.onicecandidate = function (event) {\n            if (!event.candidate) {\n              _this2.logger.info('ice gathering complete');\n\n              _this2.pc.onicecandidate = undefined;\n              resolve();\n              return;\n            }\n\n            _this2.logger.info('got ice candidate');\n          };\n        });\n      }\n\n      return icePromise;\n    }\n    /* eslint-enable complexity */\n\n    /**\n     * Creates an offer SDP\n     * @returns {Promise<string>}\n     */\n\n  }, {\n    key: 'createOffer',\n    value: function createOffer() {\n      var _this3 = this;\n\n      this.logger.info('beginning negotiation');\n      var td = getTargetMediaDirection(this, 'video');\n      var wantsVideo = td.includes('send') || td.includes('recv');\n\n      var icePromise = this._prepareIceGatherer();\n\n      return new _promise2.default(function (resolve) {\n        if (_this3.gumming) {\n          _this3.logger.info('gum in flight, waiting until it completes'); // Since gum is protected by @oneflight, returning it here will block\n          // until it completes but, more importantly, propagate a thrown\n          // exception up the stack\n\n\n          resolve(_this3._getUserMedia().then((0, _common.tap)(function () {\n            return _this3.logger.info('gum completed');\n          })));\n          return;\n        }\n\n        resolve();\n      }).then((0, _common.tap)(function () {\n        return _this3.logger.info('starting create offer', _this3.offerOptions);\n      })).then(function () {\n        _this3.offerOptions.offerToReceiveAudio = !!_this3.offerOptions.offerToReceiveAudio;\n        _this3.offerOptions.offerToReceiveVideo = !!_this3.offerOptions.offerToReceiveVideo;\n\n        _this3.logger.info('creating REAL offer', _this3.offerOptions);\n\n        _this3.logger.info('createOffer audioDirection: ' + _this3.audioDirection);\n\n        _this3.logger.info('createOffer videoDirection: ' + _this3.videoDirection);\n\n        _this3.logger.info('createOffer screenDirection: ' + _this3.screenDirection); // Ensure senders and receivers are in the correct state based on media direction\n\n\n        _this3.updateLocalMediaToTargetDirection();\n\n        return _this3.pc.createOffer(_this3.offerOptions);\n      }).then((0, _common.tap)(function (offer) {\n        offer.sdp = (0, _webrtcHelpers.limitBandwith)(_this3.bandwidthLimit, offer.sdp);\n        offer.sdp = (0, _webrtcHelpers.removeExtmap)(offer.sdp);\n      })).then((0, _common.tap)(function () {\n        return _this3.logger.info('setting local description');\n      })).then(function (offer) {\n        return _this3.pc.setLocalDescription(offer);\n      }).then((0, _common.tap)(function () {\n        return icePromise && _this3.logger.info('blocking for ice gathering');\n      })).then(function () {\n        return icePromise;\n      }).then((0, _common.tap)(function () {\n        return _this3.logger.info('limiting bandwith');\n      })).then(function () {\n        return (0, _webrtcHelpers.limitBandwith)(_this3.bandwidthLimit, _this3.pc.localDescription.sdp);\n      }).then((0, _common.tap)(function () {\n        return wantsVideo && _this3.logger.info('confirm h264 in offer');\n      })).then((0, _webrtcHelpers.ensureH264)(wantsVideo)).then(function (sdp) {\n        if (_this3.localScreenShare) {\n          // Add content descriptor to the local sdp\n          var streamId = _this3.localScreenShare.id;\n\n          var track = _this3.localScreenShare.getVideoTracks()[0];\n\n          if (track) {\n            var trackId = track.id;\n            var msid = streamId + ' ' + trackId;\n            var sections = sdp.split(msid);\n\n            if (sections[1]) {\n              sections[1] = '\\r\\na=content:slides' + sections[1];\n              sdp = sections.join(msid);\n              return sdp;\n            }\n          }\n\n          sdp += 'a=content:slides\\r\\n';\n        }\n\n        return sdp;\n      }).then((0, _common.tap)(function (sdp) {\n        _this3.offerSdp = sdp;\n      }));\n    }\n    /**\n     * Receives an answer SDP\n     * @param {string} sdp\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'acceptAnswer',\n    value: function acceptAnswer(sdp) {\n      var _this4 = this;\n\n      this.logger.info('accepting answer');\n      this.logger.debug('new answer sdp:', sdp); // Allow larger frames (this makes screenshare look *way* better, but no\n      // idea what impact it's having on the camera stream - we may want to limit\n      // it to just screen share at some future point)\n\n      var defaultCodecParams = /max-mbps=27600;max-fs=920/g;\n      var newCodecParams = 'max-mbps=27600;max-fs=8160';\n      var newSdp = sdp.replace(defaultCodecParams, newCodecParams); // If the screenshare goes inactive, make sure the sdp includes a direction\n      // config\n\n      newSdp = newSdp.replace(/m=video 0(.*?\\r\\n)/, 'm=video 0$1a=inactive\\r\\n'); // extmapFix\n\n      newSdp = (0, _webrtcHelpers.removeExtmap)(newSdp);\n      this.logger.debug('cleaned answer sdp:', newSdp); // Only accept answer if PeerConnection is in the correct state\n\n      if (this.pc.signalingState === 'have-local-offer') {\n        return this.pc.setRemoteDescription(new RTCSessionDescription({\n          sdp: newSdp,\n          type: 'answer'\n        })).then(function () {\n          _this4.logger.info('answer accepted');\n\n          _this4.answerSdp = newSdp;\n          _this4.sendingAudio = (0, _webrtcHelpers.getMediaDirectionFromTracks)('audio', _this4.pc).includes('send');\n          _this4.sendingVideo = (0, _webrtcHelpers.getMediaDirectionFromTracks)('video', _this4.pc).includes('send'); // Update media enabled flags in case we get extra media stream\n\n          _this4.updateLocalMediaToTargetDirection();\n\n          _this4.trigger('answeraccepted');\n\n          _this4.negotiationNeeded = false;\n        });\n      }\n\n      return _promise2.default.resolve();\n    }\n    /**\n     * {@link MediaStreamConstraints} that'll be used for the next call to\n     * {@link WebRTCMediaEngine.getUserMedia()}\n     * @private\n     * @type {MediaStreamConstraints}\n     */\n\n    /**\n     * {@link RTCOfferOptions} that'll be used for the next call to\n     * {@link RTCPeerConnection.createOffer}\n     * @private\n     * @type {RTCOfferOptions}\n     */\n\n    /**\n     * Indicates whether or not a call to {@link MediaDevices#getUserMedia()} is\n     * in flight\n     * @private\n     * @type {boolean}\n     */\n\n  }, {\n    key: '_setNewMediaDirection',\n\n    /**\n     * Change media direction without consumer provided tracks or complex\n     * constraints\n     * @param {string} kind\n     * @param {string} direction\n     * @private\n     * @returns {Promise}\n     */\n    value: function _setNewMediaDirection(kind, direction) {\n      var _this5 = this;\n\n      this.logger.info('setting ' + kind + ' direction to ' + direction);\n      var isSending = direction.includes('send');\n      this.constraints[kind] = isSending;\n\n      if (isSending) {\n        var senders = this.pc.getSenders().filter(function (s) {\n          return s.track && s.track.kind === kind;\n        });\n\n        if (senders.length > 0) {\n          this.logger.info('enabling existing ' + kind + ' sender track');\n          var localTracks = this.localMediaStream.getTracks().filter(function (t) {\n            return t.kind === kind;\n          });\n          senders.forEach(function (s) {\n            s.track.enabled = localTracks.includes(s.track);\n          });\n          this['sending' + capitalize[kind]] = isSending;\n          return _promise2.default.resolve();\n        }\n\n        if (!this[kind + 'Direction'].includes('send')) {\n          // only set new constraints if we were not already sending media\n          return this._setNewMediaConstraint(kind, isSending);\n        }\n      } else {\n        this.logger.info('muting ' + kind + ' local tracks');\n\n        if (!this.localMediaStream) {\n          return _promise2.default.resolve();\n        }\n\n        return this.localMediaStream.getTracks().filter(function (t) {\n          return t.kind === kind;\n        }).forEach(function (track) {\n          // We remove the track from localMediaStream, and disable on PeerConnection\n          _this5.logger.info('muting existing ' + kind + ' track from localMediaStream');\n\n          var sender = _this5.pc.getSenders().find(function (s) {\n            return s.track === track;\n          });\n\n          if (!_bowser2.default.firefox) {\n            _this5.localMediaStream.removeTrack(track);\n          }\n\n          if (sender) {\n            _this5.logger.info('muting existing ' + kind + ' track on sender');\n\n            sender.track.enabled = false;\n            track.enabled = false; // We must remove sender track from PC when muting\n            // browsers will still create SDP media field if we don't remote the track\n\n            if (!_bowser2.default.firefox) {\n              _this5.pc.removeTrack(sender);\n            }\n          }\n\n          _this5.logger.info('setting sending' + capitalize[kind] + ' to ' + isSending);\n\n          _this5['sending' + capitalize[kind]] = isSending;\n        });\n      }\n\n      return _promise2.default.resolve();\n    }\n    /**\n     * Sets or replaces current track for $kind\n     * @param {string} kind\n     * @param {MediaStreamTrack} track\n     * @returns {Promise}\n     */\n\n  }, {\n    key: '_setNewMediaTrack',\n    value: function _setNewMediaTrack(kind, track) {\n      this.logger.info('setting new ' + kind + ' track');\n      this.constraints[kind] = false;\n      return this.addOrReplaceTrack(track);\n    }\n    /**\n     * Causes track for ${kind} to be set or replaced according to $constraint\n     * @param {string} kind\n     * @param {Object|boolean} constraint\n     * @returns {Promise}\n     */\n\n  }, {\n    key: '_setNewMediaConstraint',\n    value: function _setNewMediaConstraint(kind, constraint) {\n      this.logger.info('setting ' + kind + ' with new constraint');\n      this.constraints[kind] = constraint;\n      return this._getUserMedia();\n    }\n    /**\n     * Starts or stops an outbound screenshare\n     *\n     * @param {string} direction currently only inactive or sendonly\n     * @param {Object|MediaStreamTrack} trackOrConstraint\n     * @returns {Promise}\n     */\n\n  }, {\n    key: '_setScreenShare',\n    value: function _setScreenShare(direction, trackOrConstraint) {\n      var _this6 = this;\n\n      this.logger.info('calling _setScreenShare');\n      targetMediaDirection.set(this, 'screen', direction);\n\n      if (direction.includes('send')) {\n        var constraint = (0, _defaults3.default)({}, trackOrConstraint, {\n          mediaSource: 'application',\n          width: {\n            min: '160',\n            max: '1920'\n          },\n          height: {\n            min: '90',\n            max: '1080'\n          },\n          frameRate: {\n            min: '1',\n            max: '30'\n          }\n        });\n\n        this._setNewMediaConstraint('screen', constraint);\n\n        return;\n      }\n\n      this.logger.info('removing existing screenshare tracks from peer connection and localScreenShare stream');\n      this.pc.getSenders().filter(function (s) {\n        return s.track && _this6.localScreenShare.getTracks().includes(s.track);\n      }).forEach(function (s) {\n        _this6.logger.info('removing screenshare track ' + s.track.id + ' from peer connection and localScreenShare stream');\n\n        var senderTrack = s.track;\n        s.track.enabled = false;\n\n        _this6.localScreenShare.removeTrack(senderTrack);\n\n        _this6.pc.removeTrack(s);\n\n        senderTrack.stop();\n\n        _this6.logger.info('removed screenshare track ' + senderTrack.id + ' from peer connection and localScreenShare stream');\n      }); // Remove reference to screen share media stream to trigger change event\n\n      this.localScreenShare = false;\n    } // I don't see any further ways to reduce complexity without hurting\n    // readability\n\n    /* eslint-disable complexity */\n\n    /**\n     * Sets a media direction for a given media type. Almost certainly triggers\n     * renegotiation. This is the method to use if you want to replace a track.\n     * @param {string} kind audio|video\n     * @param {string} direction sendonly|recvonly|sendrecv|inactive\n     * @param {MediaStreamTrack|Object} trackOrConstraint\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'setMedia',\n    value: function setMedia(kind, direction, trackOrConstraint) {\n      var _this7 = this;\n\n      this.logger.info('setMedia');\n\n      if (kind === 'screen') {\n        this.logger.info('setMedia: setting new screen direction');\n\n        this._setScreenShare(direction, trackOrConstraint);\n\n        return _promise2.default.resolve();\n      }\n\n      return new _promise2.default(function (resolve) {\n        if (trackOrConstraint) {\n          if (!direction.includes('send')) {\n            throw new Error('Cannot set new ' + kind + ' track or constraint if direction does not include send');\n          }\n\n          if (trackOrConstraint instanceof MediaStreamTrack) {\n            if (trackOrConstraint.kind !== kind) {\n              throw new Error('track is not a valid ' + kind + ' media stream track');\n            }\n\n            resolve(_this7._setNewMediaTrack(kind, trackOrConstraint));\n          } else {\n            resolve(_this7._setNewMediaConstraint(kind, trackOrConstraint));\n          }\n        } else {\n          if (direction === getTargetMediaDirection(_this7, kind)) {\n            _this7.logger.info('setMedia: ' + kind + ' already transitioning to ' + direction + ', not making changes');\n\n            resolve();\n          }\n\n          if (direction === _this7[kind + 'Direction']) {\n            _this7.logger.info('setMedia: ' + kind + ' already set to ' + direction + ', not making changes');\n\n            resolve();\n          }\n\n          resolve(_this7._setNewMediaDirection(kind, direction));\n        }\n      }).then(function () {\n        var shouldRecv = direction.includes('recv');\n\n        _this7.logger.info('setMedia: set targetMediaDirection for ' + kind + ' to ' + direction);\n\n        targetMediaDirection.set(_this7, kind, direction);\n\n        _this7.logger.info('setMedia: set offerToReceive' + (0, _webrtcHelpers.kindToPropertyFragment)(kind) + ' to ' + shouldRecv);\n\n        _this7.offerOptions['offerToReceive' + (0, _webrtcHelpers.kindToPropertyFragment)(kind)] = shouldRecv;\n\n        var receivers = _this7.pc.getReceivers().filter(function (r) {\n          return r.track && r.track.kind === kind;\n        });\n\n        if (shouldRecv) {\n          if (receivers.length > 0) {\n            _this7.logger.info('setMedia: unpause existing receiving ' + kind + ' track');\n\n            _this7.unpauseReceivingMedia(kind);\n          } else if (!receivers.length && _this7.answerSdp) {\n            _this7.logger.info('setMedia: no receiving ' + kind + ' track exists, trigger negotiation');\n\n            _this7.triggerNegotiationNeeded();\n          }\n        } else if (receivers.length > 0) {\n          _this7.logger.info('setMedia: pausing existing receiving ' + kind + ' track');\n\n          _this7.pauseReceivingMedia(kind);\n        }\n      });\n    }\n    /* eslint-enable complexity */\n\n    /**\n     * Wrapper around {@link MediaDevices#getUserMedia()} that delays the call one\n     * tick to reduce the number of permissions dialogs presented to the user.\n     * @name _getUserMedia\n     * @returns {Promise<MediaStream>}\n     */\n\n  }, {\n    key: '_getUserMedia',\n    value: function _getUserMedia() {\n      var _this8 = this;\n\n      this.logger.info('enqueing request to get user media');\n      return new _promise2.default(function (resolve) {\n        return process.nextTick(resolve);\n      }).then(function () {\n        if (_this8.constraints.audio === true && _this8.pc.getSenders().find(function (s) {\n          return s.track && s.track.kind === 'audio';\n        })) {\n          _this8.logger.info('already have a local audio track, removing constraint for a second one');\n\n          (0, _deleteProperty2.default)(_this8.constraints, 'audio');\n        }\n\n        if (_this8.constraints.video === true && _this8.pc.getSenders().find(function (s) {\n          return s.track && s.track.kind === 'video';\n        })) {\n          _this8.logger.info('already have a local video track, removing constraint for a second one');\n\n          (0, _deleteProperty2.default)(_this8.constraints, 'video');\n        }\n\n        var _constraints = _this8.constraints,\n            audio = _constraints.audio,\n            video = _constraints.video,\n            screen = _constraints.screen;\n\n        _this8.logger.info('getting user media with ' + (audio ? '1' : '0') + ' audio track, ' + (video ? '1' : '0') + ' video track, and ' + (screen ? '1' : '0') + ' screenshare track.');\n\n        return _promise2.default.all([(audio || video) && WebRTCMediaEngine.getUserMedia({\n          audio: audio,\n          video: video\n        }), screen && WebRTCMediaEngine.getUserMedia({\n          video: screen\n        })]);\n      }).then(function (_ref) {\n        var _ref2 = (0, _slicedToArray3.default)(_ref, 2),\n            userStream = _ref2[0],\n            screenStream = _ref2[1];\n\n        var p = [];\n\n        if (userStream) {\n          _this8.logger.info('got local media stream with ' + userStream.getAudioTracks().length + ' audio tracks and ' + userStream.getVideoTracks().length + ' video tracks');\n\n          userStream.getTracks().forEach(function (t) {\n            return p.push(_this8.addOrReplaceTrack(t));\n          });\n        }\n\n        if (screenStream) {\n          if (_this8.localScreenShare) {\n            var sender = _this8.pc.getSenders().find(function (s) {\n              return _this8.localScreenShare.getTracks().includes(s.track);\n            });\n\n            if (sender) {\n              _this8.logger.info('removing existing screenshare track from localScreenShare stream');\n\n              _this8.localScreenShare.removeTrack(sender.track);\n\n              _this8.logger.info('disabling existing screenshare track on sender');\n\n              sender.track.enabled = false;\n            } // We hope there's only a single track from the screenshare\n\n\n            screenStream.getTracks().forEach(function (t) {\n              if (sender) {\n                // if a sender already exists and we need to update with a new track, replace the track\n                _this8.logger.info('replacing existing screenshare track on sender');\n\n                p.push(sender.replaceTrack(t));\n              } else {\n                // If we've never sent, we should\n                _this8.logger.info('adding new screen track to peerConnection');\n\n                _this8.pc.addTrack(t, screenStream);\n              }\n            });\n          } else {\n            _this8.logger.info('adding localScreenShare for the first time');\n\n            _this8.logger.info('adding new screenshare track to peer connection');\n\n            screenStream.getVideoTracks().forEach(function (t) {\n              return _this8.pc.addTrack(t, screenStream);\n            });\n          }\n\n          _this8.localScreenShare = screenStream;\n        }\n\n        _this8.constraints = {};\n        return _promise2.default.all(p);\n      }).catch(function (err) {\n        _this8.trigger('error', err);\n\n        return _promise2.default.reject(err);\n      });\n    }\n    /**\n     * adds or replaces a local @{link MediaStreamTrack}\n     * @private\n     * @param {MediaStreamTrack} track\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'addOrReplaceTrack',\n    value: function addOrReplaceTrack(track) {\n      var _this9 = this;\n\n      var p = [];\n\n      if (!this.localMediaStream) {\n        this.localMediaStream = new MediaStream();\n      }\n\n      var sender = this.pc.getSenders().find(function (s) {\n        return s.track && s.track.kind === track.kind;\n      });\n      var existingTrack = this.localMediaStream.getTracks().find(function (t) {\n        return t.kind === track.kind;\n      });\n\n      if (existingTrack !== track) {\n        if (existingTrack) {\n          this.logger.info('removing previous ' + existingTrack.kind + ' track from localMediaStream');\n          this.localMediaStream.removeTrack(existingTrack);\n        }\n\n        this.logger.info('adding new ' + track.kind + ' track to localMediaStream');\n        this.localMediaStream.addTrack(track);\n      }\n\n      if (sender) {\n        if (sender.track === track) {\n          this.logger.info('new track is the same as existing track, renabling ' + track.kind + ' track on sender');\n          sender.track.enabled = true;\n        } else {\n          this.logger.info('replacing new ' + track.kind + ' on existing sender');\n          p.push(sender.replaceTrack(track).then(function () {\n            _this9.logger.info('successfully replace ' + track.kind + ' on existing sender');\n          }).catch(function (e) {\n            // replaceTrack fails silently so we need to check if track was added correctly\n            _this9.logger.warn(e);\n\n            _this9.logger.warn('was not able to replace ' + track.kind + ' track on sender');\n\n            _this9.logger.info('adding as new ' + track.kind + ' track to peerConnection');\n\n            _this9.pc.removeTrack(sender);\n\n            _this9.pc.addTrack(track, _this9.localMediaStream);\n          }));\n        }\n      } else {\n        this.logger.info('adding new ' + track.kind + ' track to peerConnection');\n        this.pc.addTrack(track, this.localMediaStream);\n      }\n\n      this.logger.info('setting sending' + capitalize[track.kind] + ' to true');\n      this['sending' + capitalize[track.kind]] = true;\n      return _promise2.default.all(p);\n    }\n    /**\n     * Stops sending useful bits on the identified track, but does not end it (the\n     * camera/mic will stay on but the remote party(s) will not see/hear anything).\n     * Avoids renegotiation. Throws if `kind` does not identify a track.\n     * @param {string} kind\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'pauseSendingMedia',\n    value: function pauseSendingMedia(kind) {\n      var _this10 = this;\n\n      if (!kind) {\n        throw new Error('kind is required');\n      }\n\n      var senders = this.pc.getSenders().filter(function (s) {\n        return s.track && s.track.kind === kind;\n      });\n\n      if (senders.length === 0) {\n        throw new Error('No ' + kind + ' media senders to pause');\n      }\n\n      senders.forEach(function (s) {\n        _this10.logger.info('pausing ' + kind + ' sender');\n\n        s.track.enabled = false;\n      });\n      this.logger.info('setting sending' + capitalize[kind] + ' to false');\n      this['sending' + capitalize[kind]] = false;\n    }\n    /**\n     * Compares target directions with senders and receivers and updates PC to match\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'updateLocalMediaToTargetDirection',\n    value: function updateLocalMediaToTargetDirection() {\n      var _this11 = this;\n\n      ['audio', 'video'].forEach(function (kind) {\n        // Get direction value set when updating senders and receivers\n        var targetDirection = getTargetMediaDirection(_this11, kind); // Get direction from peer connection\n\n        var direction = _this11[kind + 'Direction']; // If directions don't match, update peer connection to match target\n\n        if (direction !== targetDirection) {\n          var shouldSend = targetDirection.includes('send');\n\n          if (direction.includes('send') !== shouldSend) {\n            // Update pc senders to correct target direction\n            _this11.pc.getSenders().forEach(function (s) {\n              if (s.track && s.track.kind === kind) {\n                s.track.enabled = shouldSend;\n              }\n            });\n          }\n\n          var shouldRecv = targetDirection.includes('recv');\n\n          if (direction.includes('send') !== shouldRecv) {\n            // Update pc receivers to correct target direction\n            _this11.pc.getReceivers().forEach(function (r) {\n              if (r.track && r.track.kind === kind) {\n                r.track.enabled = shouldRecv;\n              }\n            });\n          }\n        }\n      });\n    }\n    /**\n     * Resumes sending bits on the identified track. Throws if `kind` does not\n     * identify a track.\n     * @param {string} kind\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'unpauseSendingMedia',\n    value: function unpauseSendingMedia(kind) {\n      var _this12 = this;\n\n      if (!kind) {\n        throw new Error('kind is required');\n      }\n\n      var senders = this.pc.getSenders().filter(function (s) {\n        return s.track && s.track.kind === kind;\n      });\n\n      if (senders.length === 0) {\n        throw new Error('No ' + kind + ' media senders to unpause');\n      }\n\n      senders.forEach(function (s) {\n        _this12.logger.info('unpausing ' + kind + ' sender');\n\n        s.track.enabled = true;\n      });\n      this.logger.info('setting sending' + capitalize[kind] + ' to true');\n      this['sending' + capitalize[kind]] = true;\n    }\n    /**\n     * Convenience function. Sets a remote track.enabled=false. Does not\n     * renegotiate.Throws if `kind` does not identify a track.\n     * @param {string} kind\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'pauseReceivingMedia',\n    value: function pauseReceivingMedia(kind) {\n      var _this13 = this;\n\n      if (!kind) {\n        throw new Error('kind is required');\n      }\n\n      var receivers = this.pc.getReceivers().filter(function (r) {\n        return r.track && r.track.kind === kind;\n      });\n\n      if (receivers.length === 0) {\n        throw new Error('No ' + kind + ' receiver media tracks to pause');\n      }\n\n      receivers.forEach(function (r) {\n        _this13.logger.info('pausing remote ' + kind + ' track');\n\n        r.track.enabled = false;\n      });\n      this.logger.info('setting receiving' + capitalize[kind] + ' to false');\n      this['receiving' + capitalize[kind]] = false;\n    }\n    /**\n     * Convenience function. Sets a remote track.enabled=true. Does not\n     * renegotiate.Throws if `kind` does not identify a track.\n     * @param {string} kind\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'unpauseReceivingMedia',\n    value: function unpauseReceivingMedia(kind) {\n      var _this14 = this;\n\n      if (!kind) {\n        throw new Error('kind is required');\n      }\n\n      var receivers = this.pc.getReceivers().filter(function (r) {\n        return r.track && r.track.kind === kind;\n      });\n\n      if (receivers.length === 0) {\n        throw new Error('No ' + kind + ' receiver media tracks to pause');\n      }\n\n      receivers.forEach(function (r) {\n        _this14.logger.info('unpausing ' + kind + ' receiver track');\n\n        r.track.enabled = true;\n      });\n      this.logger.info('setting receiving' + capitalize[kind] + ' to true from ' + this['receiving' + capitalize[kind]]);\n      this['receiving' + capitalize[kind]] = true;\n    }\n    /**\n     * Stops all tracks and streams, closes the peer connection, and removes all\n     * listeners\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      if (this.pc.signalingState !== 'closed') {\n        this.pc.getSenders().forEach(function (s) {\n          return s.track && s.track.stop();\n        });\n        this.pc.close();\n      }\n\n      this.pc.onnegotiationneeded = undefined;\n      this.pc.ontrack = undefined;\n      this.pc.onicecandidate = undefined;\n      this.ended = true;\n      this.off();\n    }\n  }, {\n    key: 'triggerNegotiationNeeded',\n\n    /**\n     * Debounced helper for triggering `negotiationneeded`.\n     * @private\n     * @returns {undefined}\n     */\n    // It's not missing, but the decorator is throwing off eslint\n    // eslint-disable-next-line require-jsdoc\n    value: function triggerNegotiationNeeded() {\n      this.trigger('negotiationneeded');\n    }\n    /**\n     * Returns a string when attempting to serialize object\n     * @returns {string}\n     */\n\n  }, {\n    key: 'serialize',\n    value: function serialize() {\n      return 'WebRTCMediaEngine';\n    }\n  }]);\n  return WebRTCMediaEngine;\n}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'localMediaStream', [_commonEvented2.default], {\n  enumerable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'remoteMediaStream', [_commonEvented2.default], {\n  enumerable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, 'localScreenShare', [_commonEvented2.default], {\n  enumerable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, 'offerSdp', [_commonEvented2.default], {\n  enumerable: true,\n  initializer: function initializer() {\n    return '';\n  }\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, 'answerSdp', [_commonEvented2.default], {\n  enumerable: true,\n  initializer: function initializer() {\n    return '';\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, 'sendingAudio', [_commonEvented2.default], {\n  enumerable: true,\n  initializer: function initializer() {\n    return false;\n  }\n}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, 'sendingVideo', [_commonEvented2.default], {\n  enumerable: true,\n  initializer: function initializer() {\n    return false;\n  }\n}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, 'receivingAudio', [_commonEvented2.default], {\n  enumerable: true,\n  initializer: function initializer() {\n    return false;\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, 'receivingVideo', [_commonEvented2.default], {\n  enumerable: true,\n  initializer: function initializer() {\n    return false;\n  }\n}), _descriptor10 = _applyDecoratedDescriptor(_class.prototype, 'ended', [_commonEvented2.default], {\n  enumerable: true,\n  initializer: function initializer() {\n    return false;\n  }\n}), _descriptor11 = _applyDecoratedDescriptor(_class.prototype, 'constraints', [_coreDecorators.nonenumerable], {\n  enumerable: true,\n  initializer: function initializer() {\n    return {};\n  }\n}), _descriptor12 = _applyDecoratedDescriptor(_class.prototype, 'offerOptions', [_coreDecorators.nonenumerable], {\n  enumerable: true,\n  initializer: function initializer() {\n    return {};\n  }\n}), _descriptor13 = _applyDecoratedDescriptor(_class.prototype, 'gumming', [_coreDecorators.nonenumerable, _commonEvented2.default], {\n  enumerable: true,\n  initializer: function initializer() {\n    return false;\n  }\n}), _applyDecoratedDescriptor(_class.prototype, '_getUserMedia', [_dec, _common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, '_getUserMedia'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'triggerNegotiationNeeded', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_class.prototype, 'triggerNegotiationNeeded'), _class.prototype)), _class));\nexports.default = WebRTCMediaEngine;\n(0, _assign2.default)(WebRTCMediaEngine.prototype, _ampersandEvents2.default);","map":null,"metadata":{},"sourceType":"script"}