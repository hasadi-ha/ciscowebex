{"ast":null,"code":"/*!\n * jwk/rsa.js - RSA Key Representation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar ecutil = require(\"../algorithms/ec-util.js\"),\n    forge = require(\"../deps/forge\"),\n    depsecc = require(\"../deps/ecc\");\n\nvar JWK = {\n  BaseKey: require(\"./basekey.js\"),\n  helpers: require(\"./helpers.js\")\n};\nvar SIG_ALGS = [\"ES256\", \"ES384\", \"ES512\"];\nvar WRAP_ALGS = [\"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A192KW\", \"ECDH-ES+A256KW\"];\nvar EC_OID = \"1.2.840.10045.2.1\";\n\nfunction oidToCurveName(oid) {\n  switch (oid) {\n    case \"1.2.840.10045.3.1.7\":\n      return \"P-256\";\n\n    case \"1.3.132.0.34\":\n      return \"P-384\";\n\n    case \"1.3.132.0.35\":\n      return \"P-521\";\n\n    default:\n      return null;\n  }\n}\n\nfunction curveNameToOid(crv) {\n  switch (crv) {\n    case \"P-256\":\n      return \"1.2.840.10045.3.1.7\";\n\n    case \"P-384\":\n      return \"1.3.132.0.34\";\n\n    case \"P-521\":\n      return \"1.3.132.0.35\";\n\n    default:\n      return null;\n  }\n}\n\nvar JWKEcCfg = {\n  publicKey: function (props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([{\n      name: \"crv\",\n      type: \"string\"\n    }, {\n      name: \"x\",\n      type: \"binary\"\n    }, {\n      name: \"y\",\n      type: \"binary\"\n    }]);\n    var pk = JWK.helpers.unpackProps(props, fields);\n\n    if (pk && pk.crv && pk.x && pk.y) {\n      pk.length = ecutil.curveSize(pk.crv);\n    } else {\n      delete pk.crv;\n      delete pk.x;\n      delete pk.y;\n    }\n\n    return pk;\n  },\n  privateKey: function (props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([{\n      name: \"crv\",\n      type: \"string\"\n    }, {\n      name: \"x\",\n      type: \"binary\"\n    }, {\n      name: \"y\",\n      type: \"binary\"\n    }, {\n      name: \"d\",\n      type: \"binary\"\n    }]);\n    var pk = JWK.helpers.unpackProps(props, fields);\n\n    if (pk && pk.crv && pk.x && pk.y && pk.d) {\n      pk.length = ecutil.curveSize(pk.crv);\n    } else {\n      pk = undefined;\n    }\n\n    return pk;\n  },\n  thumbprint: function (json) {\n    if (json.public) {\n      json = json.public;\n    }\n\n    var fields = {\n      crv: json.crv,\n      kty: \"EC\",\n      x: json.x,\n      y: json.y\n    };\n    return fields;\n  },\n  algorithms: function (keys, mode) {\n    var len = keys.public && keys.public.length || keys.private && keys.private.length || 0; // NOTE: 521 is the actual, but 512 is the expected\n\n    if (len === 521) {\n      len = 512;\n    }\n\n    switch (mode) {\n      case \"encrypt\":\n      case \"decrypt\":\n        return [];\n\n      case \"wrap\":\n        return keys.public && WRAP_ALGS || [];\n\n      case \"unwrap\":\n        return keys.private && WRAP_ALGS || [];\n\n      case \"sign\":\n        if (!keys.private) {\n          return [];\n        }\n\n        return SIG_ALGS.filter(function (a) {\n          return a === \"ES\" + len;\n        });\n\n      case \"verify\":\n        if (!keys.public) {\n          return [];\n        }\n\n        return SIG_ALGS.filter(function (a) {\n          return a === \"ES\" + len;\n        });\n    }\n  },\n  encryptKey: function (alg, keys) {\n    return keys.public;\n  },\n  decryptKey: function (alg, keys) {\n    return keys.private;\n  },\n  wrapKey: function (alg, keys) {\n    return keys.public;\n  },\n  unwrapKey: function (alg, keys) {\n    return keys.private;\n  },\n  signKey: function (alg, keys) {\n    return keys.private;\n  },\n  verifyKey: function (alg, keys) {\n    return keys.public;\n  },\n  convertToPEM: function (key, isPrivate) {\n    // curveName to OID\n    var oid = key.crv;\n    oid = curveNameToOid(oid);\n    oid = forge.asn1.oidToDer(oid); // key as bytes\n\n    var type, pub, asn1;\n\n    if (isPrivate) {\n      type = \"EC PRIVATE KEY\";\n      pub = Buffer.concat([new Buffer([0x00, 0x04]), key.x, key.y]).toString(\"binary\");\n      key = key.d.toString(\"binary\");\n      asn1 = forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.INTEGER, false, \"\\u0001\"), forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OCTETSTRING, false, key), forge.asn1.create(forge.asn1.Class.CONTEXT_SPECIFIC, 0, true, [forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, oid.bytes())]), forge.asn1.create(forge.asn1.Class.CONTEXT_SPECIFIC, 1, true, [forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.BITSTRING, false, pub)])]);\n    } else {\n      type = \"PUBLIC KEY\";\n      key = Buffer.concat([new Buffer([0x00, 0x04]), key.x, key.y]).toString(\"binary\");\n      asn1 = forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, forge.asn1.oidToDer(EC_OID).bytes()), forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, oid.bytes())]), forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.BITSTRING, false, key)]);\n    }\n\n    asn1 = forge.asn1.toDer(asn1).bytes();\n    var pem = forge.pem.encode({\n      type: type,\n      body: asn1\n    });\n    return pem;\n  }\n}; // Inspired by digitalbaazar/node-forge/js/rsa.js\n\nvar validators = {\n  oid: EC_OID,\n  privateKey: {\n    // ECPrivateKey\n    name: \"ECPrivateKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      // EC version\n      name: \"ECPrivateKey.version\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false\n    }, {\n      // private value (d)\n      name: \"ECPrivateKey.private\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: \"d\"\n    }, {\n      // EC parameters\n      tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n      name: \"ECPrivateKey.parameters\",\n      constructed: true,\n      value: [{\n        // namedCurve (crv)\n        name: \"ECPrivateKey.namedCurve\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.OID,\n        constructed: false,\n        capture: \"crv\"\n      }]\n    }, {\n      // publicKey\n      name: \"ECPrivateKey.publicKey\",\n      tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n      constructed: true,\n      value: [{\n        name: \"ECPrivateKey.point\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.BITSTRING,\n        constructed: false,\n        capture: \"point\"\n      }]\n    }]\n  },\n  embeddedPrivateKey: {\n    // ECPrivateKey\n    name: \"ECPrivateKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      // EC version\n      name: \"ECPrivateKey.version\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false\n    }, {\n      // private value (d)\n      name: \"ECPrivateKey.private\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: \"d\"\n    }, {\n      // publicKey\n      name: \"ECPrivateKey.publicKey\",\n      tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n      constructed: true,\n      value: [{\n        name: \"ECPrivateKey.point\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.BITSTRING,\n        constructed: false,\n        capture: \"point\"\n      }]\n    }]\n  }\n};\nvar JWKEcFactory = {\n  kty: \"EC\",\n  validators: validators,\n  prepare: function (props) {\n    // TODO: validate key properties\n    var cfg = JWKEcCfg;\n    var p = Promise.resolve(props);\n    p = p.then(function (json) {\n      return JWK.helpers.thumbprint(cfg, json);\n    });\n    p = p.then(function (hash) {\n      var prints = {};\n      prints[JWK.helpers.INTERNALS.THUMBPRINT_HASH] = hash;\n      props[JWK.helpers.INTERNALS.THUMBPRINT_KEY] = prints;\n      return cfg;\n    });\n    return p;\n  },\n  generate: function (size) {\n    var keypair = depsecc.generateKeyPair(size);\n    var result = {\n      \"crv\": size,\n      \"x\": keypair.public.x,\n      \"y\": keypair.public.y,\n      \"d\": keypair.private.d\n    };\n    return Promise.resolve(result);\n  },\n  import: function (input) {\n    if (validators.oid !== input.keyOid) {\n      return null;\n    } // coerce key params to OID\n\n\n    var crv;\n\n    if (input.keyParams && forge.asn1.Type.OID === input.keyParams.type) {\n      crv = forge.asn1.derToOid(input.keyParams.value);\n      crv = oidToCurveName(crv);\n    } else if (input.crv) {\n      crv = forge.asn1.derToOid(input.crv);\n      crv = oidToCurveName(crv);\n    }\n\n    if (!crv) {\n      return null;\n    }\n\n    if (!input.parsed) {\n      var capture = {},\n          errors = [];\n\n      if (\"private\" === input.type) {\n        // coerce capture.value to DER *iff* private\n        if (\"string\" === typeof input.keyValue) {\n          input.keyValue = forge.asn1.fromDer(input.keyValue);\n        } else if (Array.isArray(input.keyValue)) {\n          input.keyValue = input.keyValue[0];\n        }\n\n        if (!forge.asn1.validate(input.keyValue, validators.embeddedPrivateKey, capture, errors)) {\n          return null;\n        }\n      } else {\n        capture.point = input.keyValue;\n      }\n\n      input = capture;\n    } // convert factors to Buffers\n\n\n    var output = {\n      kty: \"EC\",\n      crv: crv\n    };\n\n    if (input.d) {\n      output.d = new Buffer(input.d, \"binary\");\n    }\n\n    if (input.point) {\n      var pt = new Buffer(input.point, \"binary\"); // only support uncompressed\n\n      if (4 !== pt.readUInt16BE(0)) {\n        return null;\n      }\n\n      pt = pt.slice(2);\n      var len = pt.length / 2;\n      output.x = pt.slice(0, len);\n      output.y = pt.slice(len);\n    }\n\n    return output;\n  }\n}; // public API\n\nmodule.exports = Object.freeze({\n  config: JWKEcCfg,\n  factory: JWKEcFactory\n}); // registration\n\n(function (REGISTRY) {\n  REGISTRY.register(JWKEcFactory);\n})(require(\"./keystore\").registry);","map":null,"metadata":{},"sourceType":"script"}