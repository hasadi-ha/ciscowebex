{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');\n\nvar _deleteProperty2 = _interopRequireDefault(_deleteProperty);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _omit2 = require('lodash/omit');\n\nvar _omit3 = _interopRequireDefault(_omit2);\n\nvar _isEmpty2 = require('lodash/isEmpty');\n\nvar _isEmpty3 = _interopRequireDefault(_isEmpty2);\n\nvar _cloneDeep2 = require('lodash/cloneDeep');\n\nvar _cloneDeep3 = _interopRequireDefault(_cloneDeep2);\n\nvar _dec, _dec2, _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint camelcase: [0] */\n\n\nvar _querystring = require('querystring');\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _common = require('@webex/common');\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _uuid = require('uuid');\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nvar OAUTH2_CSRF_TOKEN = 'oauth2-csrf-token';\n\nvar EMPTY_OBJECT_STRING = _common.base64.encode((0, _stringify2.default)({}));\n/**\n * Browser support for OAuth2. Automatically parses the URL hash for an access\n * token\n * @class\n * @name AuthorizationBrowser\n */\n\n\nvar Authorization = _webexCore.WebexPlugin.extend((_dec = (0, _common.whileInFlight)('isAuthorizing'), _dec2 = (0, _common.whileInFlight)('isAuthorizing'), (_obj = {\n  derived: {\n    /**\n     * Alias of {@link AuthorizationBrowser#isAuthorizing}\n     * @instance\n     * @memberof AuthorizationBrowser\n     * @type {boolean}\n     */\n    isAuthenticating: {\n      deps: ['isAuthorizing'],\n      fn: function fn() {\n        return this.isAuthorizing;\n      }\n    }\n  },\n  session: {\n    /**\n     * Indicates if an Authorization Code exchange is inflight\n     * @instance\n     * @memberof AuthorizationBrowser\n     * @type {boolean}\n     */\n    isAuthorizing: {\n      default: false,\n      type: 'boolean'\n    },\n    ready: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n  namespace: 'Credentials',\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} attrs {@link AmpersandState}\n   * @param {boolean} attrs.parse Controls whether or not the the url should get\n   * parsed for an access token\n   * @private\n   * @returns {Authorization}\n   */\n  // eslint-disable-next-line complexity\n  initialize: function initialize(attrs, options) {\n    var _this = this;\n\n    var ret = (0, _apply2.default)(_webexCore.WebexPlugin.prototype.initialize, this, [attrs, options]); // Reminder, we can't do parse based on config, because config is not\n    // available until nextTick and we want to be able to throw errors found in\n    // the url.\n\n    if (attrs.parse === false) {\n      this.ready = true;\n      return ret;\n    }\n\n    var location = _url2.default.parse(this.webex.getWindow().location.href, true);\n\n    this._checkForErrors(location);\n\n    var hash = location.hash;\n\n    if (!hash) {\n      this.ready = true;\n      return ret;\n    }\n\n    if (hash.includes('#')) {\n      hash = hash.substr(1);\n    }\n\n    location.hash = _querystring2.default.parse(hash);\n\n    if (location.hash.state) {\n      location.hash.state = JSON.parse(_common.base64.decode(location.hash.state));\n    }\n\n    var tokenData = this._parseHash(location);\n\n    if (!tokenData) {\n      return ret;\n    }\n\n    this._cleanUrl(location); // Wait until nextTick in case `credentials` hasn't initialized yet\n\n\n    process.nextTick(function () {\n      _this.webex.credentials.set({\n        supertoken: tokenData\n      });\n\n      _this.ready = true;\n    });\n    return ret;\n  },\n\n  /**\n   * Kicks off an oauth flow\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateLogin: function initiateLogin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.state = options.state || {};\n    options.state.csrf_token = this._generateSecurityToken(); // If we're not explicitly a confidential client, assume we're a public\n    // client\n\n    if (this.config.clientType === 'confidential') {\n      return this.initiateAuthorizationCodeGrant(options);\n    }\n\n    return this.initiateImplicitGrant(options);\n  },\n\n  /**\n   * Kicks off the Authorization Code grant flow. Typically called via\n   * {@link AuthorizationBrowser#initiateLogin}\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateImplicitGrant: function initiateImplicitGrant(options) {\n    this.logger.info('authorization: initiating implicit grant flow');\n    this.webex.getWindow().location = this.webex.credentials.buildLoginUrl((0, _assign2.default)({\n      response_type: 'token'\n    }, options));\n    return _promise2.default.resolve();\n  },\n\n  /**\n   * Kicks off the Implicit Code grant flow. Typically called via\n   * {@link AuthorizationBrowser#initiateLogin}\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateAuthorizationCodeGrant: function initiateAuthorizationCodeGrant(options) {\n    this.logger.info('authorization: initiating authorization code grant flow');\n    this.webex.getWindow().location = this.webex.credentials.buildLoginUrl((0, _assign2.default)({\n      response_type: 'code'\n    }, options));\n    return _promise2.default.resolve();\n  },\n\n  /**\n   * Requests a Webex Teams access token for a user already authenticated into\n   * your product.\n   *\n   * Note: You'll need to supply a jwtRefreshCallback of the form\n   * `Promise<jwt> = jwtRefreshCallback(webex)` for automatic token refresh to\n   * work.\n   *\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @param {Object} options.jwt This is a jwt generated by your backend that\n   * identifies a user in your system\n   * @returns {Promise}\n   */\n  requestAccessTokenFromJwt: function requestAccessTokenFromJwt(_ref) {\n    var _this2 = this;\n\n    var jwt = _ref.jwt;\n    return this.webex.request({\n      method: 'POST',\n      service: 'hydra',\n      resource: 'jwt/login',\n      headers: {\n        authorization: jwt\n      }\n    }).then(function (_ref2) {\n      var body = _ref2.body;\n      return {\n        access_token: body.token,\n        token_type: 'Bearer',\n        expires_in: body.expiresIn\n      };\n    }).then(function (token) {\n      _this2.webex.credentials.set({\n        supertoken: token\n      });\n    });\n  },\n\n  /**\n   * Called by {@link WebexCore#logout()}. Redirects to the logout page\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} options\n   * @param {boolean} options.noRedirect if true, does not redirect\n   * @returns {Promise}\n   */\n  logout: function logout() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!options.noRedirect) {\n      this.webex.getWindow().location = this.webex.credentials.buildLogoutUrl(options);\n    }\n  },\n\n  /**\n   * Checks if the result of the login redirect contains an error string\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Promise}\n   */\n  _checkForErrors: function _checkForErrors(location) {\n    var query = location.query;\n\n    if (query && query.error) {\n      var ErrorConstructor = _webexCore.grantErrors.select(query.error);\n\n      throw new ErrorConstructor(query);\n    }\n  },\n\n  /**\n   * Removes no-longer needed values from the url (access token, csrf token, etc)\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Promise}\n   */\n  _cleanUrl: function _cleanUrl(location) {\n    location = (0, _cloneDeep3.default)(location);\n\n    if (this.webex.getWindow().history && this.webex.getWindow().history.replaceState) {\n      ['access_token', 'token_type', 'expires_in', 'refresh_token', 'refresh_token_expires_in'].forEach(function (key) {\n        return (0, _deleteProperty2.default)(location.hash, key);\n      });\n\n      if (!(0, _isEmpty3.default)(location.hash.state)) {\n        location.hash.state = _common.base64.encode((0, _stringify2.default)((0, _omit3.default)(location.hash.state, 'csrf_token')));\n\n        if (location.hash.state === EMPTY_OBJECT_STRING) {\n          (0, _deleteProperty2.default)(location.hash, 'state');\n        }\n      } else {\n        (0, _deleteProperty2.default)(location.hash, 'state');\n      }\n\n      location.hash = _querystring2.default.stringify(location.hash);\n      this.webex.getWindow().history.replaceState({}, null, _url2.default.format(location));\n    }\n  },\n\n  /**\n   * Generates a CSRF token and sticks in in sessionStorage\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @private\n   * @returns {Promise}\n   */\n  _generateSecurityToken: function _generateSecurityToken() {\n    this.logger.info('authorization: generating csrf token');\n\n    var token = _uuid2.default.v4();\n\n    this.webex.getWindow().sessionStorage.setItem('oauth2-csrf-token', token);\n    return token;\n  },\n\n  /**\n   * Parses the url hash into an access token object\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} location\n   * @private\n   * @returns {Object}\n   */\n  _parseHash: function _parseHash(location) {\n    var hash = (0, _cloneDeep3.default)(location.hash);\n\n    if (hash) {\n      this._verifySecurityToken(hash);\n    }\n\n    if (!hash.access_token) {\n      this.ready = true;\n      return undefined;\n    }\n\n    if (hash.expires_in) {\n      hash.expires_in = parseInt(hash.expires_in, 10);\n    }\n\n    if (hash.refresh_token_expires_in) {\n      hash.refresh_token_expires_in = parseInt(hash.refresh_token_expires_in, 10);\n    }\n\n    return hash;\n  },\n\n  /**\n   * Checks if the CSRF token in sessionStorage is the same as the one returned\n   * in the url.\n   * @instance\n   * @memberof AuthorizationBrowser\n   * @param {Object} hash\n   * @private\n   * @returns {Promise}\n   */\n  _verifySecurityToken: function _verifySecurityToken(hash) {\n    var sessionToken = this.webex.getWindow().sessionStorage.getItem(OAUTH2_CSRF_TOKEN);\n    this.webex.getWindow().sessionStorage.removeItem(OAUTH2_CSRF_TOKEN);\n\n    if (!sessionToken) {\n      return;\n    }\n\n    if (!hash.state) {\n      throw new Error('Expected CSRF token ' + sessionToken + ', but not found in redirect hash');\n    }\n\n    if (!hash.state.csrf_token) {\n      throw new Error('Expected CSRF token ' + sessionToken + ', but not found in redirect hash');\n    }\n\n    var token = hash.state.csrf_token;\n\n    if (token !== sessionToken) {\n      throw new Error('CSRF token ' + token + ' does not match stored token ' + sessionToken);\n    }\n  },\n  version: '1.69.1'\n}, (_applyDecoratedDescriptor(_obj, 'initiateImplicitGrant', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initiateImplicitGrant'), _obj), _applyDecoratedDescriptor(_obj, 'initiateAuthorizationCodeGrant', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initiateAuthorizationCodeGrant'), _obj), _applyDecoratedDescriptor(_obj, 'requestAccessTokenFromJwt', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'requestAccessTokenFromJwt'), _obj)), _obj)));\n\nexports.default = Authorization;","map":null,"metadata":{},"sourceType":"script"}