{"ast":null,"code":"/*!\n * algorithms/rsassa.js - RSA Signatures\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar forge = require(\"../deps/forge.js\"),\n    CONSTANTS = require(\"./constants\"),\n    helpers = require(\"./helpers.js\"),\n    rsaUtil = require(\"./rsa-util.js\"); // ### RSASSA-PKCS1-v1_5\n\n\nfunction rsassaV15SignFn(name) {\n  var md = name.replace(\"RS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"RS\", \"SHA-\");\n  var alg = {\n    name: \"RSASSA-PKCS1-V1_5\",\n    hash: {\n      name: hash\n    }\n  }; // ### Fallback Implementation -- uses forge\n\n  var fallback = function (key, pdata) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata); // sign it\n\n    var pki = rsaUtil.convertToForge(key, false);\n    var sig = pki.sign(digest, \"RSASSA-PKCS1-V1_5\");\n    sig = new Buffer(sig, \"binary\");\n    return Promise.resolve({\n      data: pdata,\n      mac: sig\n    });\n  }; // ### WebCryptoAPI Implementation\n\n\n  var webcrypto = function (key, pdata) {\n    key = rsaUtil.convertToJWK(key, false);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"sign\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function (result) {\n      var sig = new Buffer(result);\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n    return promise;\n  };\n\n  var nodejs;\n\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(hash) > -1) {\n    nodejs = function (key, pdata) {\n      key = rsaUtil.convertToPem(key, false);\n      var sign = helpers.nodeCrypto.createSign(hash);\n      sign.update(pdata);\n      return {\n        data: pdata,\n        mac: sign.sign(rsaUtil.convertToPem(key, false))\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction rsassaV15VerifyFn(name) {\n  var md = name.replace(\"RS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"RS\", \"SHA-\");\n  var alg = {\n    name: \"RSASSA-PKCS1-V1_5\",\n    hash: {\n      name: hash\n    }\n  }; // ### Fallback implementation -- uses forge\n\n  var fallback = function (key, pdata, mac) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n    digest = digest.digest().bytes(); // verify it\n\n    var pki = rsaUtil.convertToForge(key, true);\n    var sig = mac.toString(\"binary\");\n    var result = pki.verify(digest, sig, \"RSASSA-PKCS1-V1_5\");\n\n    if (!result) {\n      return Promise.reject(new Error(\"verification failed\"));\n    }\n\n    return Promise.resolve({\n      data: pdata,\n      mac: mac,\n      valid: true\n    });\n  }; // ### WebCryptoAPI Implementation\n\n\n  var webcrypto = function (key, pdata, mac) {\n    key = rsaUtil.convertToJWK(key, true);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"verify\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function (result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  var nodejs;\n\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(md) > -1) {\n    nodejs = function (key, pdata, mac) {\n      var verify = helpers.nodeCrypto.createVerify(md);\n      verify.update(pdata);\n      verify.end();\n      var result = verify.verify(rsaUtil.convertToPem(key, true), mac);\n\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n} // ### RSA-PSS\n// NOTE: no WebCryptoAPI variant -- too many browsers don't\n// implement it yet (e.g., Firefox, Safari)\n\n\nfunction rsassaPssSignFn(name) {\n  var md = name.replace(\"PS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"PS\", \"SHA-\");\n  return function (key, pdata) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata); // setup padding\n\n    var pss = forge.pss.create({\n      md: forge.md[md].create(),\n      mgf: forge.mgf.mgf1.create(forge.md[md].create()),\n      saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n    }); // sign it\n\n    var pki = rsaUtil.convertToForge(key, false);\n    var sig = pki.sign(digest, pss);\n    sig = new Buffer(sig, \"binary\");\n    return Promise.resolve({\n      data: pdata,\n      mac: sig\n    });\n  };\n}\n\nfunction rsassaPssVerifyFn(name) {\n  var md = name.replace(\"PS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"PS\", \"SHA-\"); // ### Fallback implementation -- uses forge\n\n  return function (key, pdata, mac) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n    digest = digest.digest().bytes(); // setup padding\n\n    var pss = forge.pss.create({\n      md: forge.md[md].create(),\n      mgf: forge.mgf.mgf1.create(forge.md[md].create()),\n      saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n    }); // verify it\n\n    var pki = rsaUtil.convertToForge(key, true);\n    var sig = mac.toString(\"binary\");\n    var result = pki.verify(digest, sig, pss);\n\n    if (!result) {\n      return Promise.reject(new Error(\"verification failed\"));\n    }\n\n    return Promise.resolve({\n      data: pdata,\n      mac: mac,\n      valid: true\n    });\n  };\n} // ### Public API\n// * [name].sign\n// * [name].verify\n\n\nvar rsassa = {};\n[\"PS256\", \"PS384\", \"PS512\"].forEach(function (name) {\n  rsassa[name] = {\n    sign: rsassaPssSignFn(name),\n    verify: rsassaPssVerifyFn(name)\n  };\n});\n[\"RS256\", \"RS384\", \"RS512\"].forEach(function (name) {\n  rsassa[name] = {\n    sign: rsassaV15SignFn(name),\n    verify: rsassaV15VerifyFn(name)\n  };\n});\nmodule.exports = rsassa;","map":null,"metadata":{},"sourceType":"script"}