{"ast":null,"code":"'use strict';\n/*$AMPERSAND_VERSION*/\n\nvar uniqueId = require('lodash/uniqueId');\n\nvar assign = require('lodash/assign');\n\nvar cloneObj = function (obj) {\n  return assign({}, obj);\n};\n\nvar omit = require('lodash/omit');\n\nvar escape = require('lodash/escape');\n\nvar forOwn = require('lodash/forOwn');\n\nvar includes = require('lodash/includes');\n\nvar isString = require('lodash/isString');\n\nvar isObject = require('lodash/isObject');\n\nvar isDate = require('lodash/isDate');\n\nvar isFunction = require('lodash/isFunction');\n\nvar _isEqual = require('lodash/isEqual'); // to avoid shadowing\n\n\nvar has = require('lodash/has');\n\nvar result = require('lodash/result');\n\nvar union = require('lodash/union');\n\nvar Events = require('ampersand-events');\n\nvar KeyTree = require('key-tree-store');\n\nvar arrayNext = require('array-next');\n\nvar changeRE = /^change:/;\n\nvar noop = function () {};\n\nfunction Base(attrs, options) {\n  options || (options = {});\n  this.cid || (this.cid = uniqueId('state'));\n  this._events = {};\n  this._values = {};\n  this._eventBubblingHandlerCache = {};\n  this._definition = Object.create(this._definition);\n  if (options.parse) attrs = this.parse(attrs, options);\n  this.parent = options.parent;\n  this.collection = options.collection;\n  this._keyTree = new KeyTree();\n\n  this._initCollections();\n\n  this._initChildren();\n\n  this._cache = {};\n  this._previousAttributes = {};\n  if (attrs) this.set(attrs, assign({\n    silent: true,\n    initial: true\n  }, options));\n  this._changed = {};\n  if (this._derived) this._initDerived();\n  if (options.init !== false) this.initialize.apply(this, arguments);\n}\n\nassign(Base.prototype, Events, {\n  // can be allow, ignore, reject\n  extraProperties: 'ignore',\n  idAttribute: 'id',\n  namespaceAttribute: 'namespace',\n  typeAttribute: 'modelType',\n  // Stubbed out to be overwritten\n  initialize: function () {\n    return this;\n  },\n  // Get ID of model per configuration.\n  // Should *always* be how ID is determined by other code.\n  getId: function () {\n    return this[this.idAttribute];\n  },\n  // Get namespace of model per configuration.\n  // Should *always* be how namespace is determined by other code.\n  getNamespace: function () {\n    return this[this.namespaceAttribute];\n  },\n  // Get type of model per configuration.\n  // Should *always* be how type is determined by other code.\n  getType: function () {\n    return this[this.typeAttribute];\n  },\n  // A model is new if it has never been saved to the server, and lacks an id.\n  isNew: function () {\n    return this.getId() == null;\n  },\n  // get HTML-escaped value of attribute\n  escape: function (attr) {\n    return escape(this.get(attr));\n  },\n  // Check if the model is currently in a valid state.\n  isValid: function (options) {\n    return this._validate({}, assign(options || {}, {\n      validate: true\n    }));\n  },\n  // Parse can be used remap/restructure/rename incoming properties\n  // before they are applied to attributes.\n  parse: function (resp, options) {\n    //jshint unused:false\n    return resp;\n  },\n  // Serialize is the inverse of `parse` it lets you massage data\n  // on the way out. Before, sending to server, for example.\n  serialize: function (options) {\n    var attrOpts = assign({\n      props: true\n    }, options);\n    var res = this.getAttributes(attrOpts, true);\n\n    var setFromSerializedValue = function (value, key) {\n      res[key] = this[key].serialize();\n    }.bind(this);\n\n    forOwn(this._children, setFromSerializedValue);\n    forOwn(this._collections, setFromSerializedValue);\n    return res;\n  },\n  // Main set method used by generated setters/getters and can\n  // be used directly if you need to pass options or set multiple\n  // properties at once.\n  set: function (key, value, options) {\n    var self = this;\n    var extraProperties = this.extraProperties;\n    var wasChanging, changeEvents, newType, newVal, def, cast, err, attr, attrs, dataType, silent, unset, currentVal, initial, hasChanged, isEqual, onChange; // Handle both `\"key\", value` and `{key: value}` -style arguments.\n\n    if (isObject(key) || key === null) {\n      attrs = key;\n      options = value;\n    } else {\n      attrs = {};\n      attrs[key] = value;\n    }\n\n    options = options || {};\n    if (!this._validate(attrs, options)) return false; // Extract attributes and options.\n\n    unset = options.unset;\n    silent = options.silent;\n    initial = options.initial; // Initialize change tracking.\n\n    wasChanging = this._changing;\n    this._changing = true;\n    changeEvents = []; // if not already changing, store previous\n\n    if (initial) {\n      this._previousAttributes = {};\n    } else if (!wasChanging) {\n      this._previousAttributes = this.attributes;\n      this._changed = {};\n    } // For each `set` attribute...\n\n\n    for (var i = 0, keys = Object.keys(attrs), len = keys.length; i < len; i++) {\n      attr = keys[i];\n      newVal = attrs[attr];\n      newType = typeof newVal;\n      currentVal = this._values[attr];\n      def = this._definition[attr];\n\n      if (!def) {\n        // if this is a child model or collection\n        if (this._children[attr] || this._collections[attr]) {\n          if (!isObject(newVal)) {\n            newVal = {};\n          }\n\n          this[attr].set(newVal, options);\n          continue;\n        } else if (extraProperties === 'ignore') {\n          continue;\n        } else if (extraProperties === 'reject') {\n          throw new TypeError('No \"' + attr + '\" property defined on ' + (this.type || 'this') + ' model and extraProperties not set to \"ignore\" or \"allow\"');\n        } else if (extraProperties === 'allow') {\n          def = this._createPropertyDefinition(attr, 'any');\n        } else if (extraProperties) {\n          throw new TypeError('Invalid value for extraProperties: \"' + extraProperties + '\"');\n        }\n      }\n\n      isEqual = this._getCompareForType(def.type);\n      onChange = this._getOnChangeForType(def.type);\n      dataType = this._dataTypes[def.type]; // check type if we have one\n\n      if (dataType && dataType.set) {\n        cast = dataType.set(newVal);\n        newVal = cast.val;\n        newType = cast.type;\n      } // If we've defined a test, run it\n\n\n      if (def.test) {\n        err = def.test.call(this, newVal, newType);\n\n        if (err) {\n          throw new TypeError('Property \\'' + attr + '\\' failed validation with error: ' + err);\n        }\n      } // If we are required but undefined, throw error.\n      // If we are null and are not allowing null, throw error\n      // If we have a defined type and the new type doesn't match, and we are not null, throw error.\n      // If we require specific value and new one is not one of them, throw error (unless it has default value or we're unsetting it with undefined).\n\n\n      if (newVal === undefined && def.required) {\n        throw new TypeError('Required property \\'' + attr + '\\' must be of type ' + def.type + '. Tried to set ' + newVal);\n      }\n\n      if (newVal === null && def.required && !def.allowNull) {\n        throw new TypeError('Property \\'' + attr + '\\' must be of type ' + def.type + ' (cannot be null). Tried to set ' + newVal);\n      }\n\n      if (def.type && def.type !== 'any' && def.type !== newType && newVal !== null && newVal !== undefined) {\n        throw new TypeError('Property \\'' + attr + '\\' must be of type ' + def.type + '. Tried to set ' + newVal);\n      }\n\n      if (def.values && !includes(def.values, newVal)) {\n        var defaultValue = result(def, 'default');\n\n        if (unset && defaultValue !== undefined) {\n          newVal = defaultValue;\n        } else if (!unset || unset && newVal !== undefined) {\n          throw new TypeError('Property \\'' + attr + '\\' must be one of values: ' + def.values.join(', ') + '. Tried to set ' + newVal);\n        }\n      } // We know this has 'changed' if it's the initial set, so skip a potentially expensive isEqual check.\n\n\n      hasChanged = initial || !isEqual(currentVal, newVal, attr); // enforce `setOnce` for properties if set\n\n      if (def.setOnce && currentVal !== undefined && hasChanged) {\n        throw new TypeError('Property \\'' + attr + '\\' can only be set once.');\n      } // set/unset attributes.\n      // If this is not the initial set, keep track of changed attributes\n      // and push to changeEvents array so we can fire events.\n\n\n      if (hasChanged) {\n        // This fires no matter what, even on initial set.\n        onChange(newVal, currentVal, attr); // If this is a change (not an initial set), mark the change.\n        // Note it's impossible to unset on the initial set (it will already be unset),\n        // so we only include that logic here.\n\n        if (!initial) {\n          this._changed[attr] = newVal;\n          this._previousAttributes[attr] = currentVal;\n\n          if (unset) {\n            // FIXME delete is very slow. Can we get away with setting to undefined?\n            delete this._values[attr];\n          }\n\n          if (!silent) {\n            changeEvents.push({\n              prev: currentVal,\n              val: newVal,\n              key: attr\n            });\n          }\n        }\n\n        if (!unset) {\n          this._values[attr] = newVal;\n        }\n      } else {\n        // Not changed\n        // FIXME delete is very slow. Can we get away with setting to undefined?\n        delete this._changed[attr];\n      }\n    } // Fire events. This array is not populated if we are told to be silent.\n\n\n    if (changeEvents.length) this._pending = true;\n    changeEvents.forEach(function (change) {\n      self.trigger('change:' + change.key, self, change.val, options);\n    }); // You might be wondering why there's a `while` loop here. Changes can\n    // be recursively nested within `\"change\"` events.\n\n    if (wasChanging) return this;\n\n    while (this._pending) {\n      this._pending = false;\n      this.trigger('change', this, options);\n    }\n\n    this._pending = false;\n    this._changing = false;\n    return this;\n  },\n  get: function (attr) {\n    return this[attr];\n  },\n  // Toggle boolean properties or properties that have a `values`\n  // array in its definition.\n  toggle: function (property) {\n    var def = this._definition[property];\n\n    if (def.type === 'boolean') {\n      // if it's a bool, just flip it\n      this[property] = !this[property];\n    } else if (def && def.values) {\n      // If it's a property with an array of values\n      // skip to the next one looping back if at end.\n      this[property] = arrayNext(def.values, this[property]);\n    } else {\n      throw new TypeError('Can only toggle properties that are type `boolean` or have `values` array.');\n    }\n\n    return this;\n  },\n  // Get all of the attributes of the model at the time of the previous\n  // `\"change\"` event.\n  previousAttributes: function () {\n    return cloneObj(this._previousAttributes);\n  },\n  // Determine if the model has changed since the last `\"change\"` event.\n  // If you specify an attribute name, determine if that attribute has changed.\n  hasChanged: function (attr) {\n    if (attr == null) return !!Object.keys(this._changed).length;\n\n    if (has(this._derived, attr)) {\n      return this._derived[attr].depList.some(function (dep) {\n        return this.hasChanged(dep);\n      }, this);\n    }\n\n    return has(this._changed, attr);\n  },\n  // Return an object containing all the attributes that have changed, or\n  // false if there are no changed attributes. Useful for determining what\n  // parts of a view need to be updated and/or what attributes need to be\n  // persisted to the server. Unset attributes will be set to undefined.\n  // You can also pass an attributes object to diff against the model,\n  // determining if there *would be* a change.\n  changedAttributes: function (diff) {\n    if (!diff) return this.hasChanged() ? cloneObj(this._changed) : false;\n    var val,\n        changed = false;\n    var old = this._changing ? this._previousAttributes : this.attributes;\n    var def, isEqual;\n\n    for (var attr in diff) {\n      def = this._definition[attr];\n      if (!def) continue;\n      isEqual = this._getCompareForType(def.type);\n      if (isEqual(old[attr], val = diff[attr])) continue;\n      (changed || (changed = {}))[attr] = val;\n    }\n\n    return changed;\n  },\n  toJSON: function () {\n    return this.serialize();\n  },\n  unset: function (attrs, options) {\n    var self = this;\n    attrs = Array.isArray(attrs) ? attrs : [attrs];\n    attrs.forEach(function (key) {\n      var def = self._definition[key];\n      if (!def) return;\n      var val;\n\n      if (def.required) {\n        val = result(def, 'default');\n        return self.set(key, val, options);\n      } else {\n        return self.set(key, val, assign({}, options, {\n          unset: true\n        }));\n      }\n    });\n  },\n  clear: function (options) {\n    var self = this;\n    Object.keys(this.attributes).forEach(function (key) {\n      self.unset(key, options);\n    });\n    return this;\n  },\n  previous: function (attr) {\n    if (attr == null || !Object.keys(this._previousAttributes).length) return null;\n    return this._previousAttributes[attr];\n  },\n  // Get default values for a certain type\n  _getDefaultForType: function (type) {\n    var dataType = this._dataTypes[type];\n    return dataType && dataType['default'];\n  },\n  // Determine which comparison algorithm to use for comparing a property\n  _getCompareForType: function (type) {\n    var dataType = this._dataTypes[type];\n    if (dataType && dataType.compare) return dataType.compare.bind(this);\n    return _isEqual; // if no compare function is defined, use _.isEqual\n  },\n  _getOnChangeForType: function (type) {\n    var dataType = this._dataTypes[type];\n    if (dataType && dataType.onChange) return dataType.onChange.bind(this);\n    return noop;\n  },\n  // Run validation against the next complete set of model attributes,\n  // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n  _validate: function (attrs, options) {\n    if (!options.validate || !this.validate) return true;\n    attrs = assign({}, this.attributes, attrs);\n    var error = this.validationError = this.validate(attrs, options) || null;\n    if (!error) return true;\n    this.trigger('invalid', this, error, assign(options || {}, {\n      validationError: error\n    }));\n    return false;\n  },\n  _createPropertyDefinition: function (name, desc, isSession) {\n    return createPropertyDefinition(this, name, desc, isSession);\n  },\n  // just makes friendlier errors when trying to define a new model\n  // only used when setting up original property definitions\n  _ensureValidType: function (type) {\n    return includes(['string', 'number', 'boolean', 'array', 'object', 'date', 'state', 'any'].concat(Object.keys(this._dataTypes)), type) ? type : undefined;\n  },\n  getAttributes: function (options, raw) {\n    options = assign({\n      session: false,\n      props: false,\n      derived: false\n    }, options || {});\n    var res = {};\n    var val, def;\n\n    for (var item in this._definition) {\n      def = this._definition[item];\n\n      if (options.session && def.session || options.props && !def.session) {\n        val = raw ? this._values[item] : this[item];\n        if (raw && val && isFunction(val.serialize)) val = val.serialize();\n        if (typeof val === 'undefined') val = result(def, 'default');\n        if (typeof val !== 'undefined') res[item] = val;\n      }\n    }\n\n    if (options.derived) {\n      for (var derivedItem in this._derived) res[derivedItem] = this[derivedItem];\n    }\n\n    return res;\n  },\n  _initDerived: function () {\n    var self = this;\n    forOwn(this._derived, function (value, name) {\n      var def = self._derived[name];\n      def.deps = def.depList;\n\n      var update = function () {\n        var newVal = def.fn.call(self);\n\n        if (self._cache[name] !== newVal || !def.cache) {\n          if (def.cache) {\n            self._previousAttributes[name] = self._cache[name];\n          }\n\n          self._cache[name] = newVal;\n          self.trigger('change:' + name, self, self._cache[name]);\n        }\n      };\n\n      def.deps.forEach(function (propString) {\n        self._keyTree.add(propString, update);\n      });\n    });\n    this.on('all', function (eventName) {\n      if (changeRE.test(eventName)) {\n        self._keyTree.get(eventName.split(':')[1]).forEach(function (fn) {\n          fn();\n        });\n      }\n    }, this);\n  },\n  _getDerivedProperty: function (name, flushCache) {\n    // is this a derived property that is cached\n    if (this._derived[name].cache) {\n      //set if this is the first time, or flushCache is set\n      if (flushCache || !this._cache.hasOwnProperty(name)) {\n        this._cache[name] = this._derived[name].fn.apply(this);\n      }\n\n      return this._cache[name];\n    } else {\n      return this._derived[name].fn.apply(this);\n    }\n  },\n  _initCollections: function () {\n    var coll;\n    if (!this._collections) return;\n\n    for (coll in this._collections) {\n      this._safeSet(coll, new this._collections[coll](null, {\n        parent: this\n      }));\n    }\n  },\n  _initChildren: function () {\n    var child;\n    if (!this._children) return;\n\n    for (child in this._children) {\n      this._safeSet(child, new this._children[child]({}, {\n        parent: this\n      }));\n\n      this.listenTo(this[child], 'all', this._getCachedEventBubblingHandler(child));\n    }\n  },\n  // Returns a bound handler for doing event bubbling while\n  // adding a name to the change string.\n  _getCachedEventBubblingHandler: function (propertyName) {\n    if (!this._eventBubblingHandlerCache[propertyName]) {\n      this._eventBubblingHandlerCache[propertyName] = function (name, model, newValue) {\n        if (changeRE.test(name)) {\n          this.trigger('change:' + propertyName + '.' + name.split(':')[1], model, newValue);\n        } else if (name === 'change') {\n          this.trigger('change', this);\n        }\n      }.bind(this);\n    }\n\n    return this._eventBubblingHandlerCache[propertyName];\n  },\n  // Check that all required attributes are present\n  _verifyRequired: function () {\n    var attrs = this.attributes; // should include session\n\n    for (var def in this._definition) {\n      if (this._definition[def].required && typeof attrs[def] === 'undefined') {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  // expose safeSet method\n  _safeSet: function safeSet(property, value) {\n    if (property in this) {\n      throw new Error('Encountered namespace collision while setting instance property `' + property + '`');\n    }\n\n    this[property] = value;\n    return this;\n  }\n}); // getter for attributes\n\nObject.defineProperties(Base.prototype, {\n  attributes: {\n    get: function () {\n      return this.getAttributes({\n        props: true,\n        session: true\n      });\n    }\n  },\n  all: {\n    get: function () {\n      return this.getAttributes({\n        session: true,\n        props: true,\n        derived: true\n      });\n    }\n  },\n  isState: {\n    get: function () {\n      return true;\n    },\n    set: function () {}\n  }\n}); // helper for creating/storing property definitions and creating\n// appropriate getters/setters\n\nfunction createPropertyDefinition(object, name, desc, isSession) {\n  var def = object._definition[name] = {};\n  var type, descArray;\n\n  if (isString(desc)) {\n    // grab our type if all we've got is a string\n    type = object._ensureValidType(desc);\n    if (type) def.type = type;\n  } else {\n    //Transform array of ['type', required, default] to object form\n    if (Array.isArray(desc)) {\n      descArray = desc;\n      desc = {\n        type: descArray[0],\n        required: descArray[1],\n        'default': descArray[2]\n      };\n    }\n\n    type = object._ensureValidType(desc.type);\n    if (type) def.type = type;\n    if (desc.required) def.required = true;\n\n    if (desc['default'] && typeof desc['default'] === 'object') {\n      throw new TypeError('The default value for ' + name + ' cannot be an object/array, must be a value or a function which returns a value/object/array');\n    }\n\n    def['default'] = desc['default'];\n    def.allowNull = desc.allowNull ? desc.allowNull : false;\n    if (desc.setOnce) def.setOnce = true;\n    if (def.required && def['default'] === undefined && !def.setOnce) def['default'] = object._getDefaultForType(type);\n    def.test = desc.test;\n    def.values = desc.values;\n  }\n\n  if (isSession) def.session = true;\n\n  if (!type) {\n    type = isString(desc) ? desc : desc.type; // TODO: start throwing a TypeError in future major versions instead of warning\n\n    console.warn('Invalid data type of `' + type + '` for `' + name + '` property. Use one of the default types or define your own');\n  } // define a getter/setter on the prototype\n  // but they get/set on the instance\n\n\n  Object.defineProperty(object, name, {\n    set: function (val) {\n      this.set(name, val);\n    },\n    get: function () {\n      if (!this._values) {\n        throw Error('You may be trying to `extend` a state object with \"' + name + '\" which has been defined in `props` on the object being extended');\n      }\n\n      var value = this._values[name];\n      var typeDef = this._dataTypes[def.type];\n\n      if (typeof value !== 'undefined') {\n        if (typeDef && typeDef.get) {\n          value = typeDef.get(value);\n        }\n\n        return value;\n      }\n\n      var defaultValue = result(def, 'default');\n      this._values[name] = defaultValue; // If we've set a defaultValue, fire a change handler effectively marking\n      // its change from undefined to the default value.\n\n      if (typeof defaultValue !== 'undefined') {\n        var onChange = this._getOnChangeForType(def.type);\n\n        onChange(defaultValue, value, name);\n      }\n\n      return defaultValue;\n    }\n  });\n  return def;\n} // helper for creating derived property definitions\n\n\nfunction createDerivedProperty(modelProto, name, definition) {\n  var def = modelProto._derived[name] = {\n    fn: isFunction(definition) ? definition : definition.fn,\n    cache: definition.cache !== false,\n    depList: definition.deps || []\n  }; // add to our shared dependency list\n\n  def.depList.forEach(function (dep) {\n    modelProto._deps[dep] = union(modelProto._deps[dep] || [], [name]);\n  }); // defined a top-level getter for derived names\n\n  Object.defineProperty(modelProto, name, {\n    get: function () {\n      return this._getDerivedProperty(name);\n    },\n    set: function () {\n      throw new TypeError(\"`\" + name + \"` is a derived property, it can't be set directly.\");\n    }\n  });\n}\n\nvar dataTypes = {\n  string: {\n    'default': function () {\n      return '';\n    }\n  },\n  date: {\n    set: function (newVal) {\n      var newType;\n\n      if (newVal == null) {\n        newType = typeof null;\n      } else if (!isDate(newVal)) {\n        var err = null;\n        var dateVal = new Date(newVal).valueOf();\n\n        if (isNaN(dateVal)) {\n          // If the newVal cant be parsed, then try parseInt first\n          dateVal = new Date(parseInt(newVal, 10)).valueOf();\n          if (isNaN(dateVal)) err = true;\n        }\n\n        newVal = dateVal;\n        newType = 'date';\n\n        if (err) {\n          newType = typeof newVal;\n        }\n      } else {\n        newType = 'date';\n        newVal = newVal.valueOf();\n      }\n\n      return {\n        val: newVal,\n        type: newType\n      };\n    },\n    get: function (val) {\n      if (val == null) {\n        return val;\n      }\n\n      return new Date(val);\n    },\n    'default': function () {\n      return new Date();\n    }\n  },\n  array: {\n    set: function (newVal) {\n      return {\n        val: newVal,\n        type: Array.isArray(newVal) ? 'array' : typeof newVal\n      };\n    },\n    'default': function () {\n      return [];\n    }\n  },\n  object: {\n    set: function (newVal) {\n      var newType = typeof newVal; // we have to have a way of supporting \"missing\" objects.\n      // Null is an object, but setting a value to undefined\n      // should work too, IMO. We just override it, in that case.\n\n      if (newType !== 'object' && newVal === undefined) {\n        newVal = null;\n        newType = 'object';\n      }\n\n      return {\n        val: newVal,\n        type: newType\n      };\n    },\n    'default': function () {\n      return {};\n    }\n  },\n  // the `state` data type is a bit special in that setting it should\n  // also bubble events\n  state: {\n    set: function (newVal) {\n      var isInstance = newVal instanceof Base || newVal && newVal.isState;\n\n      if (isInstance) {\n        return {\n          val: newVal,\n          type: 'state'\n        };\n      } else {\n        return {\n          val: newVal,\n          type: typeof newVal\n        };\n      }\n    },\n    compare: function (currentVal, newVal) {\n      return currentVal === newVal;\n    },\n    onChange: function (newVal, previousVal, attributeName) {\n      // if this has changed we want to also handle\n      // event propagation\n      if (previousVal) {\n        this.stopListening(previousVal, 'all', this._getCachedEventBubblingHandler(attributeName));\n      }\n\n      if (newVal != null) {\n        this.listenTo(newVal, 'all', this._getCachedEventBubblingHandler(attributeName));\n      }\n    }\n  }\n}; // the extend method used to extend prototypes, maintain inheritance chains for instanceof\n// and allow for additions to the model definitions.\n\nfunction extend(protoProps) {\n  /*jshint validthis:true*/\n  var parent = this;\n  var child; // The constructor function for the new subclass is either defined by you\n  // (the \"constructor\" property in your `extend` definition), or defaulted\n  // by us to simply call the parent's constructor.\n\n  if (protoProps && protoProps.hasOwnProperty('constructor')) {\n    child = protoProps.constructor;\n  } else {\n    child = function () {\n      return parent.apply(this, arguments);\n    };\n  } // Add static properties to the constructor function from parent\n\n\n  assign(child, parent); // Set the prototype chain to inherit from `parent`, without calling\n  // `parent`'s constructor function.\n\n  var Surrogate = function () {\n    this.constructor = child;\n  };\n\n  Surrogate.prototype = parent.prototype;\n  child.prototype = new Surrogate(); // set prototype level objects\n\n  child.prototype._derived = assign({}, parent.prototype._derived);\n  child.prototype._deps = assign({}, parent.prototype._deps);\n  child.prototype._definition = assign({}, parent.prototype._definition);\n  child.prototype._collections = assign({}, parent.prototype._collections);\n  child.prototype._children = assign({}, parent.prototype._children);\n  child.prototype._dataTypes = assign({}, parent.prototype._dataTypes || dataTypes); // Mix in all prototype properties to the subclass if supplied.\n\n  if (protoProps) {\n    var omitFromExtend = ['dataTypes', 'props', 'session', 'derived', 'collections', 'children'];\n\n    for (var i = 0; i < arguments.length; i++) {\n      var def = arguments[i];\n\n      if (def.dataTypes) {\n        forOwn(def.dataTypes, function (def, name) {\n          child.prototype._dataTypes[name] = def;\n        });\n      }\n\n      if (def.props) {\n        forOwn(def.props, function (def, name) {\n          createPropertyDefinition(child.prototype, name, def);\n        });\n      }\n\n      if (def.session) {\n        forOwn(def.session, function (def, name) {\n          createPropertyDefinition(child.prototype, name, def, true);\n        });\n      }\n\n      if (def.derived) {\n        forOwn(def.derived, function (def, name) {\n          createDerivedProperty(child.prototype, name, def);\n        });\n      }\n\n      if (def.collections) {\n        forOwn(def.collections, function (constructor, name) {\n          child.prototype._collections[name] = constructor;\n        });\n      }\n\n      if (def.children) {\n        forOwn(def.children, function (constructor, name) {\n          child.prototype._children[name] = constructor;\n        });\n      }\n\n      assign(child.prototype, omit(def, omitFromExtend));\n    }\n  } // Set a convenience property in case the parent's prototype is needed\n  // later.\n\n\n  child.__super__ = parent.prototype;\n  return child;\n}\n\nBase.extend = extend; // Our main exports\n\nmodule.exports = Base;","map":null,"metadata":{},"sourceType":"script"}