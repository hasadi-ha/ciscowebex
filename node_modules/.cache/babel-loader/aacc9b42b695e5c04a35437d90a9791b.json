{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DryError = exports.KmsError = exports.KMS = exports.default = undefined;\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _isString2 = require('lodash/isString');\n\nvar _isString3 = _interopRequireDefault(_isString2);\n\nvar _isObject2 = require('lodash/isObject');\n\nvar _isObject3 = _interopRequireDefault(_isObject2);\n\nvar _has2 = require('lodash/has');\n\nvar _has3 = _interopRequireDefault(_has2);\n\nvar _encryption = require('./encryption');\n\nObject.defineProperty(exports, 'default', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_encryption).default;\n  }\n});\n\nvar _kms = require('./kms');\n\nObject.defineProperty(exports, 'KMS', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_kms).default;\n  }\n});\n\nvar _kmsErrors = require('./kms-errors');\n\nObject.defineProperty(exports, 'KmsError', {\n  enumerable: true,\n  get: function get() {\n    return _kmsErrors.KmsError;\n  }\n});\nObject.defineProperty(exports, 'DryError', {\n  enumerable: true,\n  get: function get() {\n    return _kmsErrors.DryError;\n  }\n});\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _encryption2 = _interopRequireDefault(_encryption);\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nrequire('@webex/internal-plugin-wdm');\n\nrequire('@webex/internal-plugin-mercury');\n\nvar _kmsDryErrorInterceptor = require('./kms-dry-error-interceptor');\n\nvar _kmsDryErrorInterceptor2 = _interopRequireDefault(_kmsDryErrorInterceptor);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar interceptors = void 0;\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n// Note: There's a bug where if bind gets replayed because of a timeout in which\n// the original request eventually completed, there'll be an error indicating\n// the key can't be bound (because it already has been). This could be mitigated\n// by using Promise.race to resolve replays (as more requests get enqueue for a\n// specific action, accept whichever one completes first).\n\nif (process.env.NODE_ENV === 'test') {\n  interceptors = {\n    KmsDryErrorInterceptor: _kmsDryErrorInterceptor2.default.create\n  };\n}\n\n(0, _webexCore.registerInternalPlugin)('encryption', _encryption2.default, {\n  payloadTransformer: {\n    predicates: [{\n      name: 'encryptKmsMessage',\n      direction: 'outbound',\n      // I don't see any practical way to reduce complexity here.\n      // eslint-disable-next-line complexity\n      test: function test(ctx, options) {\n        if (!(0, _has3.default)(options, 'body.kmsMessage')) {\n          return _promise2.default.resolve(false);\n        }\n\n        if (!(0, _isObject3.default)(options.body.kmsMessage)) {\n          return _promise2.default.resolve(false);\n        } // If this is a template for a kms message, assume another transform\n        // will fill it in later. This is a bit of a leaky abstraction, but the\n        // alternative is building a complex rules engine for controlling\n        // ordering of transforms\n\n\n        if (options.body.kmsMessage.keyUris && options.body.kmsMessage.keyUris.length === 0) {\n          return _promise2.default.resolve(false);\n        }\n\n        if (options.body.kmsMessage.resourceUri && (options.body.kmsMessage.resourceUri.includes('<KRO>') || options.body.kmsMessage.resourceUri.includes('<KEYURL>'))) {\n          return _promise2.default.resolve(false);\n        }\n\n        if (options.body.kmsMessage.uri && (options.body.kmsMessage.uri.includes('<KRO>') || options.body.kmsMessage.uri.includes('<KEYURL>'))) {\n          return _promise2.default.resolve(false);\n        }\n\n        return _promise2.default.resolve(true);\n      },\n      extract: function extract(options) {\n        return _promise2.default.resolve(options.body);\n      }\n    }, {\n      name: 'decryptKmsMessage',\n      direction: 'inbound',\n      test: function test(ctx, response) {\n        return _promise2.default.resolve((0, _has3.default)(response, 'body.kmsMessage') && (0, _isString3.default)(response.body.kmsMessage));\n      },\n      extract: function extract(response) {\n        return _promise2.default.resolve(response.body);\n      }\n    }, {\n      name: 'decryptErrorResponse',\n      direction: 'inbound',\n      test: function test(ctx, reason) {\n        return _promise2.default.resolve(Boolean(reason.body && reason.body.errorCode === 1900000));\n      },\n      extract: function extract(reason) {\n        return _promise2.default.resolve(reason);\n      }\n    }],\n    transforms: [{\n      name: 'encryptKmsMessage',\n      fn: function fn(ctx, object) {\n        if (!object) {\n          return _promise2.default.resolve();\n        }\n\n        if (!object.kmsMessage) {\n          return _promise2.default.resolve();\n        }\n\n        if ((0, _isString3.default)(object.kmsMessage)) {\n          return _promise2.default.resolve();\n        }\n\n        return ctx.spark.internal.encryption.kms.prepareRequest(object.kmsMessage).then(function (req) {\n          object.kmsMessage = req.wrapped;\n        });\n      }\n    }, {\n      name: 'decryptKmsMessage',\n      fn: function fn(ctx, object) {\n        return ctx.spark.internal.encryption.kms.decryptKmsMessage(object.kmsMessage).then(function (kmsMessage) {\n          object.kmsMessage = kmsMessage;\n        });\n      }\n    }, {\n      name: 'decryptErrorResponse',\n      fn: function fn(ctx, reason) {\n        var promises = reason.body.errors.map(function (error) {\n          return ctx.spark.internal.encryption.kms.decryptKmsMessage(error.description).then(function (desc) {\n            error.description = desc;\n          });\n        });\n        promises.push(ctx.spark.internal.encryption.kms.decryptKmsMessage(reason.body.message).then(function (kmsMessage) {\n          reason.body.message = kmsMessage;\n        }));\n        return _promise2.default.all(promises).then(function () {\n          return _promise2.default.reject(new _kmsErrors.DryError(reason));\n        });\n      }\n    }]\n  },\n  interceptors: interceptors,\n  config: _config2.default\n});","map":null,"metadata":{},"sourceType":"script"}