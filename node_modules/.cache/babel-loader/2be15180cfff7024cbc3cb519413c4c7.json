{"ast":null,"code":"/*!\n * jwk/helpers.js - JWK Internal Helper Functions and Constants\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar clone = require(\"lodash.clone\"),\n    util = require(\"../util\"),\n    forge = require(\"../deps/forge\");\n\nvar ALGORITHMS = require(\"../algorithms\"); // ### ASN.1 Validators\n// Adapted from digitalbazaar/node-forge/js/asn1.js\n// PrivateKeyInfo\n\n\nvar privateKeyValidator = {\n  name: \"PrivateKeyInfo\",\n  tagClass: forge.asn1.Class.UNIVERSAL,\n  type: forge.asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    // Version (INTEGER)\n    name: \"PrivateKeyInfo.version\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.INTEGER,\n    constructed: false,\n    capture: \"keyVersion\"\n  }, {\n    name: \"PrivateKeyInfo.privateKeyAlgorithm\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: \"AlgorithmIdentifier.algorithm\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.OID,\n      constructed: false,\n      capture: \"keyOid\"\n    }, {\n      name: \"AlgorithmIdentifier.parameters\",\n      captureAsn1: \"keyParams\"\n    }]\n  }, {\n    name: \"PrivateKeyInfo\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.OCTETSTRING,\n    constructed: false,\n    capture: \"keyValue\"\n  }]\n}; // Adapted from digitalbazaar/node-forge/x509.js\n\nvar publicKeyValidator = {\n  name: \"SubjectPublicKeyInfo\",\n  tagClass: forge.asn1.Class.UNIVERSAL,\n  type: forge.asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: \"SubjectPublicKeyInfo.AlgorithmIdentifier\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: \"AlgorithmIdentifier.algorithm\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.OID,\n      constructed: false,\n      capture: \"keyOid\"\n    }, {\n      name: \"AlgorithmIdentifier.parameters\",\n      captureAsn1: \"keyParams\"\n    }]\n  }, {\n    name: \"SubjectPublicKeyInfo.subjectPublicKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.BITSTRING,\n    constructed: false,\n    capture: \"keyValue\"\n  }]\n}; // Adapted from digitalbazaar/node-forge/x509.js\n\nvar X509CertificateValidator = {\n  name: \"Certificate\",\n  tagClass: forge.asn1.Class.UNIVERSAL,\n  type: forge.asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: \"Certificate.TBSCertificate\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    captureAsn1: \"certificate\",\n    value: [{\n      name: \"Certificate.TBSCertificate.version\",\n      tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n      type: 0,\n      constructed: true,\n      optional: true,\n      value: [{\n        name: \"Certificate.TBSCertificate.version.integer\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"certVersion\"\n      }]\n    }, {\n      name: \"Certificate.TBSCertificate.serialNumber\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"certSerialNumber\"\n    }, {\n      name: \"Certificate.TBSCertificate.signature\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [{\n        name: \"Certificate.TBSCertificate.signature.algorithm\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.OID,\n        constructed: false,\n        capture: \"certSignatureOid\"\n      }, {\n        name: \"Certificate.TBSCertificate.signature.parameters\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        optional: true,\n        captureAsn1: \"certSignatureParams\"\n      }]\n    }, {\n      name: \"Certificate.TBSCertificate.issuer\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: \"certIssuer\"\n    }, {\n      name: \"Certificate.TBSCertificate.validity\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      // Note: UTC and generalized times may both appear so the capture\n      // names are based on their detected order, the names used below\n      // are only for the common case, which validity time really means\n      // \"notBefore\" and which means \"notAfter\" will be determined by order\n      value: [{\n        // notBefore (Time) (UTC time case)\n        name: \"Certificate.TBSCertificate.validity.notBefore (utc)\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.UTCTIME,\n        constructed: false,\n        optional: true,\n        capture: \"certValidity1UTCTime\"\n      }, {\n        // notBefore (Time) (generalized time case)\n        name: \"Certificate.TBSCertificate.validity.notBefore (generalized)\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.GENERALIZEDTIME,\n        constructed: false,\n        optional: true,\n        capture: \"certValidity2GeneralizedTime\"\n      }, {\n        // notAfter (Time) (only UTC time is supported)\n        name: \"Certificate.TBSCertificate.validity.notAfter (utc)\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.UTCTIME,\n        constructed: false,\n        optional: true,\n        capture: \"certValidity3UTCTime\"\n      }, {\n        // notAfter (Time) (only UTC time is supported)\n        name: \"Certificate.TBSCertificate.validity.notAfter (generalized)\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.GENERALIZEDTIME,\n        constructed: false,\n        optional: true,\n        capture: \"certValidity4GeneralizedTime\"\n      }]\n    }, {\n      // Name (subject) (RDNSequence)\n      name: \"Certificate.TBSCertificate.subject\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: \"certSubject\"\n    }, // SubjectPublicKeyInfo\n    publicKeyValidator, {\n      // issuerUniqueID (optional)\n      name: \"Certificate.TBSCertificate.issuerUniqueID\",\n      tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n      type: 1,\n      constructed: true,\n      optional: true,\n      value: [{\n        name: \"Certificate.TBSCertificate.issuerUniqueID.id\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.BITSTRING,\n        constructed: false,\n        capture: \"certIssuerUniqueId\"\n      }]\n    }, {\n      // subjectUniqueID (optional)\n      name: \"Certificate.TBSCertificate.subjectUniqueID\",\n      tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n      type: 2,\n      constructed: true,\n      optional: true,\n      value: [{\n        name: \"Certificate.TBSCertificate.subjectUniqueID.id\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.BITSTRING,\n        constructed: false,\n        capture: \"certSubjectUniqueId\"\n      }]\n    }, {\n      // Extensions (optional)\n      name: \"Certificate.TBSCertificate.extensions\",\n      tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n      type: 3,\n      constructed: true,\n      captureAsn1: \"certExtensions\",\n      optional: true\n    }]\n  }, {\n    // AlgorithmIdentifier (signature algorithm)\n    name: \"Certificate.signatureAlgorithm\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      // algorithm\n      name: \"Certificate.signatureAlgorithm.algorithm\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.OID,\n      constructed: false,\n      capture: \"certSignatureOid\"\n    }, {\n      name: \"Certificate.TBSCertificate.signature.parameters\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      optional: true,\n      captureAsn1: \"certSignatureParams\"\n    }]\n  }, {\n    // SignatureValue\n    name: \"Certificate.signatureValue\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.BITSTRING,\n    constructed: false,\n    capture: \"certSignature\"\n  }]\n};\nvar INTERNALS = {\n  THUMBPRINT_KEY: \"internal\\u0000thumbprint\",\n  THUMBPRINT_HASH: \"SHA-256\"\n};\nmodule.exports = {\n  validators: {\n    privateKey: privateKeyValidator,\n    publicKey: publicKeyValidator,\n    certificate: X509CertificateValidator\n  },\n  thumbprint: function (cfg, json, hash) {\n    if (\"function\" !== typeof cfg.thumbprint) {\n      return Promise.reject(new Error(\"thumbprint not supported\"));\n    }\n\n    hash = (hash || INTERNALS.THUMBPRINT_HASH).toUpperCase();\n    var fields = cfg.thumbprint(json);\n    var input = Object.keys(fields).sort().map(function (k) {\n      var v = fields[k];\n\n      if (Buffer.isBuffer(v)) {\n        v = util.base64url.encode(v);\n      }\n\n      return JSON.stringify(k) + \":\" + JSON.stringify(v);\n    });\n    input = \"{\" + input.join(\",\") + \"}\";\n\n    try {\n      return ALGORITHMS.digest(hash, new Buffer(input, \"utf8\"));\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  },\n  unpackProps: function (props, allowed) {\n    var output; // apply all of the existing values\n\n    allowed.forEach(function (cfg) {\n      if (!(cfg.name in props)) {\n        return;\n      }\n\n      output = output || {};\n      var value = props[cfg.name];\n\n      switch (cfg.type) {\n        case \"binary\":\n          if (Buffer.isBuffer(value)) {\n            value = value;\n            props[cfg.name] = util.base64url.encode(value);\n          } else {\n            value = util.base64url.decode(value);\n          }\n\n          break;\n\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n          value = value;\n          break;\n\n        case \"array\":\n          value = [].concat(value);\n          break;\n\n        case \"object\":\n          value = clone(value);\n          break;\n\n        default:\n          // TODO: deep clone?\n          value = value;\n          break;\n      }\n\n      output[cfg.name] = value;\n    }); // remove any from json that didn't apply\n\n    var check = output || {};\n    Object.keys(props).forEach(function (n) {\n      if (n in check) {\n        return;\n      }\n\n      delete props[n];\n    });\n    return output;\n  },\n  COMMON_PROPS: [{\n    name: \"kty\",\n    type: \"string\"\n  }, {\n    name: \"kid\",\n    type: \"string\"\n  }, {\n    name: \"use\",\n    type: \"string\"\n  }, {\n    name: \"alg\",\n    type: \"string\"\n  }, {\n    name: \"x5c\",\n    type: \"array\"\n  }, {\n    name: \"x5t\",\n    type: \"binary\"\n  }, {\n    name: \"x5u\",\n    type: \"string\"\n  }, {\n    name: \"key_ops\",\n    type: \"array\"\n  }],\n  INTERNALS: INTERNALS\n};","map":null,"metadata":{},"sourceType":"script"}