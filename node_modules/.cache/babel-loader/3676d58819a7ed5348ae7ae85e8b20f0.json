{"ast":null,"code":"/*!\n * jws/sign.js - Sign to JWS\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar clone = require(\"lodash.clone\"),\n    merge = require(\"../util/merge\"),\n    uniq = require(\"lodash.uniq\"),\n    util = require(\"../util\"),\n    JWK = require(\"../jwk\"),\n    slice = require(\"./helpers\").slice;\n\nvar DEFAULTS = require(\"./defaults\");\n/**\n * @class JWS.Signer\n * @classdesc Generator of signed content.\n *\n * @description\n * **NOTE:** this class cannot be instantiated directly. Instead call {@link\n * JWS.createSign}.\n */\n\n\nvar JWSSigner = function (cfg, signatories) {\n  var finalized = false,\n      format = cfg.format || \"general\",\n      content = new Buffer(0);\n  /**\n  * @member {Boolean} JWS.Signer#compact\n  * @description\n  * Indicates whether the outuput of this signature generator is using\n  * the Compact serialization (`true`) or the JSON serialization\n  * (`false`).\n  */\n\n  Object.defineProperty(this, \"compact\", {\n    get: function () {\n      return \"compact\" === format;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"format\", {\n    get: function () {\n      return format;\n    },\n    enumerable: true\n  });\n  /**\n  * @method JWS.Signer#update\n  * @description\n  * Updates the signing content for this signature content. The content\n  * is appended to the end of any other content already applied.\n  *\n  * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n  * converted to a Buffer internally to {encoding}.\n  *\n  * @param {Buffer|String} data The data to sign.\n  * @param {String} [encoding=\"binary\"] The encoding of {data}.\n  * @returns {JWS.Signer} This signature generator.\n  * @throws {Error} If a signature has already been generated.\n  */\n\n  Object.defineProperty(this, \"update\", {\n    value: function (data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n\n        if (content.length) {\n          content = Buffer.concat([content, data], content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n  * @method JWS.Signer#final\n  * @description\n  * Finishes the signature operation.\n  *\n  * The returned Promise, when fulfilled, is the JSON Web Signature (JWS)\n  * object, either in the Compact (if {@link JWS.Signer#format} is\n  * `\"compact\"`), the flattened JSON (if {@link JWS.Signer#format} is\n  * \"flattened\"), or the general JSON serialization.\n  *\n  * @param {Buffer|String} [data] The final content to apply.\n  * @param {String} [encoding=\"binary\"] The encoding of the final content\n  *        (if any).\n  * @returns {Promise} The promise for the signatures\n  * @throws {Error} If a signature has already been generated.\n  */\n\n  Object.defineProperty(this, \"final\", {\n    value: function (data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      } // last-minute data\n\n\n      this.update(data, encoding); // mark as done...ish\n\n      finalized = true;\n      var promise; // map signatory promises to just signatories\n\n      promise = Promise.all(signatories);\n      promise = promise.then(function (sigs) {\n        // prepare content\n        content = util.base64url.encode(content);\n        sigs = sigs.map(function (s) {\n          // prepare protected\n          var protect = {},\n              lenProtect = 0,\n              unprotect = clone(s.header),\n              lenUnprotect = Object.keys(unprotect).length;\n          s.protected.forEach(function (h) {\n            if (!(h in unprotect)) {\n              return;\n            }\n\n            protect[h] = unprotect[h];\n            lenProtect++;\n            delete unprotect[h];\n            lenUnprotect--;\n          });\n\n          if (lenProtect > 0) {\n            protect = JSON.stringify(protect);\n            protect = util.base64url.encode(protect);\n          } else {\n            protect = \"\";\n          } // signit!\n\n\n          var data = new Buffer(protect + \".\" + content, \"ascii\");\n          s = s.key.sign(s.header.alg, data, s.header);\n          s = s.then(function (result) {\n            var sig = {};\n\n            if (0 < lenProtect) {\n              sig.protected = protect;\n            }\n\n            if (0 < lenUnprotect) {\n              sig.header = unprotect;\n            }\n\n            sig.signature = util.base64url.encode(result.mac);\n            return sig;\n          });\n          return s;\n        });\n        sigs = [Promise.resolve(content)].concat(sigs);\n        return Promise.all(sigs);\n      });\n      promise = promise.then(function (results) {\n        var content = results[0];\n        return {\n          payload: content,\n          signatures: results.slice(1)\n        };\n      });\n\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function (jws) {\n            var compact = [jws.signatures[0].protected, jws.payload, jws.signatures[0].signature];\n            compact = compact.join(\".\");\n            return compact;\n          });\n          break;\n\n        case \"flattened\":\n          promise = promise.then(function (jws) {\n            var flattened = {};\n            flattened.payload = jws.payload;\n            var sig = jws.signatures[0];\n\n            if (sig.protected) {\n              flattened.protected = sig.protected;\n            }\n\n            if (sig.header) {\n              flattened.header = sig.header;\n            }\n\n            flattened.signature = sig.signature;\n            return flattened;\n          });\n          break;\n      }\n\n      return promise;\n    }\n  });\n};\n/**\n * @description\n * Creates a new JWS.Signer with the given options and signatories.\n *\n * @param {Object} [opts] The signing options\n * @param {Boolean} [opts.compact] Use compact serialization?\n * @param {String} [opts.format] The serialization format to use (\"compact\",\n *                 \"flattened\", \"general\")\n * @param {Object} [opts.fields] Additional header fields\n * @param {JWK.Key[]|Object[]} [signs] Signatories, either as an array of\n *        JWK.Key instances; or an array of objects, each with the following\n *        properties\n * @param {JWK.Key} signs.key Key used to sign content\n * @param {Object} [signs.header] Per-signatory header fields\n * @param {String} [signs.reference] Reference field to identify the key\n * @param {String[]|String} [signs.protect] List of fields to integrity\n *        protect (\"*\" to protect all fields)\n * @returns {JWS.Signer} The signature generator.\n * @throws {Error} If Compact serialization is requested but there are\n *         multiple signatories\n */\n\n\nfunction createSign(opts, signs) {\n  // fixup signatories\n  var options = opts,\n      signStart = 1,\n      signList = signs;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one signatory must be provided\");\n  }\n\n  if (arguments.length === 1) {\n    signList = opts;\n    signStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) || opts && \"kty\" in opts || opts && \"key\" in opts && (JWK.isKey(opts.key) || \"kty\" in opts.key)) {\n    signList = opts;\n    signStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n\n  if (!Array.isArray(signList)) {\n    signList = slice(arguments, signStart);\n  } // fixup options\n\n\n  options = merge(clone(DEFAULTS), options); // setup header fields\n\n  var allFields = options.fields || {}; // setup serialization format\n\n  var format = options.format;\n\n  if (!format) {\n    format = options.compact ? \"compact\" : \"general\";\n  }\n\n  if ((\"compact\" === format || \"flattened\" === format) && 1 < signList.length) {\n    throw new Error(\"too many signatories for compact or flattened JSON serialization\");\n  } // note protected fields (globally)\n  // protected fields are per signature\n\n\n  var protectAll = \"*\" === options.protect;\n\n  if (options.compact) {\n    protectAll = true;\n  }\n\n  signList = signList.map(function (s, idx) {\n    var p; // resolve a key\n\n    if (s && \"kty\" in s) {\n      p = JWK.asKey(s);\n      p = p.then(function (k) {\n        return {\n          key: k\n        };\n      });\n    } else if (s) {\n      p = JWK.asKey(s.key);\n      p = p.then(function (k) {\n        return {\n          header: s.header,\n          reference: s.reference,\n          protect: s.protect,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for signatory \" + idx));\n    } // resolve the complete signatory\n\n\n    p = p.then(function (signatory) {\n      var key = signatory.key; // make sure there is a header\n\n      var header = signatory.header || {};\n      header = merge(merge({}, allFields), header);\n      signatory.header = header; // ensure an algorithm\n\n      if (!header.alg) {\n        header.alg = key.algorithms(JWK.MODE_SIGN)[0] || \"\";\n      } // determine the key reference\n\n\n      var ref = signatory.reference;\n      delete signatory.reference;\n\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function (k) {\n          return k in header;\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n\n      var jwk;\n\n      if (ref) {\n        jwk = key.toJSON();\n\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      } // determine protected fields\n\n\n      var protect = signatory.protect;\n\n      if (protectAll || \"*\" === protect) {\n        protect = Object.keys(header);\n      } else if (\"string\" === protect) {\n        protect = [protect];\n      } else if (Array.isArray(protect)) {\n        protect = protect.concat();\n      } else if (!protect) {\n        protect = [];\n      } else {\n        return Promise.reject(new Error(\"protect must be a list of fields\"));\n      }\n\n      protect = uniq(protect);\n      signatory.protected = protect; // freeze signatory\n\n      signatory = Object.freeze(signatory);\n      return signatory;\n    });\n    return p;\n  });\n  var cfg = {\n    format: format\n  };\n  return new JWSSigner(cfg, signList);\n}\n\nmodule.exports = {\n  signer: JWSSigner,\n  createSign: createSign\n};","map":null,"metadata":{},"sourceType":"script"}