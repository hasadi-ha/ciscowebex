{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _apply = require('babel-runtime/core-js/reflect/apply');\n\nvar _apply2 = _interopRequireDefault(_apply);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _isArray2 = require('lodash/isArray');\n\nvar _isArray3 = _interopRequireDefault(_isArray2);\n\nvar _dec, _dec2, _dec3, _dec4, _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar _common = require('@webex/common');\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _userUuidBatcher = require('./user-uuid-batcher');\n\nvar _userUuidBatcher2 = _interopRequireDefault(_userUuidBatcher);\n\nvar _userUuidStore = require('./user-uuid-store');\n\nvar _userUuidStore2 = _interopRequireDefault(_userUuidStore);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n/**\n * @class\n */\n\n\nvar User = _webexCore.SparkPlugin.extend((_dec = (0, _webexCore.waitForValue)('@'), _dec2 = (0, _common.oneFlight)({\n  keyFactory: function keyFactory(email, options) {\n    return email + String(options && options.create);\n  }\n}), _dec3 = (0, _webexCore.persist)('@'), _dec4 = (0, _common.deprecated)('Use User#verify()'), (_obj = {\n  namespace: 'User',\n  children: {\n    batcher: _userUuidBatcher2.default\n  },\n  props: {\n    /**\n     * Indicates if the current user is known to have a password.\n     * @instance\n     * @memberof User\n     * @type {boolean}\n     */\n    hasPassword: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n  session: {\n    store: {\n      default: function _default() {\n        return new _userUuidStore2.default();\n      },\n      type: 'any'\n    }\n  },\n\n  /**\n   * Activates a Spark user account and exchanges for user token.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {Object} options.confirmationCode (required -- optional if verification token is provided)\n   * @param {Object} options.id (required -- optional if verification token is provided)\n   * @param {Object} options.verificationToken (required -- optional if uuid and verification token provided)\n   * @param {Object} options.email (required with verificationToken for Federation/global user)\n   * @returns {Promise} Resolves with a userSession\n   */\n  activate: function activate() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!(options.verificationToken || options.confirmationCode && options.id)) {\n      return _promise2.default.reject(new Error('either options.verificationToken is required or both options.confirmationCode and options.id are required'));\n    } // Email is required for federation\n\n\n    if (this.spark.config.credentials.federation && !options.email) {\n      return _promise2.default.reject(new Error('email is required with federation option'));\n    }\n\n    options.scope = this.spark.config.credentials.scope; // if we have options.email and options.verificationToken\n    // and Federation flag is enabled, flag that we need to\n    // lookup user's CI.\n\n    var needsCILookup = this.spark.config.credentials.federation && options.email && options.verificationToken;\n    return this.getUserCI(options.email, needsCILookup).then(function () {\n      var activateOptions = (0, _assign2.default)({}, options);\n      delete activateOptions.email;\n      return _this.request({\n        uri: _this.spark.config.credentials.activationUrl,\n        method: 'POST',\n        body: activateOptions,\n        auth: {\n          user: _this.spark.config.credentials.client_id,\n          pass: _this.spark.config.credentials.client_secret,\n          sendImmediately: true\n        }\n      }).then(function (res) {\n        _this.spark.credentials.set({\n          supertoken: res.body.tokenData\n        });\n\n        return res.body;\n      });\n    });\n  },\n\n  /**\n   * Converts a user-identifying object to a uuid, perhaps by doing a network\n   * lookup\n   * @param {string|Object} user\n   * @param {Object} options\n   * @param {boolean} options.create if true, ensures the return UUID refers to\n   * an existing user (rather than creating one deterministically based on email\n   * address), even if that user must be created\n   * @returns {Promise<string>}\n   */\n  asUUID: function asUUID(user, options) {\n    var _this2 = this;\n\n    if (!user) {\n      return _promise2.default.reject(new Error('`user` is required'));\n    }\n\n    if ((0, _isArray3.default)(user)) {\n      return _promise2.default.all(user.map(function (u) {\n        return _this2.asUUID(u, options);\n      }));\n    }\n\n    var id = this._extractUUID(user);\n\n    if (!(options && options.force) && _common.patterns.uuid.test(id)) {\n      return _promise2.default.resolve(id);\n    }\n\n    var email = this._extractEmailAddress(user);\n\n    if (!_common.patterns.email.test(email)) {\n      return _promise2.default.reject(new Error('Provided user object does not appear to identify a user'));\n    }\n\n    return this.getUUID(email, options);\n  },\n\n  /**\n   * Requests a uuid from the api\n   * @param {string} email\n   * @param {Object} options\n   * @param {boolean} options.create\n   * @returns {Promise<string>}\n   */\n  fetchUUID: function fetchUUID(email, options) {\n    var _this3 = this;\n\n    return this.batcher.request({\n      email: email,\n      create: options && options.create\n    }).then(function (user) {\n      return _this3.recordUUID((0, _assign2.default)({\n        emailAddress: email\n      }, user)).then(function () {\n        return user.id;\n      });\n    });\n  },\n\n  /**\n   * Fetches details about the current user\n   * @returns {Promise<Object>}\n   */\n  get: function get() {\n    var _this4 = this;\n\n    return this.request({\n      service: 'conversation',\n      resource: 'users'\n    }).then(function (res) {\n      return res.body;\n    }).then((0, _common.tap)(function (user) {\n      return _this4.recordUUID({\n        id: user.id,\n        // CI endpoints don't use the same user format as actors, so, email may\n        // be in one of a few fields\n        emailAddress: user.email || user.emailAddress\n      });\n    }));\n  },\n  getUUID: function getUUID(email, options) {\n    var _this5 = this;\n\n    return this.store.getByEmail(email).then(function (user) {\n      if (options && options.create && !user.userExists) {\n        return _promise2.default.reject(new Error('User for specified email cannot be confirmed to exist'));\n      }\n\n      if (!user.id) {\n        return _promise2.default.reject(new Error('No id recorded for specified user'));\n      }\n\n      return user.id;\n    }).catch(function () {\n      return _this5.fetchUUID(email, options);\n    });\n  },\n  initialize: function initialize() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return (0, _apply2.default)(_webexCore.SparkPlugin.prototype.initialize, this, args);\n  },\n\n  /**\n   * Caches the uuid for the specified email address\n   * @param {Object} user\n   * @param {string} user.id\n   * @param {string} user.emailAddress\n   * @returns {Promise}\n   */\n  recordUUID: function recordUUID(user) {\n    if (!user) {\n      return _promise2.default.reject(new Error('`user` is required'));\n    }\n\n    if (!user.id) {\n      return _promise2.default.reject(new Error('`user.id` is required'));\n    }\n\n    if (!_common.patterns.uuid.test(user.id)) {\n      return _promise2.default.reject(new Error('`user.id` must be a uuid'));\n    }\n\n    if (!user.emailAddress) {\n      return _promise2.default.reject(new Error('`user.emailAddress` is required'));\n    }\n\n    if (!_common.patterns.email.test(user.emailAddress)) {\n      return _promise2.default.reject(new Error('`user.emailAddress` must be an email address'));\n    }\n\n    return this.store.add(user);\n  },\n  register: function register() {\n    return this.verify.apply(this, arguments);\n  },\n\n  /**\n   * Updates a user's password with spark.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {string} options.password (required)\n   * @param {string} options.email (required when federation enabled)\n   * @returns {Promise} Resolves with complete user object containing new password\n   */\n  setPassword: function setPassword(options) {\n    var _this6 = this;\n\n    options = options || {};\n\n    if (!options.password) {\n      return _promise2.default.reject(new Error('`options.password` is required'));\n    } // Email is required for federation\n\n\n    if (this.spark.config.credentials.federation && !options.email) {\n      return _promise2.default.reject(new Error('email is required with federation option'));\n    }\n\n    return this.getUserCI(options.email, this.spark.config.credentials.federation).then(function () {\n      return _this6.spark.credentials.getUserToken();\n    }).then(function (token) {\n      return _this6.request({\n        uri: _this6.spark.config.credentials.setPasswordUrl + '/' + _this6.spark.internal.device.userId,\n        method: 'PATCH',\n        headers: {\n          authorization: token.toString()\n        },\n        body: {\n          schemas: ['urn:scim:schemas:core:1.0', 'urn:scim:schemas:extension:cisco:commonidentity:1.0'],\n          password: options.password\n        }\n      });\n    }).then(function (res) {\n      _this6.hasPassword = true;\n      return res.body;\n    });\n  },\n\n  /**\n   * Updates the current user's display name\n   * @param {Object} options\n   * @param {string} options.displayName\n   * @returns {Promise<Object>}\n   */\n  update: function update(options) {\n    options = options || {};\n\n    if (!options.displayName) {\n      return _promise2.default.reject(new Error('`options.displayName` is required'));\n    }\n\n    return this.request({\n      method: 'PATCH',\n      service: 'conversation',\n      resource: 'users/user',\n      body: options\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * Determines if the specified user needs to signup or can signin.\n   * Triggers activation email if client credentials are used\n   * @param {Object} options\n   * @param {string} options.email (required)\n   * @param {string} options.reqId required if need to check email status\n   * @param {string} options.preloginId\n   * @returns {Promise<Object>}\n   */\n  verify: function verify(options) {\n    var _this7 = this;\n\n    options = (0, _assign2.default)({}, this.config.verifyDefaults, options);\n\n    if (!options.email) {\n      return _promise2.default.reject(new Error('`options.email` is required'));\n    } // For Federation, there is only one Atlas, which we get the user's CI from\n    // Use default CI URL to start, will be re-set after we retrieve user's CI\n\n\n    var orgIdentityUrl = this.spark.config.credentials.identity.url;\n    var orgIdbrokerUrl = this.spark.config.credentials.idbroker.url;\n\n    if (this.spark.config.credentials.federation) {\n      this.spark.config.credentials.idbroker.url = this.spark.config.credentials.idbroker.defaultUrl;\n      this.spark.config.credentials.identity.url = this.spark.config.credentials.identity.defaultUrl;\n    }\n\n    return this.spark.credentials.getUserToken().catch(function () {\n      return _this7.spark.credentials.getClientToken();\n    }).then(function (token) {\n      return _this7.request({\n        service: 'atlas',\n        resource: 'users/activations',\n        method: 'POST',\n        headers: {\n          authorization: token.toString(),\n          'x-prelogin-userid': options.preloginId\n        },\n        body: options,\n        shouldRefreshAccessToken: false\n      });\n    }).then(function (res) {\n      if (res.body.hasPassword || res.body.sso) {\n        _this7.hasPassword = true;\n      } // if we have a different CI than default, and Federation is enabled,\n      // update the CI to what was returned by Atlas.\n\n\n      if (_this7.spark.config.credentials.federation && res.body.userEntities) {\n        _this7.spark.config.credentials.idbroker.url = res.body.userEntities.idBrokerUrl;\n        _this7.spark.config.credentials.identity.url = res.body.userEntities.identityUrl;\n      }\n\n      return res.body;\n    }).catch(function (reason) {\n      // reset CI on failure\n      if (_this7.spark.config.credentials.federation) {\n        _this7.spark.config.credentials.idbroker.url = orgIdbrokerUrl;\n        _this7.spark.config.credentials.identity.url = orgIdentityUrl;\n      }\n\n      return _promise2.default.reject(reason);\n    });\n  },\n\n  /**\n   * If the passed-in lookupCI is true, retrieve the user's\n   * CI from Atlas and return the URL's via a Promise.\n   * Otherwise, return current CI in config via a Promise.\n   * Useful in a Promise chain to retrieve the CI based on\n   * conditions like Federation enabled, and suppresses sending\n   * an additional email to the user, since this is just a\n   * look-up.\n   * @param {string} email (required)\n   * @param {boolean} lookupCI (required)\n   * @returns {Promise<Object>}\n   */\n  getUserCI: function getUserCI(email, lookupCI) {\n    if (lookupCI) {\n      // call verify first to get the user's CI, but suppress sending another email\n      var verifyOptions = {\n        email: email,\n        suppressEmail: true\n      };\n      return this.verify(verifyOptions).then(function (res) {\n        return _promise2.default.resolve(res.userEntities);\n      });\n    }\n\n    return _promise2.default.resolve({\n      idBrokerUrl: this.spark.config.credentials.idbroker.url,\n      identityUrl: this.spark.config.credentials.identity.url\n    });\n  },\n\n  /**\n   * Extracts the uuid from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractUUID: function _extractUUID(user) {\n    return user.entryUUID || user.id || user;\n  },\n\n  /**\n   * Extracts the email address from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractEmailAddress: function _extractEmailAddress(user) {\n    return user.email || user.emailAddress || user.entryEmail || user;\n  },\n  version: '1.59.0'\n}, (_applyDecoratedDescriptor(_obj, 'activate', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'activate'), _obj), _applyDecoratedDescriptor(_obj, 'getUUID', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'getUUID'), _obj), _applyDecoratedDescriptor(_obj, 'initialize', [_dec3], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initialize'), _obj), _applyDecoratedDescriptor(_obj, 'register', [_dec4], (0, _getOwnPropertyDescriptor2.default)(_obj, 'register'), _obj)), _obj)));\n\nexports.default = User;","map":null,"metadata":{},"sourceType":"script"}