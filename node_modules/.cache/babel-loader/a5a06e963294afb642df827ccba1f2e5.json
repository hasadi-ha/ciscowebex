{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _weakMap = require('babel-runtime/core-js/weak-map');\n\nvar _weakMap2 = _interopRequireDefault(_weakMap);\n\nvar _omit2 = require('lodash/omit');\n\nvar _omit3 = _interopRequireDefault(_omit2);\n\nvar _dec, _desc, _value, _obj;\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar _querystring = require('querystring');\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nvar _util = require('util');\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _commonTimers = require('@webex/common-timers');\n\nvar _common = require('@webex/common');\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _nodeKms = require('node-kms');\n\nvar _nodeJose = require('node-jose');\n\nvar _nodeJose2 = _interopRequireDefault(_nodeJose);\n\nvar _kmsBatcher = require('./kms-batcher');\n\nvar _kmsBatcher2 = _interopRequireDefault(_kmsBatcher);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nvar contexts = new _weakMap2.default();\nvar kmsDetails = new _weakMap2.default();\nvar partialContexts = new _weakMap2.default();\n/**\n * @class\n */\n\nvar KMS = _webexCore.SparkPlugin.extend((_dec = (0, _common.oneFlight)({\n  keyFactory: function keyFactory(_ref) {\n    var uri = _ref.uri,\n        onBehalfOf = _ref.onBehalfOf;\n    return uri + '/' + onBehalfOf;\n  }\n}), (_obj = {\n  namespace: 'Encryption',\n  children: {\n    batcher: _kmsBatcher2.default\n  },\n\n  /**\n   * Binds a key to a resource\n   * @param {Object} options\n   * @param {KMSResourceObject} options.kro\n   * @param {string} options.kroUri\n   * @param {Key} options.key\n   * @param {string} options.keyUri\n   * @returns {Promise<Key>}\n   */\n  bindKey: function bindKey(_ref2) {\n    var _this = this;\n\n    var kro = _ref2.kro,\n        kroUri = _ref2.kroUri,\n        key = _ref2.key,\n        keyUri = _ref2.keyUri;\n    kroUri = kroUri || kro.uri;\n    keyUri = keyUri || key.uri;\n    this.logger.info('kms: binding key to resource');\n    /* istanbul ignore if */\n\n    if (!kroUri) {\n      return _promise2.default.reject(new Error('`kro` or `kroUri` is required'));\n    }\n    /* istanbul ignore if */\n\n\n    if (!keyUri) {\n      return _promise2.default.reject(new Error('`key` or `keyUri` is required'));\n    }\n\n    return this.request({\n      method: 'update',\n      resourceUri: kroUri,\n      uri: keyUri\n    }).then(function (res) {\n      _this.logger.info('kms: bound key to resource');\n\n      return res.key;\n    });\n  },\n\n  /**\n   * Creates a new KMS Resource\n   * @param {Object} options\n   * @param {Array<string>} options.userIds\n   * @param {Array<string>} options.keyUris\n   * @param {Key} options.key\n   * @param {Array<Keys>} options.keys\n   * @returns {Promise<KMSResourceObject>}\n   */\n  createResource: function createResource(_ref3) {\n    var _this2 = this;\n\n    var userIds = _ref3.userIds,\n        keyUris = _ref3.keyUris,\n        key = _ref3.key,\n        keys = _ref3.keys;\n    keyUris = keyUris || [];\n    /* istanbul ignore if */\n\n    if (keys) {\n      keyUris = keys.reduce(function (uris, k) {\n        uris.push(k.uri);\n        return uris;\n      }, keyUris);\n    }\n    /* istanbul ignore else */\n\n\n    if (key) {\n      keyUris.push(key.uri);\n    }\n    /* istanbul ignore if */\n\n\n    if (keyUris.length === 0) {\n      return _promise2.default.reject(new Error('Cannot create KMS Resource without at least one keyUri'));\n    }\n\n    this.logger.info('kms: creating resource');\n    return this.request({\n      method: 'create',\n      uri: '/resources',\n      userIds: userIds,\n      keyUris: keyUris\n    }).then(function (res) {\n      _this2.logger.info('kms: created resource');\n\n      return res.resource;\n    });\n  },\n\n  /**\n   * Authorizes a user or KRO to a KRO\n   * @param {Object} options\n   * @param {Array<string>} options.userIds\n   * @param {Array<string>} options.authIds interchangable with userIds\n   * @param {KMSResourceObject} options.kro the target kro\n   * @param {string} options.kroUri\n   * @returns {Promise<KMSAuthorizationObject>}\n   */\n  addAuthorization: function addAuthorization(_ref4) {\n    var _this3 = this;\n\n    var userIds = _ref4.userIds,\n        authIds = _ref4.authIds,\n        kro = _ref4.kro,\n        kroUri = _ref4.kroUri;\n    userIds = userIds || [];\n    kroUri = kroUri || kro.uri;\n\n    if (authIds) {\n      userIds = userIds.concat(authIds);\n    }\n    /* istanbul ignore if */\n\n\n    if (userIds.length === 0) {\n      return _promise2.default.reject(new Error('Cannot add authorization without userIds or authIds'));\n    }\n    /* istanbul ignore if */\n\n\n    if (!kroUri) {\n      return _promise2.default.reject(new Error('`kro` or `kroUri` is required'));\n    }\n\n    this.logger.info('kms: adding authorization to kms resource');\n    return this.request({\n      method: 'create',\n      uri: '/authorizations',\n      resourceUri: kroUri,\n      userIds: userIds\n    }).then(function (res) {\n      _this3.logger.info('kms: added authorization');\n\n      return res.authorizations;\n    });\n  },\n\n  /**\n   * Retrieve a list of users that have been authorized to the KRO\n   * @param {Object} options\n   * @param {KMSResourceObject} options.kro the target kro\n   * @param {string} options.kroUri\n   * @returns {Array<authId>}\n   */\n  listAuthorizations: function listAuthorizations(_ref5) {\n    var _this4 = this;\n\n    var kro = _ref5.kro,\n        kroUri = _ref5.kroUri;\n    kroUri = kroUri || kro.uri;\n    /* istanbul ignore if */\n\n    if (!kroUri) {\n      return _promise2.default.reject(new Error('`kro` or `kroUri` is required'));\n    }\n\n    return this.request({\n      method: 'retrieve',\n      uri: kroUri + '/authorizations'\n    }).then(function (res) {\n      _this4.logger.info('kms: retrieved authorization list');\n\n      return res.authorizations;\n    });\n  },\n\n  /**\n   * Deauthorizes a user or KRO from a KRO\n   * @param {Object} options\n   * @param {string} options.userId\n   * @param {string} options.authId interchangable with userIds\n   * @param {KMSResourceObject} options.kro the target kro\n   * @param {string} options.kroUri\n   * @returns {Promise<KMSAuthorizationObject>}\n   */\n  removeAuthorization: function removeAuthorization(_ref6) {\n    var _this5 = this;\n\n    var authId = _ref6.authId,\n        userId = _ref6.userId,\n        kro = _ref6.kro,\n        kroUri = _ref6.kroUri;\n    authId = authId || userId;\n    kroUri = kroUri || kro.uri;\n    /* istanbul ignore if */\n\n    if (!authId) {\n      return _promise2.default.reject(new Error('Cannot remove authorization without authId'));\n    }\n    /* istanbul ignore if */\n\n\n    if (!kroUri) {\n      return _promise2.default.reject(new Error('`kro` or `kroUri` is required'));\n    }\n\n    this.logger.info('kms: removing authorization from kms resource');\n    return this.request({\n      method: 'delete',\n      uri: kroUri + '/authorizations?' + _querystring2.default.stringify({\n        authId: authId\n      })\n    }).then(function (res) {\n      _this5.logger.info('kms: removed authorization');\n\n      return res.authorizations;\n    });\n  },\n\n  /**\n   * Requests `count` unbound keys from the kms\n   * @param {Object} options\n   * @param {Number} options.count\n   * @returns {Array<Key>}\n   */\n  createUnboundKeys: function createUnboundKeys(_ref7) {\n    var _this6 = this;\n\n    var count = _ref7.count;\n    this.logger.info('kms: request ' + count + ' unbound keys');\n    /* istanbul ignore if */\n\n    if (!count) {\n      return _promise2.default.reject(new Error('`options.count` is required'));\n    }\n\n    return this.request({\n      method: 'create',\n      uri: '/keys',\n      count: count\n    }).then(function (res) {\n      _this6.logger.info('kms: received unbound keys');\n\n      return _promise2.default.all(res.keys.map(_this6.asKey));\n    });\n  },\n  fetchKey: function fetchKey(_ref8) {\n    var _this7 = this;\n\n    var uri = _ref8.uri,\n        onBehalfOf = _ref8.onBehalfOf;\n    /* istanbul ignore if */\n\n    if (!uri) {\n      return _promise2.default.reject(new Error('`options.uri` is required'));\n    }\n\n    this.logger.info('kms: fetching key');\n    return this.request({\n      method: 'retrieve',\n      uri: uri\n    }, {\n      onBehalfOf: onBehalfOf\n    }).then(function (res) {\n      _this7.logger.info('kms: fetched key');\n\n      return _this7.asKey(res.key);\n    });\n  },\n\n  /**\n   * Pings the kms. Mostly for testing\n   * @returns {Promise}\n   */\n  ping: function ping() {\n    return this.request({\n      method: 'update',\n      uri: '/ping'\n    });\n  },\n\n  /**\n   * Ensures a key obect is Key instance\n   * @param {Object} key\n   * @returns {Promise<Key>}\n   */\n  asKey: function asKey(key) {\n    return _nodeJose2.default.JWK.asKey(key.jwk).then(function (jwk) {\n      key.jwk = jwk;\n      return key;\n    });\n  },\n\n  /**\n   * Adds appropriate metadata to the KMS request\n   * @param {Object} payload\n   * @param {Object} onBehalfOf Optional parameter to prepare the request on behalf of another user\n   * @returns {Promise<KMS.Request>}\n   */\n  prepareRequest: function prepareRequest(payload, onBehalfOf) {\n    var _this8 = this;\n\n    var isECDHRequest = payload.method === 'create' && payload.uri.includes('/ecdhe');\n    return _promise2.default.resolve(isECDHRequest ? partialContexts.get(this) : this._getContext()).then(function (context) {\n      _this8.logger.info('kms: wrapping ' + (isECDHRequest ? 'ephemeral key' : 'kms') + ' request');\n\n      var req = new _nodeKms.Request(payload);\n      var requestContext = context;\n\n      if (onBehalfOf) {\n        requestContext = _this8._contextOnBehalfOf(context, onBehalfOf);\n      }\n\n      return req.wrap(requestContext, {\n        serverKey: isECDHRequest\n      }).then(function () {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n          _this8.logger.info('kms: request payload', _util2.default.inspect((0, _omit3.default)(JSON.parse((0, _stringify2.default)(req)), 'wrapped'), {\n            depth: null\n          }));\n        }\n\n        return req;\n      });\n    });\n  },\n\n  /**\n   * Accepts a kms message event, decrypts it, and passes it to the batcher\n   * @param {Object} event\n   * @returns {Promise<Object>}\n   */\n  processKmsMessageEvent: function processKmsMessageEvent(event) {\n    var _this9 = this;\n\n    this.logger.info('kms: received kms message');\n    return _promise2.default.all(event.encryption.kmsMessages.map(function (kmsMessage, index) {\n      return _this9._isECDHEMessage(kmsMessage).then(function (isECDHMessage) {\n        _this9.logger.info('kms: received ' + (isECDHMessage ? 'ecdhe' : 'normal') + ' message');\n\n        var res = new _nodeKms.Response(kmsMessage);\n        return _promise2.default.resolve(isECDHMessage ? partialContexts.get(_this9) : contexts.get(_this9)) // eslint-disable-next-line max-nested-callbacks\n        .then(function (context) {\n          return res.unwrap(context);\n        }) // eslint-disable-next-line max-nested-callbacks\n        .then(function () {\n          if (process.env.NODE_ENV !== 'production') {\n            _this9.logger.info('kms: response payload', _util2.default.inspect((0, _omit3.default)(JSON.parse((0, _stringify2.default)(res)), 'wrapped'), {\n              depth: null\n            }));\n          }\n        }) // eslint-disable-next-line max-nested-callbacks\n        .then(function () {\n          event.encryption.kmsMessages[index] = res;\n        }) // eslint-disable-next-line max-nested-callbacks\n        .then(function () {\n          return res;\n        });\n      });\n    })).then(function () {\n      return _this9.batcher.processKmsMessageEvent(event);\n    }).catch(function (reason) {\n      _this9.logger.error('kms: decrypt failed', reason.stack);\n\n      return _promise2.default.reject(reason);\n    }).then(function () {\n      return event;\n    });\n  },\n\n  /**\n   * Decrypts a kms message\n   * @param {Object} kmsMessage\n   * @returns {Promise<Object>}\n   */\n  decryptKmsMessage: function decryptKmsMessage(kmsMessage) {\n    var res = new _nodeKms.Response(kmsMessage);\n    return contexts.get(this).then(function (context) {\n      return res.unwrap(context);\n    }).then(function () {\n      return res.body;\n    });\n  },\n\n  /**\n   * Determines if the kms message is an ecdhe message or a normal message\n   * @param {Object} kmsMessage\n   * @returns {Promise<boolean>}\n   */\n  _isECDHEMessage: function _isECDHEMessage(kmsMessage) {\n    return this._getKMSStaticPubKey().then(function (kmsStaticPubKey) {\n      var fields = kmsMessage.split('.');\n\n      if (fields.length !== 3) {\n        return false;\n      }\n\n      var header = JSON.parse(_nodeJose2.default.util.base64url.decode(fields[0]));\n      return header.kid === kmsStaticPubKey.kid;\n    });\n  },\n\n  /**\n   * Sends a request to the kms\n   * @param {Object} payload\n   * @param {Object} options\n   * @param {Number} options.timeout (internal)\n   * @param {string} options.onBehalfOf Run the request on behalf of another user (UUID), used in compliance scenarios\n   * @returns {Promise<Object>}\n   */\n  request: function request(payload) {\n    var _this10 = this;\n\n    var _ref9 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        timeout = _ref9.timeout,\n        onBehalfOf = _ref9.onBehalfOf;\n\n    timeout = timeout || this.config.kmsInitialTimeout; // Note: this should only happen when we're using the async kms batcher;\n    // once we implement the sync batcher, this'll need to be smarter.\n\n    return this.spark.internal.mercury.connect().then(function () {\n      return _this10.prepareRequest(payload, onBehalfOf);\n    }).then(function (req) {\n      req[_kmsBatcher.TIMEOUT_SYMBOL] = timeout;\n      return _this10.batcher.request(req);\n    }) // High complexity is due to attempt at test mode resiliency\n    // eslint-disable-next-line complexity\n    .catch(function (reason) {\n      if (process.env.NODE_ENV === 'test' && (reason.status === 403 || reason.statusCode === 403) && reason.message.match(/Failed to resolve authorization token in KmsMessage request for user/)) {\n        _this10.logger.warn('kms: rerequested key due to test-mode kms auth failure');\n\n        return _this10.request(payload, {\n          onBehalfOf: onBehalfOf\n        });\n      } // Ideally, most or all of the code below would go in kms-batcher, but\n      // but batching needs at least one more round of refactoring for that to\n      // work.\n\n\n      if (!reason.statusCode && !reason.status) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n          /* istanbul ignore next: reason.stack vs stack difficult to control in test */\n          _this10.logger.info('kms: request error', reason.stack || reason);\n        }\n\n        timeout *= 2;\n\n        if (timeout >= _this10.config.kmsMaxTimeout) {\n          _this10.logger.info('kms: exceeded maximum KMS request retries; negotiating new ecdh key');\n          /* istanbul ignore else */\n\n\n          if (process.env.NODE_ENV !== 'production') {\n            _this10.logger.info('kms: timeout/maxtimeout', timeout, _this10.config.kmsMaxTimeout);\n          }\n\n          contexts.delete(_this10);\n          timeout = 0;\n        }\n\n        return _this10.request(payload, {\n          timeout: timeout,\n          onBehalfOf: onBehalfOf\n        });\n      }\n\n      return _promise2.default.reject(reason);\n    });\n  },\n\n  /**\n   * @private\n   * @returns {Promise<string>}\n   */\n  _getAuthorization: function _getAuthorization() {\n    return this.spark.credentials.getUserToken('spark:kms').then(function (token) {\n      return token.access_token;\n    });\n  },\n\n  /**\n   * @private\n   * @param {String} onBehalfOf create context on behalf of another user, undefined when this is not necessary\n   * @returns {Promise<Object>}\n   */\n  _getContext: function _getContext() {\n    var _this11 = this;\n\n    var promise = contexts.get(this);\n\n    if (!promise) {\n      promise = this._prepareContext();\n      contexts.set(this, promise);\n      promise.then(function (context) {\n        var expiresIn = context.ephemeralKey.expirationDate - Date.now() - 30000;\n        (0, _commonTimers.safeSetTimeout)(function () {\n          return contexts.delete(_this11);\n        }, expiresIn);\n      });\n    }\n\n    return _promise2.default.all([promise, this._getAuthorization()]).then(function (_ref10) {\n      var _ref11 = (0, _slicedToArray3.default)(_ref10, 2),\n          context = _ref11[0],\n          authorization = _ref11[1];\n\n      context.clientInfo.credential.bearer = authorization;\n      return context;\n    });\n  },\n\n  /**\n   * @private\n   * @returns {Promise<Object>}\n   */\n  _getKMSCluster: function _getKMSCluster() {\n    this.logger.info('kms: retrieving KMS cluster');\n    return this._getKMSDetails().then(function (_ref12) {\n      var kmsCluster = _ref12.kmsCluster;\n      return kmsCluster;\n    });\n  },\n\n  /**\n   * @private\n   * @returns {Promise<Object>}\n   */\n  _getKMSDetails: function _getKMSDetails() {\n    var _this12 = this;\n\n    var details = kmsDetails.get(this);\n\n    if (!details) {\n      this.logger.info('kms: fetching KMS details');\n      details = this.spark.request({\n        service: 'encryption',\n        resource: '/kms/' + this.spark.internal.device.userId\n      }).then(function (res) {\n        _this12.logger.info('kms: fetched KMS details');\n\n        var body = res.body;\n        body.rsaPublicKey = JSON.parse(body.rsaPublicKey);\n        return body;\n      }).catch(function (reason) {\n        _this12.logger.error('kms: failed to fetch KMS details', reason);\n\n        return _promise2.default.reject(reason);\n      });\n      kmsDetails.set(this, details);\n    }\n\n    return details;\n  },\n\n  /**\n   * @private\n   * @returns {Promise<Object>}\n   */\n  _getKMSStaticPubKey: function _getKMSStaticPubKey() {\n    this.logger.info('kms: retrieving KMS static public key');\n    return this._getKMSDetails().then(function (_ref13) {\n      var rsaPublicKey = _ref13.rsaPublicKey;\n      return rsaPublicKey;\n    });\n  },\n\n  /**\n   * @private\n   * @returns {Promise<Object>}\n   */\n  _prepareContext: function _prepareContext() {\n    var _this13 = this;\n\n    this.logger.info('kms: creating context');\n    var context = new _nodeKms.Context();\n    return _promise2.default.all([this._getKMSStaticPubKey(), this._getAuthorization()]).then(function (_ref14) {\n      var _ref15 = (0, _slicedToArray3.default)(_ref14, 2),\n          kmsStaticPubKey = _ref15[0],\n          authorization = _ref15[1];\n\n      context.clientInfo = {\n        clientId: _this13.spark.internal.device.url,\n        credential: {\n          userId: _this13.spark.internal.device.userId,\n          bearer: authorization\n        }\n      };\n      context.serverInfo = {\n        key: kmsStaticPubKey\n      };\n\n      _this13.logger.info('kms: creating local ephemeral key');\n\n      return context.createECDHKey();\n    }).then(function (localECDHKey) {\n      context.ephemeralKey = localECDHKey;\n      partialContexts.set(_this13, context);\n      return _promise2.default.all([localECDHKey.asKey(), _this13._getKMSCluster()]);\n    }).then(function (_ref16) {\n      var _ref17 = (0, _slicedToArray3.default)(_ref16, 2),\n          localECDHKey = _ref17[0],\n          cluster = _ref17[1];\n\n      _this13.logger.info('kms: submitting ephemeral key request');\n\n      return _this13.request({\n        uri: cluster + '/ecdhe',\n        method: 'create',\n        jwk: localECDHKey.toJSON()\n      });\n    }).then(function (res) {\n      _this13.logger.info('kms: deriving final ephemeral key');\n\n      return context.deriveEphemeralKey(res.key);\n    }).then(function (key) {\n      context.ephemeralKey = key;\n      partialContexts.delete(_this13);\n\n      _this13.logger.info('kms: derived final ephemeral key');\n\n      return context;\n    }).catch(function (reason) {\n      _this13.logger.error('kms: failed to negotiate ephemeral key', reason);\n\n      return _promise2.default.reject(reason);\n    });\n  },\n\n  /**\n   * KMS 'retrieve' requests can be made on behalf of another user. This is useful\n   * for scenarios such as eDiscovery. i.e. Where an authorized compliance officer is\n   * entitled to retrieve content generated by any organisational user.\n   * As the KMSContext is cached, updating it will affect separate requests. Hence when\n   * making a request onBehalfOf another user create a new context for just this request.\n   * However this context will be 'light' as it only needs to change one field.\n   * @param {Object} originalContext - The base context to 'copy'\n   * @param {String} onBehalfOf - The user specified in the new context\n   * @returns {Context} A 'copy' of the existing context with a new user specified\n   * @private\n   */\n  _contextOnBehalfOf: function _contextOnBehalfOf(originalContext, onBehalfOf) {\n    var context = new _nodeKms.Context();\n    context.clientInfo = context.clientInfo = {\n      clientId: originalContext.clientInfo.clientId,\n      credential: {\n        userId: onBehalfOf,\n        bearer: originalContext.clientInfo.credential.bearer\n      }\n    };\n    context.serverInfo = originalContext.serverInfo;\n    context.ephemeralKey = originalContext.ephemeralKey;\n    return context;\n  },\n  version: '1.59.0'\n}, (_applyDecoratedDescriptor(_obj, 'fetchKey', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'fetchKey'), _obj), _applyDecoratedDescriptor(_obj, '_getContext', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, '_getContext'), _obj)), _obj)));\n\nexports.default = KMS;","map":null,"metadata":{},"sourceType":"script"}