{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.filterEscapeSync = exports.filterEscape = exports.filterSync = exports.filter = exports.escapeSync = exports.escape = undefined;\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _reduce2 = require('lodash/reduce');\n\nvar _reduce3 = _interopRequireDefault(_reduce2);\n\nvar _includes2 = require('lodash/includes');\n\nvar _includes3 = _interopRequireDefault(_includes2);\n\nvar _forEach2 = require('lodash/forEach');\n\nvar _forEach3 = _interopRequireDefault(_forEach2);\n\nvar _curry2 = require('lodash/curry');\n\nvar _curry3 = _interopRequireDefault(_curry2);\n\nvar _htmlBase = require('./html-base');\n\nObject.defineProperty(exports, 'escape', {\n  enumerable: true,\n  get: function get() {\n    return _htmlBase.escape;\n  }\n});\nObject.defineProperty(exports, 'escapeSync', {\n  enumerable: true,\n  get: function get() {\n    return _htmlBase.escapeSync;\n  }\n});\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Some browsers don't implement {@link Element#remove()} or\n * {@link NodeList#remove()} or {@link HTMLCollection#remove()}. This wrapper\n * calls the appropriate `#remove()` method if available, or falls back to a\n * non-global-polluting polyfill.\n * @param {Element|NodeList|HTMLCollection} node\n * @returns {undefined}\n */\n\n\nfunction removeNode(node) {\n  if (node.remove) {\n    node.remove();\n    return;\n  }\n\n  if (node.parentElement) {\n    node.parentElement.removeChild(node);\n    return;\n  }\n\n  if ('length' in node) {\n    for (var i = node.length - 1; i >= 0; i -= 1) {\n      removeNode(node[i]);\n    }\n\n    return;\n  }\n\n  throw new Error('Could not find a way to remove node');\n}\n/**\n * @param {Object} allowedTags\n * @param {Array<string>} allowedStyles\n * @param {string} html\n * @private\n * @returns {string}\n */\n\n\nfunction _filter() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return new _promise2.default(function (resolve) {\n    resolve(_filterSync.apply(undefined, args));\n  });\n}\n/**\n * Curried async HTML filter.\n * @param {Object} allowedTags Map of tagName -> array of allowed attributes\n * @param {Array<string>} allowedStyles Array of allowed styles\n * @param {string} html html to filter\n * @returns {string}\n */\n\n\nvar filter = exports.filter = (0, _curry3.default)(_filter, 4);\n/**\n * @param {function} processCallback callback function to do additional\n * processing on node. of the form process(node)\n * @param {Object} allowedTags\n * @param {Array<string>} allowedStyles\n * @param {string} html\n * @private\n * @returns {string}\n */\n\nfunction _filterSync(processCallback, allowedTags, allowedStyles, html) {\n  if (!html || !allowedStyles || !allowedTags) {\n    if (html.length === 0) {\n      return html;\n    }\n\n    throw new Error('`allowedTags`, `allowedStyles`, and `html` must be provided');\n  }\n\n  var doc = new DOMParser().parseFromString(html, 'text/html');\n  depthFirstForEach(doc.body.childNodes, filterNode);\n  processCallback(doc.body);\n\n  if (html.indexOf('body') === 1) {\n    return '<body>' + doc.body.innerHTML + '</body>';\n  }\n\n  return doc.body.innerHTML;\n  /**\n   * @param {Node} node\n   * @private\n   * @returns {undefined}\n   */\n\n  function filterNode(node) {\n    if (!isElement(node)) {\n      return;\n    }\n\n    var nodeName = node.nodeName.toLowerCase();\n    var allowedTagNames = (0, _keys2.default)(allowedTags);\n    depthFirstForEach(node.childNodes, filterNode);\n\n    if ((0, _includes3.default)(allowedTagNames, nodeName)) {\n      var allowedAttributes = allowedTags[nodeName];\n      (0, _forEach3.default)(listAttributeNames(node.attributes), function (attrName) {\n        if (!(0, _includes3.default)(allowedAttributes, attrName)) {\n          node.removeAttribute(attrName);\n        } else if (attrName === 'href' || attrName === 'src') {\n          var attrValue = node.attributes.getNamedItem(attrName).value.trim().toLowerCase(); // We're doing at runtime what the no-script-url rule does at compile\n          // time\n          // eslint-disable-next-line no-script-url\n\n          if (attrValue.indexOf('javascript:') === 0 || attrValue.indexOf('vbscript:') === 0) {\n            reparent(node);\n          }\n        } else if (attrName === 'style') {\n          var styles = node.attributes.getNamedItem('style').value.split(';').map(function (style) {\n            var styleName = trim(style.split(':')[0]);\n\n            if ((0, _includes3.default)(allowedStyles, styleName)) {\n              return style;\n            }\n\n            return null;\n          }).filter(function (style) {\n            return Boolean(style);\n          }).join(';');\n          node.setAttribute('style', styles);\n        }\n      });\n    } else {\n      reparent(node);\n    }\n  }\n}\n/**\n * Same as _filter, but escapes rather than removes disallowed values\n * @param {Function} processCallback\n * @param {Object} allowedTags\n * @param {Array<string>} allowedStyles\n * @param {string} html\n * @returns {Promise<string>}\n */\n\n\nfunction _filterEscape() {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return new _promise2.default(function (resolve) {\n    resolve(_filterEscapeSync.apply(undefined, args));\n  });\n}\n/**\n * Same as _filterSync, but escapes rather than removes disallowed values\n * @param {Function} processCallback\n * @param {Object} allowedTags\n * @param {Array<string>} allowedStyles\n * @param {string} html\n * @returns {string}\n */\n\n\nfunction _filterEscapeSync(processCallback, allowedTags, allowedStyles, html) {\n  if (!html || !allowedStyles || !allowedTags) {\n    if (html.length === 0) {\n      return html;\n    }\n\n    throw new Error('`allowedTags`, `allowedStyles`, and `html` must be provided');\n  }\n\n  var doc = new DOMParser().parseFromString(html, 'text/html');\n  depthFirstForEach(doc.body.childNodes, filterNode);\n  processCallback(doc.body);\n\n  if (html.indexOf('body') === 1) {\n    return '<body>' + doc.body.innerHTML + '</body>';\n  }\n\n  return doc.body.innerHTML;\n  /**\n   * @param {Node} node\n   * @private\n   * @returns {undefined}\n   */\n\n  function filterNode(node) {\n    if (!isElement(node)) {\n      return;\n    }\n\n    depthFirstForEach(node.childNodes, filterNode);\n    var nodeName = node.nodeName.toLowerCase();\n    var allowedTagNames = (0, _keys2.default)(allowedTags);\n\n    if ((0, _includes3.default)(allowedTagNames, nodeName)) {\n      var allowedAttributes = allowedTags[nodeName];\n      (0, _forEach3.default)(listAttributeNames(node.attributes), function (attrName) {\n        if (!(0, _includes3.default)(allowedAttributes, attrName)) {\n          node.removeAttribute(attrName);\n        } else if (attrName === 'href' || attrName === 'src') {\n          var attrValue = node.attributes.getNamedItem(attrName).value.toLowerCase(); // We're doing at runtime what the no-script-url rule does at compile\n          // time\n          // eslint-disable-next-line no-script-url\n\n          if (attrValue.indexOf('javascript:') === 0 || attrValue.indexOf('vbscript:') === 0) {\n            reparent(node);\n          }\n        } else if (attrName === 'style') {\n          var styles = node.attributes.getNamedItem('style').value.split(';').map(function (style) {\n            var styleName = trim(style.split(':')[0]);\n\n            if ((0, _includes3.default)(allowedStyles, styleName)) {\n              return style;\n            }\n\n            return null;\n          }).filter(function (style) {\n            return Boolean(style);\n          }).join(';');\n          node.setAttribute('style', styles);\n        }\n      });\n    } else {\n      escapeNode(node);\n    }\n  }\n}\n/**\n * Escapes a given html node\n * @param {Node} node\n * @returns {undefined}\n */\n\n\nfunction escapeNode(node) {\n  var before = document.createTextNode('<' + node.nodeName.toLowerCase() + '>');\n  var after = document.createTextNode('</' + node.nodeName.toLowerCase() + '>');\n  node.parentNode.insertBefore(before, node);\n\n  while (node.childNodes.length > 0) {\n    node.parentNode.insertBefore(node.childNodes[0], node);\n  }\n\n  node.parentNode.insertBefore(after, node);\n  removeNode(node);\n}\n\nvar trimPattern = /^\\s|\\s$/g;\n/**\n * @param {string} str\n * @returns {string}\n */\n\nfunction trim(str) {\n  return str.replace(trimPattern, '');\n}\n/**\n * @param {Node} node\n * @private\n * @returns {undefined}\n */\n\n\nfunction reparent(node) {\n  while (node.childNodes.length > 0) {\n    node.parentNode.insertBefore(node.childNodes[0], node);\n  }\n\n  removeNode(node);\n}\n/**\n * @param {NamedNodeMap} attributes\n * @private\n * @returns {Array<string>}\n */\n\n\nfunction listAttributeNames(attributes) {\n  return (0, _reduce3.default)(attributes, function (attrNames, attr) {\n    attrNames.push(attr.name);\n    return attrNames;\n  }, []);\n}\n/**\n * @param {Array} list\n * @param {Function} fn\n * @private\n * @returns {undefined}\n */\n\n\nfunction depthFirstForEach(list, fn) {\n  for (var i = list.length; i >= 0; i -= 1) {\n    fn(list[i]);\n  }\n}\n/**\n * @param {Node} o\n * @private\n * @returns {Boolean}\n */\n\n\nfunction isElement(o) {\n  if (!o) {\n    return false;\n  }\n\n  if (o.ownerDocument === undefined) {\n    return false;\n  }\n\n  if (o.nodeType !== 1) {\n    return false;\n  }\n\n  if (typeof o.nodeName !== 'string') {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Curried HTML filter.\n * @param {Object} allowedTags Map of tagName -> array of allowed attributes\n * @param {Array<string>} allowedStyles Array of allowed styles\n * @param {string} html html to filter\n * @returns {string}\n */\n\n\nvar filterSync = exports.filterSync = (0, _curry3.default)(_filterSync, 4);\n/**\n * Curried HTML filter that escapes rather than removes disallowed tags\n * @param {Object} allowedTags Map of tagName -> array of allowed attributes\n * @param {Array<string>} allowedStyles Array of allowed styles\n * @param {string} html html to filter\n * @returns {Promise<string>}\n */\n\nvar filterEscape = exports.filterEscape = (0, _curry3.default)(_filterEscape, 4);\n/**\n * Curried HTML filter that escapes rather than removes disallowed tags\n * @param {Object} allowedTags Map of tagName -> array of allowed attributes\n * @param {Array<string>} allowedStyles Array of allowed styles\n * @param {string} html html to filter\n * @returns {string}\n */\n\nvar filterEscapeSync = exports.filterEscapeSync = (0, _curry3.default)(_filterEscapeSync, 4);","map":null,"metadata":{},"sourceType":"script"}