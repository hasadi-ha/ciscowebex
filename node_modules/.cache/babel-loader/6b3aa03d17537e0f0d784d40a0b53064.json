{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.levels = undefined;\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');\n\nvar _deleteProperty2 = _interopRequireDefault(_deleteProperty);\n\nvar _entries = require('babel-runtime/core-js/object/entries');\n\nvar _entries2 = _interopRequireDefault(_entries);\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _isString2 = require('lodash/isString');\n\nvar _isString3 = _interopRequireDefault(_isString2);\n\nvar _isObject2 = require('lodash/isObject');\n\nvar _isObject3 = _interopRequireDefault(_isObject2);\n\nvar _isArray2 = require('lodash/isArray');\n\nvar _isArray3 = _interopRequireDefault(_isArray2);\n\nvar _has2 = require('lodash/has');\n\nvar _has3 = _interopRequireDefault(_has2);\n\nvar _cloneDeep2 = require('lodash/cloneDeep');\n\nvar _cloneDeep3 = _interopRequireDefault(_cloneDeep2);\n\nvar _common = require('@webex/common');\n\nvar _webexCore = require('@webex/webex-core');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar precedence = {\n  silent: 0,\n  error: 1,\n  warn: 2,\n  log: 3,\n  info: 4,\n  debug: 5,\n  trace: 6\n};\nvar levels = exports.levels = (0, _keys2.default)(precedence).filter(function (level) {\n  return level !== 'silent';\n});\nvar fallbacks = {\n  error: ['log'],\n  warn: ['error', 'log'],\n  info: ['log'],\n  debug: ['info', 'log'],\n  trace: ['debug', 'info', 'log']\n};\nvar authTokenKeyPattern = /[Aa]uthorization/;\n/**\n * Recursively strips \"authorization\" fields from the specified object\n * @param {Object} object\n * @private\n * @returns {Object}\n */\n\nfunction walkAndFilter(object) {\n  if ((0, _isArray3.default)(object)) {\n    return object.map(walkAndFilter);\n  }\n\n  if (!(0, _isObject3.default)(object)) {\n    if ((0, _isString3.default)(object)) {\n      if (_common.patterns.email.test(object)) {\n        return '-- REDACTED --';\n      }\n    }\n\n    return object;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = (0, _getIterator3.default)((0, _entries2.default)(object)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = (0, _slicedToArray3.default)(_ref, 2);\n\n      var key = _ref2[0];\n      var value = _ref2[1];\n\n      if (authTokenKeyPattern.test(key)) {\n        (0, _deleteProperty2.default)(object, key);\n      } else {\n        object[key] = walkAndFilter(value);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return object;\n}\n/**\n * @class\n */\n\n\nvar Logger = _webexCore.SparkPlugin.extend({\n  namespace: 'Logger',\n  derived: {\n    level: {\n      cache: false,\n      fn: function fn() {\n        return this.getCurrentLevel();\n      }\n    }\n  },\n  session: {\n    buffer: {\n      type: 'array',\n      default: function _default() {\n        return [];\n      }\n    }\n  },\n\n  /**\n   * Ensures auth headers don't get printed in logs\n   * @param {Array<mixed>} args\n   * @private\n   * @memberof Logger\n   * @returns {Array<mixed>}\n   */\n  filter: function filter() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return args.map(function (arg) {\n      // SparkHttpError already ensures auth tokens don't get printed, so, no\n      // need to alter it here.\n      if (arg instanceof Error) {\n        // karma logs won't print subclassed errors correctly, so we need\n        // explicitly call their tostring methods.\n        if (process.env.NODE_ENV === 'test' && _common.inBrowser) {\n          var ret = arg.toString();\n          ret += 'BEGIN STACK';\n          ret += arg.stack;\n          ret += 'END STACK';\n          return ret;\n        }\n\n        return arg;\n      }\n\n      arg = (0, _cloneDeep3.default)(arg);\n      return walkAndFilter(arg);\n    });\n  },\n\n  /**\n   * Determines if the current level allows logs at the specified level to be\n   * printed\n   * @param {string} level\n   * @private\n   * @memberof Logger\n   * @returns {boolean}\n   */\n  shouldPrint: function shouldPrint(level) {\n    return precedence[level] <= precedence[this.getCurrentLevel()];\n  },\n\n  /**\n   * Determines if the current level allows logs at the specified level to be\n   * put into the log buffer. We're configuring it omit trace and debug logs\n   * because there are *a lot* of debug logs that really don't provide value at\n   * runtime (they're helpful for debugging locally, but really just pollute the\n   * uploaded logs and push useful info out).\n   * @param {string} level\n   * @private\n   * @memberof Logger\n   * @returns {boolean}\n   */\n  shouldBuffer: function shouldBuffer(level) {\n    return precedence[level] <= precedence.info;\n  },\n\n  /**\n   * Indicates the current log level based on env vars, feature toggles, and\n   * user type.\n   * @instance\n   * @memberof Logger\n   * @private\n   * @memberof Logger\n   * @returns {string}\n   */\n  // eslint-disable-next-line complexity\n  getCurrentLevel: function getCurrentLevel() {\n    // If a level has been explicitly set via config, alway use it.\n    if (this.config.level) {\n      return this.config.level;\n    }\n\n    if (levels.includes(process.env.CISCOSPARK_LOG_LEVEL)) {\n      return process.env.CISCOSPARK_LOG_LEVEL;\n    } // Always use debug-level logging in test mode;\n\n\n    if (process.env.NODE_ENV === 'test') {\n      return 'trace';\n    } // Use server-side-feature toggles to configure log levels\n\n\n    var level = this.spark.internal.device && this.spark.internal.device.features.developer.get('log-level');\n\n    if (level) {\n      if (levels.includes(level)) {\n        return level;\n      }\n    }\n\n    return 'error';\n  },\n  version: '1.59.0'\n});\n\nlevels.forEach(function (level) {\n  var impls = fallbacks[level];\n  var impl = level;\n\n  if (impls) {\n    impls = impls.slice(); // eslint-disable-next-line no-console\n\n    while (!console[impl]) {\n      impl = impls.pop();\n    }\n  } // Much of the complexity in the following function is due to a test-mode-only\n  // helper\n  // eslint-disable-next-line complexity\n\n\n  Logger.prototype[level] = function wrappedConsoleMethod() {\n    try {\n      var shouldPrint = this.shouldPrint(level);\n      var shouldBuffer = this.shouldBuffer(level);\n\n      if (!shouldBuffer && !shouldPrint) {\n        return;\n      }\n\n      var filtered = this.filter.apply(this, arguments);\n      var stringified = filtered.map(function (item) {\n        if (item instanceof _webexCore.SparkHttpError) {\n          return item.toString();\n        }\n\n        return item;\n      });\n\n      if (shouldPrint) {\n        var _console; // when logging an object in browsers, we tend to get a dynamic\n        // reference, thus going back to look at the logged value doesn't\n        // necessarily show the state at log time, thus we print the stringified\n        // value.\n\n\n        var toPrint = _common.inBrowser ? stringified : filtered;\n        /* istanbul ignore if */\n\n        if (process.env.NODE_ENV === 'test' && (0, _has3.default)(this, 'spark.internal.device.url')) {\n          toPrint.unshift(this.spark.internal.device.url.slice(-3));\n        } // eslint-disable-next-line no-console\n\n\n        (_console = console)[impl].apply(_console, (0, _toConsumableArray3.default)(toPrint));\n      }\n\n      if (shouldBuffer) {\n        stringified.unshift(Date.now());\n        this.buffer.push(stringified);\n\n        if (this.buffer.length > this.config.historyLength) {\n          this.buffer.shift();\n        }\n      }\n    } catch (reason) {\n      /* istanbul ignore next */\n      // eslint-disable-next-line no-console\n      console.warn('failed to execute Logger#' + level, reason);\n    }\n  };\n});\nexports.default = Logger;","map":null,"metadata":{},"sourceType":"script"}