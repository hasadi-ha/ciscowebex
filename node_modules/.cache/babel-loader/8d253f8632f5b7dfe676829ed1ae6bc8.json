{"ast":null,"code":"/*!\n * jwk/rsa.js - RSA Key Representation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\"use strict\";\n\nvar forge = require(\"../deps/forge.js\"),\n    rsau = require(\"../algorithms/rsa-util\"),\n    nodeCrypto = require(\"../algorithms/helpers\").nodeCrypto;\n\nvar JWK = {\n  BaseKey: require(\"./basekey.js\"),\n  helpers: require(\"./helpers.js\")\n};\nvar SIG_ALGS = [\"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\"];\nvar WRAP_ALGS = [\"RSA-OAEP\", \"RSA-OAEP-256\", \"RSA1_5\"];\nvar JWKRsaCfg = {\n  publicKey: function (props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([{\n      name: \"n\",\n      type: \"binary\"\n    }, {\n      name: \"e\",\n      type: \"binary\"\n    }]);\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n\n    if (pk && pk.n && pk.e) {\n      pk.length = pk.n.length * 8;\n    } else {\n      delete pk.e;\n      delete pk.n;\n    }\n\n    return pk;\n  },\n  privateKey: function (props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([{\n      name: \"n\",\n      type: \"binary\"\n    }, {\n      name: \"e\",\n      type: \"binary\"\n    }, {\n      name: \"d\",\n      type: \"binary\"\n    }, {\n      name: \"p\",\n      type: \"binary\"\n    }, {\n      name: \"q\",\n      type: \"binary\"\n    }, {\n      name: \"dp\",\n      type: \"binary\"\n    }, {\n      name: \"dq\",\n      type: \"binary\"\n    }, {\n      name: \"qi\",\n      type: \"binary\"\n    }]);\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n\n    if (pk && pk.d && pk.n && pk.e && pk.p && pk.q && pk.dp && pk.dq && pk.qi) {\n      pk.length = pk.d.length * 8;\n    } else {\n      pk = undefined;\n    }\n\n    return pk;\n  },\n  thumbprint: function (json) {\n    if (json.public) {\n      json = json.public;\n    }\n\n    var fields = {\n      e: json.e,\n      kty: \"RSA\",\n      n: json.n\n    };\n    return fields;\n  },\n  algorithms: function (keys, mode) {\n    switch (mode) {\n      case \"encrypt\":\n      case \"decrypt\":\n        return [];\n\n      case \"wrap\":\n        return keys.public && WRAP_ALGS.slice() || [];\n\n      case \"unwrap\":\n        return keys.private && WRAP_ALGS.slice() || [];\n\n      case \"sign\":\n        return keys.private && SIG_ALGS.slice() || [];\n\n      case \"verify\":\n        return keys.public && SIG_ALGS.slice() || [];\n    }\n\n    return [];\n  },\n  wrapKey: function (alg, keys) {\n    return keys.public;\n  },\n  unwrapKey: function (alg, keys) {\n    return keys.private;\n  },\n  signKey: function (alg, keys) {\n    return keys.private;\n  },\n  verifyKey: function (alg, keys) {\n    return keys.public;\n  },\n  convertToPEM: function (key, isPrivate) {\n    var k = rsau.convertToForge(key, !isPrivate);\n\n    if (!isPrivate) {\n      return forge.pki.publicKeyToPem(k);\n    }\n\n    return forge.pki.privateKeyToPem(k);\n  }\n};\n\nfunction convertBNtoBuffer(bn) {\n  bn = bn.toString(16);\n\n  if (bn.length % 2) {\n    bn = \"0\" + bn;\n  }\n\n  return new Buffer(bn, \"hex\");\n} // Adapted from digitalbaazar/node-forge/js/rsa.js\n\n\nvar validators = {\n  oid: \"1.2.840.113549.1.1.1\",\n  privateKey: {\n    name: \"RSAPrivateKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      // Version (INTEGER)\n      name: \"RSAPrivateKey.version\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"version\"\n    }, {\n      // modulus (n)\n      name: \"RSAPrivateKey.modulus\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"n\"\n    }, {\n      // publicExponent (e)\n      name: \"RSAPrivateKey.publicExponent\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"e\"\n    }, {\n      // privateExponent (d)\n      name: \"RSAPrivateKey.privateExponent\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"d\"\n    }, {\n      // prime1 (p)\n      name: \"RSAPrivateKey.prime1\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"p\"\n    }, {\n      // prime2 (q)\n      name: \"RSAPrivateKey.prime2\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"q\"\n    }, {\n      // exponent1 (d mod (p-1))\n      name: \"RSAPrivateKey.exponent1\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"dp\"\n    }, {\n      // exponent2 (d mod (q-1))\n      name: \"RSAPrivateKey.exponent2\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"dq\"\n    }, {\n      // coefficient ((inverse of q) mod p)\n      name: \"RSAPrivateKey.coefficient\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"qi\"\n    }]\n  },\n  publicKey: {\n    // RSAPublicKey\n    name: \"RSAPublicKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      // modulus (n)\n      name: \"RSAPublicKey.modulus\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"n\"\n    }, {\n      // publicExponent (e)\n      name: \"RSAPublicKey.exponent\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"e\"\n    }]\n  }\n}; // Factory\n\nvar JWKRsaFactory = {\n  kty: \"RSA\",\n  validators: validators,\n  prepare: function (props) {\n    // TODO: validate key properties\n    var cfg = JWKRsaCfg;\n    var p = Promise.resolve(props);\n    p = p.then(function (json) {\n      return JWK.helpers.thumbprint(cfg, json);\n    });\n    p = p.then(function (hash) {\n      var prints = {};\n      prints[JWK.helpers.INTERNALS.THUMBPRINT_HASH] = hash;\n      props[JWK.helpers.INTERNALS.THUMBPRINT_KEY] = prints;\n      return cfg;\n    });\n    return p;\n  },\n  generate: function (size) {\n    // TODO: validate key sizes\n    var promise;\n\n    if (nodeCrypto) {\n      promise = new Promise(function (resolve, reject) {\n        forge.pki.rsa.generateKeyPair({\n          bits: size,\n          e: 0x010001\n        }, function (err, key) {\n          if (err) return reject(err);\n          resolve(key.privateKey);\n        });\n      });\n    } else {\n      var key = forge.pki.rsa.generateKeyPair({\n        bits: size,\n        e: 0x010001\n      });\n      promise = Promise.resolve(key.privateKey);\n    }\n\n    ;\n    return promise.then(function (key) {\n      // convert to JSON-ish\n      var result = {};\n      [\"e\", \"n\", \"d\", \"p\", \"q\", {\n        incoming: \"dP\",\n        outgoing: \"dp\"\n      }, {\n        incoming: \"dQ\",\n        outgoing: \"dq\"\n      }, {\n        incoming: \"qInv\",\n        outgoing: \"qi\"\n      }].forEach(function (f) {\n        var incoming, outgoing;\n\n        if (\"string\" === typeof f) {\n          incoming = outgoing = f;\n        } else {\n          incoming = f.incoming;\n          outgoing = f.outgoing;\n        }\n\n        if (incoming in key) {\n          result[outgoing] = convertBNtoBuffer(key[incoming]);\n        }\n      });\n      return result;\n    });\n  },\n  import: function (input) {\n    if (validators.oid !== input.keyOid) {\n      return null;\n    }\n\n    if (!input.parsed) {\n      // coerce capture.keyValue to DER\n      if (\"string\" === typeof input.keyValue) {\n        input.keyValue = forge.asn1.fromDer(input.keyValue);\n      } else if (Array.isArray(input.keyValue)) {\n        input.keyValue = input.keyValue[0];\n      } // capture key factors\n\n\n      var validator = \"private\" === input.type ? validators.privateKey : validators.publicKey;\n      var capture = {},\n          errors = [];\n\n      if (!forge.asn1.validate(input.keyValue, validator, capture, errors)) {\n        return null;\n      }\n\n      input = capture;\n    } // convert factors to Buffers\n\n\n    var output = {\n      kty: \"RSA\"\n    };\n    [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"].forEach(function (f) {\n      if (!(f in input)) {\n        return;\n      }\n\n      var b = new Buffer(input[f], \"binary\"); // remove leading zero padding if any\n\n      if (0 === b[0]) {\n        b = b.slice(1);\n      }\n\n      output[f] = b;\n    });\n    return output;\n  }\n}; // public API\n\nmodule.exports = Object.freeze({\n  config: JWKRsaCfg,\n  factory: JWKRsaFactory\n}); // registration\n\n(function (REGISTRY) {\n  REGISTRY.register(JWKRsaFactory);\n})(require(\"./keystore\").registry);","map":null,"metadata":{},"sourceType":"script"}