{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _uniq2 = require('lodash/uniq');\n\nvar _uniq3 = _interopRequireDefault(_uniq2);\n\nvar _pick2 = require('lodash/pick');\n\nvar _pick3 = _interopRequireDefault(_pick2);\n\nvar _omit2 = require('lodash/omit');\n\nvar _omit3 = _interopRequireDefault(_omit2);\n\nvar _merge2 = require('lodash/merge');\n\nvar _merge3 = _interopRequireDefault(_merge2);\n\nvar _map2 = require('lodash/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _last2 = require('lodash/last');\n\nvar _last3 = _interopRequireDefault(_last2);\n\nvar _isString2 = require('lodash/isString');\n\nvar _isString3 = _interopRequireDefault(_isString2);\n\nvar _isObject2 = require('lodash/isObject');\n\nvar _isObject3 = _interopRequireDefault(_isObject2);\n\nvar _isArray2 = require('lodash/isArray');\n\nvar _isArray3 = _interopRequireDefault(_isArray2);\n\nvar _defaults2 = require('lodash/defaults');\n\nvar _defaults3 = _interopRequireDefault(_defaults2);\n\nvar _cloneDeep2 = require('lodash/cloneDeep');\n\nvar _cloneDeep3 = _interopRequireDefault(_cloneDeep2);\n\nvar _querystring = require('querystring');\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nvar _events = require('events');\n\nvar _common = require('@webex/common');\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _helperImage = require('@webex/helper-image');\n\nvar _uuid = require('uuid');\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nvar _convoError = require('./convo-error');\n\nvar _shareActivity = require('./share-activity');\n\nvar _shareActivity2 = _interopRequireDefault(_shareActivity);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar Conversation = _webexCore.SparkPlugin.extend({\n  namespace: 'Conversation',\n  acknowledge: function acknowledge(conversation, object, activity) {\n    var _this = this;\n\n    if (!(0, _isObject3.default)(object)) {\n      return _promise2.default.reject(new Error('`object` must be an object'));\n    }\n\n    return this._inferConversationUrl(conversation).then(function () {\n      return _this.prepare(activity, {\n        verb: 'acknowledge',\n        target: _this.prepareConversation(conversation),\n        object: {\n          objectType: 'activity',\n          id: object.id,\n          url: object.url\n        }\n      });\n    }).then(function (a) {\n      return _this.submit(a);\n    });\n  },\n\n  /**\n   * Adds a participant to a conversation\n   * @param {Object} conversation\n   * @param {Object|string} participant\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @returns {Promise<Activity>}\n   */\n  add: function add(conversation, participant, activity) {\n    var _this2 = this;\n\n    return this._inferConversationUrl(conversation).then(function () {\n      return _this2.spark.internal.user.asUUID(participant, {\n        create: true\n      });\n    }).then(function (id) {\n      return _this2.prepare(activity, {\n        verb: 'add',\n        target: _this2.prepareConversation(conversation),\n        object: {\n          id: id,\n          objectType: 'person'\n        },\n        kmsMessage: {\n          method: 'create',\n          uri: '/authorizations',\n          resourceUri: '<KRO>',\n          userIds: [id]\n        }\n      }).then(function (a) {\n        return _this2.submit(a);\n      });\n    });\n  },\n\n  /**\n   * Creates a conversation\n   * @param {Object} params\n   * @param {Array<Participant>} params.participants\n   * @param {Array<File>} params.files\n   * @param {string} params.comment\n   * @param {string} params.html\n   * @param {Object} params.displayName\n   * @param {Object} options\n   * @param {Boolean} options.allowPartialCreation\n   * @param {Boolean} options.forceGrouped\n   * @param {Boolean} options.skipOneOnOneFetch skips checking 1:1 exists before creating conversation\n   * @returns {Promise<Conversation>}\n   */\n  create: function create(params, options) {\n    var _this3 = this;\n\n    options = options || {};\n\n    if (!params.participants || params.participants.length === 0) {\n      return _promise2.default.reject(new Error('`params.participants` is required'));\n    }\n\n    return _promise2.default.all(params.participants.map(function (participant) {\n      return _this3.spark.internal.user.asUUID(participant, {\n        create: true\n      }) // eslint-disable-next-line arrow-body-style\n      .catch(function (err) {\n        return options.allowPartialCreation ? undefined : _promise2.default.reject(err);\n      });\n    })).then(function (participants) {\n      participants.unshift(_this3.spark.internal.device.userId);\n      participants = (0, _uniq3.default)(participants);\n      var validParticipants = participants.filter(function (participant) {\n        return participant;\n      });\n      params.participants = validParticipants; // check if original participants list was to create a 1:1\n\n      if (participants.length === 2 && !(options && options.forceGrouped)) {\n        if (!params.participants[1]) {\n          return _promise2.default.reject(new _convoError.InvalidUserCreation());\n        }\n\n        if (options.skipOneOnOneFetch) {\n          return _this3._createOneOnOne(params);\n        }\n\n        return _this3._maybeCreateOneOnOneThenPost(params, options);\n      }\n\n      return _this3._createGrouped(params, options);\n    }).then(function (c) {\n      if (!params.files) {\n        return c;\n      }\n\n      return _this3.spark.internal.conversation.share(c, params.files).then(function (a) {\n        c.activities.items.push(a);\n        return c;\n      });\n    });\n  },\n  delete: function _delete(conversation, object, activity) {\n    var _this4 = this;\n\n    if (!(0, _isObject3.default)(object)) {\n      return _promise2.default.reject(new Error('`object` must be an object'));\n    }\n\n    return this._inferConversationUrl(conversation).then(function () {\n      return _this4.prepare(activity, {\n        verb: 'delete',\n        target: _this4.prepareConversation(conversation),\n        object: (0, _pick3.default)(object, 'id', 'url', 'objectType')\n      });\n    }).then(function (a) {\n      return _this4.submit(a);\n    });\n  },\n\n  /**\n   * Downloads the file specified in item.scr or item.url\n   * @param {Object} item\n   * @param {Object} item.scr\n   * @param {string} item.url\n   * @param {Object} options\n   * @param {Object} options.headers\n   * @returns {Promise<File>}\n   */\n  download: function download(item, options) {\n    var _this5 = this;\n\n    var isEncrypted = Boolean(item.scr && item.scr.key);\n    var shunt = new _events.EventEmitter();\n    var promise = void 0;\n\n    if (isEncrypted) {\n      promise = this.spark.internal.encryption.download(item.scr);\n    } else if (item.scr && item.scr.loc) {\n      promise = this._downloadUnencryptedFile(item.scr.loc, options);\n    } else {\n      promise = this._downloadUnencryptedFile(item.url, options);\n    }\n\n    promise = promise.on('progress', function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return shunt.emit.apply(shunt, ['progress'].concat(args));\n    }).then(function (res) {\n      return (0, _helperImage.readExifData)(item, res);\n    }).then(function (file) {\n      _this5.logger.info('conversation: file downloaded');\n\n      if (item.displayName && !file.name) {\n        file.name = item.displayName;\n      }\n\n      if (!file.type && item.mimeType) {\n        file.type = item.mimeType;\n      }\n\n      return file;\n    });\n    (0, _common.proxyEvents)(shunt, promise);\n    return promise;\n  },\n\n  /**\n   * Downloads an unencrypted file\n   * @param {string} uri\n   * @param {Object} options\n   * @param {Ojbect} options.headers\n   * @returns {Promise<File>}\n   */\n  _downloadUnencryptedFile: function _downloadUnencryptedFile(uri, options) {\n    options = options || {};\n    (0, _assign2.default)(options, {\n      uri: uri,\n      responseType: 'buffer'\n    });\n    var promise = this.request(options).then(function (res) {\n      return res.body;\n    });\n    (0, _common.proxyEvents)(options.download, promise);\n    return promise;\n  },\n\n  /**\n   * Helper method that expands a set of parameters into an activty object\n   * @param {string} verb\n   * @param {Object} object\n   * @param {Object} target\n   * @param {Object|string} actor\n   * @returns {Object}\n   */\n  expand: function expand(verb, object, target, actor) {\n    var activity = {\n      actor: actor,\n      objectType: 'activity',\n      verb: verb\n    };\n\n    if (!actor) {\n      actor = this.spark.internal.device.userId;\n    }\n\n    if ((0, _isString3.default)(actor)) {\n      activity.actor = {\n        objectType: 'person',\n        id: actor\n      };\n    }\n\n    if (object) {\n      activity.object = object;\n    }\n\n    if (target) {\n      activity.target = target;\n    }\n\n    return activity;\n  },\n\n  /**\n   * Fetches a single conversation\n   * @param {Object} conversation\n   * @param {Object} options\n   * @returns {Promise<Conversation>}\n   */\n  get: function get(conversation, options) {\n    var _this6 = this;\n\n    return this._inferConversationUrl(conversation).then(function () {\n      var user = conversation.user,\n          url = conversation.url;\n      options = options || {};\n      var params = {\n        qs: (0, _assign2.default)({\n          uuidEntryFormat: true,\n          personRefresh: true,\n          activitiesLimit: 0,\n          includeConvWithDeletedUserUUID: false,\n          includeParticipants: false\n        }, (0, _omit3.default)(options, 'id', 'user', 'url'))\n      }; // Default behavior is to set includeParticipants=false,\n      // which makes the payload lighter by removing participant info.\n      // If the caller explicitly sets the participantAckFilter or\n      // participantsLimit, we don't want that default setting.\n\n      if ('participantAckFilter' in options || 'participantsLimit' in options) {\n        delete params.qs.includeParticipants;\n      }\n\n      return _promise2.default.resolve(user ? _this6.spark.internal.user.asUUID(user) : null).then(function (userId) {\n        if (userId) {\n          (0, _assign2.default)(params, {\n            service: 'conversation',\n            resource: 'conversations/user/' + userId\n          });\n        } else {\n          params.uri = url;\n        }\n\n        return _this6.request(params);\n      });\n    }).then((0, _common.tap)(function (res) {\n      return _this6._recordUUIDs(res.body);\n    })).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * Leaves the conversation or removes the specified user from the specified\n   * conversation\n   * @param {Object} conversation\n   * @param {Object|string} participant If not specified, defaults to current\n   * user\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @returns {Promise<Activity>}\n   */\n  leave: function leave(conversation, participant, activity) {\n    var _this7 = this;\n\n    return this._inferConversationUrl(conversation).then(function () {\n      if (!participant) {\n        participant = _this7.spark.internal.device.userId;\n      }\n\n      return _this7.spark.internal.user.asUUID(participant).then(function (id) {\n        return _this7.prepare(activity, {\n          verb: 'leave',\n          target: _this7.prepareConversation(conversation),\n          object: {\n            id: id,\n            objectType: 'person'\n          },\n          kmsMessage: {\n            method: 'delete',\n            uri: '<KRO>/authorizations?' + _querystring2.default.stringify({\n              authId: id\n            })\n          }\n        });\n      });\n    }).then(function (a) {\n      return _this7.submit(a);\n    });\n  },\n\n  /**\n   * Lists a set of conversations. By default does not fetch activities or\n   * participants\n   * @param {Object} options\n   * @param {boolean} options.deferDecrypt - when true, deferDecrypt tells the\n   * payload transformer to normalize (but not decrypt) each received\n   * conversation. Instead, the received conversations will each have a bound\n   * decrypt method that can be executed at the consumer's leisure\n   * @returns {Promise<Array<Conversation>>}\n   */\n  list: function list(options) {\n    return this._list({\n      service: 'conversation',\n      resource: 'conversations',\n      qs: (0, _omit3.default)(options, 'deferDecrypt'),\n      deferDecrypt: options.deferDecrypt\n    });\n  },\n\n  /**\n   * Lists the conversations the current user has left. By default does not\n   * fetch activities or participants\n   * @param {Object} options\n   * @returns {Promise<Array<Conversation>>}\n   */\n  listLeft: function listLeft(options) {\n    return this._list({\n      service: 'conversation',\n      resource: 'conversations/left',\n      qs: options\n    });\n  },\n\n  /**\n   * List activities for the specified conversation\n   * @param {Object} options\n   * @returns {Promise<Array<Activity>>}\n   */\n  listActivities: function listActivities(options) {\n    return this._listActivities((0, _assign2.default)(options, {\n      mentions: false\n    }));\n  },\n\n  /**\n   * Lists activities in which the current user was mentioned\n   * @param {Object} options\n   * @returns {Promise<Array<Activity>>}\n   */\n  listMentions: function listMentions(options) {\n    return this._listActivities((0, _assign2.default)(options, {\n      mentions: true\n    }));\n  },\n\n  /**\n   * Mutes the mentions of a conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  muteMentions: function muteMentions(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['MENTION_NOTIFICATIONS_OFF']\n    }, activity);\n  },\n\n  /**\n   * Mutes the messages of a conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  muteMessages: function muteMessages(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['MESSAGE_NOTIFICATIONS_OFF']\n    }, activity);\n  },\n  cardAction: function cardAction(conversation, inputs, parentActivity) {\n    var _this8 = this;\n\n    var activity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    activity.parent = {\n      id: parentActivity.id,\n      type: 'cardAction'\n    };\n    return this._inferConversationUrl(conversation).then(function () {\n      return _this8.prepare(activity, {\n        verb: 'cardAction',\n        target: _this8.prepareConversation(conversation),\n        object: (0, _assign2.default)({\n          objectType: 'submit'\n        }, inputs)\n      });\n    }).then(function (a) {\n      return _this8.submit(a);\n    });\n  },\n\n  /**\n   * Posts a message to a conversation\n   * @param {Object} conversation\n   * @param {Object|string} message if string, treated as plaintext; if object,\n   * assumed to be object property of `post` activity\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @returns {Promise<Activity>}\n   */\n  post: function post(conversation, message, activity) {\n    var _this9 = this;\n\n    if ((0, _isString3.default)(message)) {\n      message = {\n        displayName: message\n      };\n    }\n\n    return this._inferConversationUrl(conversation).then(function () {\n      return _this9.prepare(activity, {\n        verb: 'post',\n        target: _this9.prepareConversation(conversation),\n        object: (0, _assign2.default)({\n          objectType: 'comment'\n        }, message)\n      });\n    }).then(function (a) {\n      return _this9.submit(a);\n    });\n  },\n  prepareConversation: function prepareConversation(conversation) {\n    return (0, _defaults3.default)((0, _pick3.default)(conversation, 'id', 'url', 'objectType', 'defaultActivityEncryptionKeyUrl', 'kmsResourceObjectUrl'), {\n      objectType: 'conversation'\n    });\n  },\n  prepare: function prepare(activity, params) {\n    var _this10 = this;\n\n    params = params || {};\n    activity = activity || {};\n    return _promise2.default.resolve(activity.prepare ? activity.prepare(params) : activity).then(function (act) {\n      (0, _defaults3.default)(act, {\n        verb: params.verb,\n        kmsMessage: params.kmsMessage,\n        objectType: 'activity',\n        clientTempId: _uuid2.default.v4(),\n        actor: _this10.spark.internal.device.userId\n      }); // Workaround because parent is a reserved props in Ampersand\n\n      if (activity.parentActivityId && activity.activityType || activity.parent && activity.parent.id && activity.parent.type) {\n        act.parent = {\n          id: activity.parentActivityId || activity.parent.id,\n          type: activity.activityType || activity.parent.type\n        };\n      }\n\n      if ((0, _isString3.default)(act.actor)) {\n        act.actor = {\n          objectType: 'person',\n          id: act.actor\n        };\n      }\n\n      ['actor', 'object'].forEach(function (key) {\n        if (params[key]) {\n          act[key] = act[key] || {};\n          (0, _defaults3.default)(act[key], params[key]);\n        }\n      });\n\n      if (params.target) {\n        (0, _merge3.default)(act, {\n          target: (0, _pick3.default)(params.target, 'id', 'url', 'objectType', 'kmsResourceObjectUrl', 'defaultActivityEncryptionKeyUrl')\n        });\n      }\n\n      ['object', 'target'].forEach(function (key) {\n        if (act[key] && act[key].url && !act[key].id) {\n          act[key].id = act[key].url.split('/').pop();\n        }\n      });\n      ['actor', 'object', 'target'].forEach(function (key) {\n        if (act[key] && !act[key].objectType) {\n          // Reminder: throwing here because it's the only way to get out of\n          // this loop in event of an error.\n          throw new Error('`act.' + key + '.objectType` must be defined');\n        }\n      });\n\n      if (act.object && act.object.content && !act.object.displayName) {\n        return _promise2.default.reject(new Error('Cannot submit activity object with `content` but no `displayName`'));\n      }\n\n      return act;\n    });\n  },\n\n  /**\n   * Handles incoming conversation.activity mercury messages\n   * @param {Event} event\n   * @returns {Promise}\n   */\n  processActivityEvent: function processActivityEvent(event) {\n    return this.spark.transform('inbound', event).then(function () {\n      return event;\n    });\n  },\n\n  /**\n   * Removes all mute-related tags\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  removeAllMuteTags: function removeAllMuteTags(conversation, activity) {\n    return this.untag(conversation, {\n      tags: ['MENTION_NOTIFICATIONS_OFF', 'MENTION_NOTIFICATIONS_ON', 'MESSAGE_NOTIFICATIONS_OFF', 'MESSAGE_NOTIFICATIONS_ON']\n    }, activity);\n  },\n\n  /**\n   * Creates a ShareActivty for the specified conversation\n   * @param {Object} conversation\n   * @param {Object} activity\n   * @returns {ShareActivty}\n   */\n  makeShare: function makeShare(conversation, activity) {\n    // if we pass activity as null then it does not take care of the\n    // clientTempId created by the web-client while making the provisional\n    // activity, hence we need to pass the activity which was created by the\n    // web-client. This fixes the issue where the image activities do not come\n    // back properly oriented from the server since the clientTempId is missing\n    return _shareActivity2.default.create(conversation, activity, this.spark);\n  },\n\n  /**\n   * Assigns an avatar to a room\n   * @param {Object} conversation\n   * @param {File} avatar\n   * @returns {Promise<Activity>}\n   */\n  assign: function assign(conversation, avatar) {\n    var _this11 = this;\n\n    if ((avatar.size || avatar.length) > 1024 * 1024) {\n      return _promise2.default.reject(new Error('Room avatars must be less than 1MB'));\n    }\n\n    return this._inferConversationUrl(conversation).then(function () {\n      var activity = _shareActivity2.default.create(conversation, null, _this11.spark);\n\n      activity.enableThumbnails = false;\n      activity.add(avatar);\n      return _this11.prepare(activity, {\n        target: _this11.prepareConversation(conversation)\n      });\n    }).then(function (a) {\n      // yes, this seems a little hacky; will likely be resolved as a result\n      // of #213\n      a.verb = 'assign';\n      return _this11.submit(a);\n    });\n  },\n\n  /**\n   * Sets the typing status of the current user in a conversation\n   *\n   * @param {Object} conversation\n   * @param {Object} options\n   * @param {boolean} options.typing\n   * @returns {Promise}\n   */\n  updateTypingStatus: function updateTypingStatus(conversation, options) {\n    if (!conversation.id) {\n      if (conversation.url) {\n        conversation.id = conversation.url.split('/').pop();\n      } else {\n        return _promise2.default.reject(new Error('conversation: could not identify conversation'));\n      }\n    }\n\n    var eventType = void 0;\n\n    if (options.typing) {\n      eventType = 'status.start_typing';\n    } else {\n      eventType = 'status.stop_typing';\n    }\n\n    var params = {\n      method: 'POST',\n      service: 'conversation',\n      resource: 'status/typing',\n      body: {\n        conversationId: conversation.id,\n        eventType: eventType\n      }\n    };\n    return this.request(params);\n  },\n\n  /**\n   * Shares files to the specified converstion\n   * @param {Object} conversation\n   * @param {ShareActivity|Array<File>} activity\n   * @returns {Promise<Activity>}\n   */\n  share: function share(conversation, activity) {\n    var _this12 = this;\n\n    if ((0, _isArray3.default)(activity)) {\n      activity = {\n        object: {\n          files: activity\n        }\n      };\n    }\n\n    return this._inferConversationUrl(conversation).then(function () {\n      if (!(activity instanceof _shareActivity2.default)) {\n        activity = _shareActivity2.default.create(conversation, activity, _this12.spark);\n      }\n\n      return _this12.prepare(activity, {\n        target: _this12.prepareConversation(conversation)\n      });\n    }).then(function (a) {\n      return _this12.submit(a);\n    });\n  },\n\n  /**\n   * Submits an activity to the conversation service\n   * @param {Object} activity\n   * @returns {Promise<Activity>}\n   */\n  submit: function submit(activity) {\n    var params = {\n      method: 'POST',\n      service: 'conversation',\n      resource: activity.verb === 'share' ? 'content' : 'activities',\n      body: activity,\n      qs: {\n        personRefresh: true\n      }\n    };\n\n    if (activity.verb === 'share') {\n      (0, _assign2.default)(params.qs, {\n        transcode: true,\n        async: false\n      });\n    } // triggers user-activity to reset logout timer\n\n\n    this.spark.trigger('user-activity');\n    return this.request(params).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * Remove the avatar from a room\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise}\n   */\n  unassign: function unassign(conversation, activity) {\n    var _this13 = this;\n\n    return this._inferConversationUrl(conversation).then(function () {\n      return _this13.prepare(activity, {\n        verb: 'unassign',\n        target: _this13.prepareConversation(conversation),\n        object: {\n          objectType: 'content',\n          files: {\n            items: []\n          }\n        }\n      });\n    }).then(function (a) {\n      return _this13.submit(a);\n    });\n  },\n\n  /**\n   * Mutes the mentions of a conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  unmuteMentions: function unmuteMentions(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['MENTION_NOTIFICATIONS_ON']\n    }, activity);\n  },\n\n  /**\n   * Mutes the messages of a conversation\n   * @param {Conversation~ConversationObject} conversation\n   * @param {Conversation~ActivityObject} activity\n   * @returns {Promise} Resolves with the created activity\n   */\n  unmuteMessages: function unmuteMessages(conversation, activity) {\n    return this.tag(conversation, {\n      tags: ['MESSAGE_NOTIFICATIONS_ON']\n    }, activity);\n  },\n  update: function update(conversation, object, activity) {\n    var _this14 = this;\n\n    if (!(0, _isObject3.default)(object)) {\n      return _promise2.default.reject(new Error('`object` must be an object'));\n    }\n\n    return this._inferConversationUrl(conversation).then(function () {\n      return _this14.prepare(activity, {\n        verb: 'update',\n        target: _this14.prepareConversation(conversation),\n        object: object\n      });\n    }).then(function (a) {\n      return _this14.submit(a);\n    });\n  },\n\n  /**\n   * Sets a new key for the conversation\n   * @param {Object} conversation\n   * @param {Key|string} key (optional)\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @returns {Promise<Activity>}\n   */\n  updateKey: function updateKey(conversation, key, activity) {\n    var _this15 = this;\n\n    return this._inferConversationUrl(conversation).then(function () {\n      return _this15.get(conversation, {\n        activitiesLimit: 0,\n        includeParticipants: true\n      });\n    }).then(function (c) {\n      return _this15._updateKey(c, key, activity);\n    });\n  },\n\n  /**\n   * Sets a new key for the conversation\n   * @param {Object} conversation\n   * @param {Key|string} key (optional)\n   * @param {Object} activity Reference to the activity that will eventually be\n   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a\n   * provisional activity\n   * @private\n   * @returns {Promise<Activity>}\n   */\n  _updateKey: function _updateKey(conversation, key, activity) {\n    var _this16 = this;\n\n    return _promise2.default.resolve(key || this.spark.internal.encryption.kms.createUnboundKeys({\n      count: 1\n    })).then(function (keys) {\n      var k = (0, _isArray3.default)(keys) ? keys[0] : keys;\n      var params = {\n        verb: 'updateKey',\n        target: _this16.prepareConversation(conversation),\n        object: {\n          defaultActivityEncryptionKeyUrl: k.uri,\n          objectType: 'conversation'\n        }\n      }; // Reminder: the kmsResourceObjectUrl is only usable if there is\n      // defaultActivityEncryptionKeyUrl.\n\n      if (conversation.defaultActivityEncryptionKeyUrl) {\n        params.kmsMessage = {\n          method: 'update',\n          resourceUri: '<KRO>',\n          uri: k.uri\n        };\n      } else {\n        params.kmsMessage = {\n          method: 'create',\n          uri: '/resources',\n          userIds: (0, _map3.default)(conversation.participants.items, 'id'),\n          keyUris: [k.uri]\n        };\n      }\n\n      return _this16.prepare(activity, params).then(function (a) {\n        return _this16.submit(a);\n      });\n    });\n  },\n\n  /**\n   * @param {Object} payload\n   * @param {Object} options\n   * @private\n   * @returns {Promise<Activity>}\n   */\n  _create: function _create(payload, options) {\n    options = options || {};\n    return this.request({\n      method: 'POST',\n      service: 'conversation',\n      resource: 'conversations',\n      body: payload,\n      qs: {\n        forceCreate: options.allowPartialCreation\n      }\n    }).then(function (res) {\n      return res.body;\n    });\n  },\n\n  /**\n   * @param {Object} params\n   * @param {Object} options\n   * @private\n   * @returns {Promise}\n   */\n  _createGrouped: function _createGrouped(params, options) {\n    return this._create(this._prepareConversationForCreation(params), options);\n  },\n\n  /**\n   * @param {Object} params\n   * @param {Object} options\n   * @private\n   * @returns {Promise}\n   */\n  _createOneOnOne: function _createOneOnOne(params) {\n    var payload = this._prepareConversationForCreation(params);\n\n    payload.tags = ['ONE_ON_ONE'];\n    return this._create(payload);\n  },\n\n  /**\n   * @param {Object} conversation\n   * @private\n   * @returns {Promise}\n   */\n  _inferConversationUrl: function _inferConversationUrl(conversation) {\n    var _this17 = this;\n\n    if (conversation.id) {\n      return this.spark.internal.feature.getFeature('developer', 'web-high-availability').then(function (haMessagingEnabled) {\n        if (haMessagingEnabled) {\n          // recompute conversation URL each time as the host may have changed\n          // since last usage\n          return _this17.spark.internal.device.getServiceUrl('conversation').then(function (url) {\n            conversation.url = url + '/conversations/' + conversation.id;\n            return conversation;\n          });\n        }\n\n        if (!conversation.url) {\n          return _this17.spark.internal.device.getServiceUrl('conversation').then(function (url) {\n            conversation.url = url + '/conversations/' + conversation.id;\n            /* istanbul ignore else */\n\n            if (process.env.NODE_ENV !== 'production') {\n              _this17.logger.warn('conversation: inferred conversation url from conversation id; please pass whole conversation objects to Conversation methods');\n            }\n\n            return conversation;\n          });\n        }\n\n        return _promise2.default.resolve(conversation);\n      });\n    }\n\n    return _promise2.default.resolve(conversation);\n  },\n\n  /**\n   * @param {Object} options\n   * @private\n   * @returns {Promise<Array<Activity>>}\n   */\n  _listActivities: function _listActivities(options) {\n    return this._list({\n      service: 'conversation',\n      resource: options.mentions ? 'mentions' : 'activities',\n      qs: (0, _omit3.default)(options, 'mentions')\n    });\n  },\n\n  /**\n   * @param {Object} options\n   * @private\n   * @returns {Promise<Array<Conversation>>}\n   */\n  _list: function _list(options) {\n    var _this18 = this;\n\n    options.qs = (0, _assign2.default)({\n      personRefresh: true,\n      uuidEntryFormat: true,\n      activitiesLimit: 0,\n      participantsLimit: 0\n    }, options.qs);\n    return this.request(options).then(function (res) {\n      if (!res.body || !res.body.items || res.body.items.length === 0) {\n        return [];\n      }\n\n      var items = res.body.items;\n\n      if ((0, _last3.default)(items).published < items[0].published) {\n        items.reverse();\n      }\n\n      return _promise2.default.all(items.map(function (item) {\n        return _this18._recordUUIDs(item);\n      })) // eslint-disable-next-line max-nested-callbacks\n      .then(function () {\n        return items;\n      });\n    });\n  },\n\n  /**\n   * @param {Object} params\n   * @param {Object} options\n   * @private\n   * @returns {Promise<Conversation>}\n   */\n  _maybeCreateOneOnOneThenPost: function _maybeCreateOneOnOneThenPost(params, options) {\n    var _this19 = this;\n\n    return this.get((0, _defaults3.default)({\n      // the use of uniq in Conversation#create guarantees participant[1] will\n      // always be the other user\n      user: params.participants[1]\n    }), (0, _assign2.default)(options, {\n      includeConvWithDeletedUserUUID: true,\n      includeParticipants: true\n    })).then(function (conversation) {\n      if (params.comment || params.html) {\n        return _this19.post(conversation, {\n          content: params.html,\n          displayName: params.comment\n        }).then(function (activity) {\n          conversation.activities.items.push(activity);\n          return conversation;\n        });\n      }\n\n      return conversation;\n    }).catch(function (reason) {\n      if (reason.statusCode !== 404) {\n        return _promise2.default.reject(reason);\n      }\n\n      return _this19._createOneOnOne(params);\n    });\n  },\n\n  /**\n   * @param {Object} params\n   * @private\n   * @returns {Object}\n   */\n  _prepareConversationForCreation: function _prepareConversationForCreation(params) {\n    var _this20 = this;\n\n    var payload = {\n      activities: {\n        items: [this.expand('create')]\n      },\n      objectType: 'conversation',\n      kmsMessage: {\n        method: 'create',\n        uri: '/resources',\n        userIds: (0, _cloneDeep3.default)(params.participants),\n        keyUris: []\n      }\n    };\n\n    if (params.displayName) {\n      payload.displayName = params.displayName;\n    }\n\n    params.participants.forEach(function (participant) {\n      payload.activities.items.push(_this20.expand('add', {\n        objectType: 'person',\n        id: participant\n      }));\n    });\n\n    if (params.comment) {\n      payload.activities.items.push(this.expand('post', {\n        objectType: 'comment',\n        content: params.html,\n        displayName: params.comment\n      }));\n    }\n\n    return payload;\n  },\n\n  /**\n   * @param {Object} conversation\n   * @private\n   * @returns {Promise}\n   */\n  _recordUUIDs: function _recordUUIDs(conversation) {\n    var _this21 = this;\n\n    if (!conversation.participants || !conversation.participants.items) {\n      return _promise2.default.resolve(conversation);\n    }\n\n    return _promise2.default.all(conversation.participants.items.map(function (participant) {\n      // ROOMs do not have email addresses, so there's no point attempting to\n      // record their UUIDs.\n      if (participant.type === 'ROOM') {\n        return _promise2.default.resolve();\n      }\n\n      return _this21.spark.internal.user.recordUUID(participant).catch(function (err) {\n        return _this21.logger.warn('Could not record uuid for ' + (participant.id || participant.entryUUID), err);\n      });\n    }));\n  },\n  version: '1.59.0'\n});\n\n['favorite', 'hide', 'lock', 'mute', 'unfavorite', 'unhide', 'unlock', 'unmute'].forEach(function (verb) {\n  Conversation.prototype[verb] = function submitSimpleActivity(conversation, activity) {\n    var _this22 = this;\n\n    return this._inferConversationUrl(conversation).then(function () {\n      return _this22.prepare(activity, {\n        verb: verb,\n        object: _this22.prepareConversation(conversation)\n      });\n    }).then(function (a) {\n      return _this22.submit(a);\n    });\n  };\n});\n['assignModerator', 'unassignModerator'].forEach(function (verb) {\n  Conversation.prototype[verb] = function submitModerationChangeActivity(conversation, moderator, activity) {\n    var _this23 = this;\n\n    return _promise2.default.all([this._inferConversationUrl(conversation), moderator ? this.spark.internal.user.asUUID(moderator) : this.spark.internal.device.userId]).then(function (_ref) {\n      var _ref2 = (0, _slicedToArray3.default)(_ref, 2),\n          c = _ref2[0],\n          userId = _ref2[1];\n\n      return _this23.prepare(activity, {\n        verb: verb,\n        target: _this23.prepareConversation(c),\n        object: {\n          id: userId,\n          objectType: 'person'\n        }\n      });\n    }).then(function (a) {\n      return _this23.submit(a);\n    });\n  };\n});\n/**\n * Sets/unsets space property for convo\n * @param {Object} conversation\n * @param {string} tag\n * @param {Activity} activity\n * @returns {Promise<Activity>}\n */\n\n['setSpaceProperty', 'unsetSpaceProperty'].forEach(function (fnName) {\n  var verb = fnName.startsWith('set') ? 'set' : 'unset';\n\n  Conversation.prototype[fnName] = function submitSpacePropertyActivity(conversation, tag, activity) {\n    var _this24 = this;\n\n    if (!(0, _isString3.default)(tag)) {\n      return _promise2.default.reject(new Error('`tag` must be a string'));\n    }\n\n    return this._inferConversationUrl(conversation).then(function () {\n      return _this24.prepare(activity, {\n        verb: verb,\n        target: _this24.prepareConversation(conversation),\n        object: {\n          tags: [tag],\n          objectType: 'spaceProperty'\n        }\n      });\n    }).then(function (a) {\n      return _this24.submit(a);\n    });\n  };\n});\n['tag', 'untag'].forEach(function (verb) {\n  Conversation.prototype[verb] = function submitObjectActivity(conversation, object, activity) {\n    var _this25 = this;\n\n    if (!(0, _isObject3.default)(object)) {\n      return _promise2.default.reject(new Error('`object` must be an object'));\n    }\n\n    var c = this.prepareConversation(conversation);\n    return this._inferConversationUrl(conversation).then(function () {\n      return _this25.prepare(activity, {\n        verb: verb,\n        target: c,\n        object: (0, _assign2.default)(c, object)\n      });\n    }).then(function (a) {\n      return _this25.submit(a);\n    });\n  };\n});\nexports.default = Conversation;","map":null,"metadata":{},"sourceType":"script"}