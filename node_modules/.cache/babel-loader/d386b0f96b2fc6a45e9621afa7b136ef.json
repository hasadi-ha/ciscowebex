{"ast":null,"code":"/*!\n * algorithms/aes-gcm.js - AES-GCM Encryption and Key-Wrapping\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\"use strict\";\n\nvar helpers = require(\"./helpers.js\"),\n    CONSTANTS = require(\"./constants.js\"),\n    GCM = require(\"../deps/ciphermodes/gcm\");\n\nfunction gcmEncryptFN(size) {\n  function commonChecks(key, iv) {\n    if (size !== key.length << 3) {\n      throw new Error(\"invalid key size\");\n    }\n\n    if (12 !== iv.length) {\n      throw new Error(\"invalid iv\");\n    }\n  } // ### 'fallback' implementation -- uses forge\n\n\n  var fallback = function (key, pdata, props) {\n    var iv = props.iv || new Buffer(0),\n        adata = props.aad || props.adata || new Buffer(0),\n        cipher,\n        cdata; // validate inputs\n\n    try {\n      commonChecks(key, iv, adata);\n    } catch (err) {\n      return Promise.reject(err);\n    } // setup cipher\n\n\n    cipher = GCM.createCipher({\n      key: key,\n      iv: iv,\n      additionalData: adata\n    }); // ciphertext is the same length as plaintext\n\n    cdata = new Buffer(pdata.length);\n    var promise = new Promise(function (resolve, reject) {\n      var amt = CONSTANTS.CHUNK_SIZE,\n          clen = 0,\n          poff = 0;\n\n      (function doChunk() {\n        var plen = Math.min(amt, pdata.length - poff);\n        clen += cipher.update(pdata, poff, plen, cdata, clen);\n        poff += plen;\n\n        if (pdata.length > poff) {\n          setTimeout(doChunk, 0);\n          return;\n        } // finish it\n\n\n        clen += cipher.finish(cdata, clen);\n\n        if (clen !== pdata.length) {\n          reject(new Error(\"encryption failed\"));\n          return;\n        } // resolve with output\n\n\n        var tag = cipher.tag;\n        resolve({\n          data: cdata,\n          tag: tag\n        });\n      })();\n    });\n    return promise;\n  }; // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n\n\n  var webcrypto = function (key, pdata, props) {\n    var iv = props.iv || new Buffer(0),\n        adata = props.aad || props.adata || new Buffer(0);\n\n    try {\n      commonChecks(key, iv, adata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = {\n      name: \"AES-GCM\"\n    };\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"encrypt\"]);\n    promise = promise.then(function (key) {\n      alg.iv = iv;\n      alg.tagLength = 128;\n\n      if (adata.length) {\n        alg.additionalData = adata;\n      }\n\n      return helpers.subtleCrypto.encrypt(alg, key, pdata);\n    });\n    promise = promise.then(function (result) {\n      var tagStart = result.byteLength - 16;\n      var tag = result.slice(tagStart);\n      tag = new Buffer(tag);\n      var cdata = result.slice(0, tagStart);\n      cdata = new Buffer(cdata);\n      return {\n        data: cdata,\n        tag: tag\n      };\n    });\n    return promise;\n  }; // ### NodeJS implementation\n\n\n  var nodejs = function (key, pdata, props) {\n    var iv = props.iv || new Buffer(0),\n        adata = props.aad || props.adata || new Buffer(0);\n\n    try {\n      commonChecks(key, iv, adata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = \"aes-\" + key.length * 8 + \"-gcm\";\n    var cipher;\n\n    try {\n      cipher = helpers.nodeCrypto.createCipheriv(alg, key, iv);\n    } catch (err) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n\n    if (\"function\" !== typeof cipher.setAAD) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n\n    if (adata.length) {\n      cipher.setAAD(adata);\n    }\n\n    var cdata = Buffer.concat([cipher.update(pdata), cipher.final()]);\n    var tag = cipher.getAuthTag();\n    return {\n      data: cdata,\n      tag: tag\n    };\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction gcmDecryptFN(size) {\n  function commonChecks(key, iv, tag) {\n    if (size !== key.length << 3) {\n      throw new Error(\"invalid key size\");\n    }\n\n    if (12 !== iv.length) {\n      throw new Error(\"invalid iv\");\n    }\n\n    if (16 !== tag.length) {\n      throw new Error(\"invalid tag length\");\n    }\n  } // ### fallback implementation -- uses forge\n\n\n  var fallback = function (key, cdata, props) {\n    var adata = props.aad || props.adata || new Buffer(0),\n        iv = props.iv || new Buffer(0),\n        tag = props.tag || props.mac || new Buffer(0),\n        cipher,\n        pdata; // validate inputs\n\n    try {\n      commonChecks(key, iv, tag);\n    } catch (err) {\n      return Promise.reject(err);\n    } // setup cipher\n\n\n    cipher = GCM.createDecipher({\n      key: key,\n      iv: iv,\n      additionalData: adata,\n      tag: tag\n    }); // plaintext is the same length as ciphertext\n\n    pdata = new Buffer(cdata.length);\n    var promise = new Promise(function (resolve, reject) {\n      var amt = CONSTANTS.CHUNK_SIZE,\n          plen = 0,\n          coff = 0;\n\n      (function doChunk() {\n        var clen = Math.min(amt, cdata.length - coff);\n        plen += cipher.update(cdata, coff, clen, pdata, plen);\n        coff += clen;\n\n        if (cdata.length > coff) {\n          setTimeout(doChunk, 0);\n          return;\n        }\n\n        try {\n          plen += cipher.finish(pdata, plen);\n        } catch (err) {\n          reject(new Error(\"decryption failed\"));\n          return;\n        }\n\n        if (plen !== cdata.length) {\n          reject(new Error(\"decryption failed\"));\n          return;\n        } // resolve with output\n\n\n        resolve(pdata);\n      })();\n    });\n    return promise;\n  }; // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n\n\n  var webcrypto = function (key, cdata, props) {\n    var adata = props.aad || props.adata || new Buffer(0),\n        iv = props.iv || new Buffer(0),\n        tag = props.tag || props.mac || new Buffer(0); // validate inputs\n\n    try {\n      commonChecks(key, iv, tag);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = {\n      name: \"AES-GCM\"\n    };\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"decrypt\"]);\n    promise = promise.then(function (key) {\n      alg.iv = iv;\n      alg.tagLength = 128;\n\n      if (adata.length) {\n        alg.additionalData = adata;\n      } // concatenate cdata and tag\n\n\n      cdata = Buffer.concat([cdata, tag], cdata.length + tag.length);\n      return helpers.subtleCrypto.decrypt(alg, key, cdata);\n    });\n    promise = promise.then(function (pdata) {\n      pdata = new Buffer(pdata);\n      return pdata;\n    });\n    return promise;\n  };\n\n  var nodejs = function (key, cdata, props) {\n    var adata = props.aad || props.adata || new Buffer(0),\n        iv = props.iv || new Buffer(0),\n        tag = props.tag || props.mac || new Buffer(0); // validate inputs\n\n    try {\n      commonChecks(key, iv, tag);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = \"aes-\" + key.length * 8 + \"-gcm\";\n    var cipher;\n\n    try {\n      cipher = helpers.nodeCrypto.createDecipheriv(alg, key, iv);\n    } catch (err) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n\n    if (\"function\" !== typeof cipher.setAAD) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n\n    cipher.setAuthTag(tag);\n\n    if (adata.length) {\n      cipher.setAAD(adata);\n    }\n\n    try {\n      var pdata = Buffer.concat([cipher.update(cdata), cipher.final()]);\n      return pdata;\n    } catch (err) {\n      throw new Error(\"decryption failed\");\n    }\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n} // ### Public API\n// * [name].encrypt\n// * [name].decrypt\n\n\nvar aesGcm = {};\n[\"A128GCM\", \"A192GCM\", \"A256GCM\", \"A128GCMKW\", \"A192GCMKW\", \"A256GCMKW\"].forEach(function (alg) {\n  var size = parseInt(/A(\\d+)GCM(?:KW)?/g.exec(alg)[1]);\n  aesGcm[alg] = {\n    encrypt: gcmEncryptFN(size),\n    decrypt: gcmDecryptFN(size)\n  };\n});\nmodule.exports = aesGcm;","map":null,"metadata":{},"sourceType":"script"}