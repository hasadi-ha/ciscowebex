{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _webexCore = require('@webex/webex-core');\n\nvar _common = require('@webex/common');\n\nvar _events = require('events');\n\nvar _nodeJose = require('node-jose');\n\nvar _nodeJose2 = _interopRequireDefault(_nodeJose);\n\nvar _nodeScr = require('node-scr');\n\nvar _nodeScr2 = _interopRequireDefault(_nodeScr);\n\nvar _ensureBuffer = require('./ensure-buffer');\n\nvar _ensureBuffer2 = _interopRequireDefault(_ensureBuffer);\n\nvar _kms = require('./kms');\n\nvar _kms2 = _interopRequireDefault(_kms);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Encryption = _webexCore.WebexPlugin.extend({\n  children: {\n    kms: _kms2.default\n  },\n  namespace: 'Encryption',\n  processKmsMessageEvent: function processKmsMessageEvent(event) {\n    return this.kms.processKmsMessageEvent(event);\n  },\n  decryptBinary: function decryptBinary(scr, buffer) {\n    return (0, _ensureBuffer2.default)(buffer).then(function (b) {\n      /* istanbul ignore if */\n      if (buffer.length === 0 || buffer.byteLength === 0) {\n        return _promise2.default.reject(new Error('Attempted to decrypt zero-length buffer'));\n      }\n\n      return scr.decrypt(b);\n    });\n  },\n\n  /**\n   * Decrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} cipherScr - An encrypted SCR\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {Object} Decrypted SCR\n   */\n  decryptScr: function decryptScr(key, cipherScr, options) {\n    return this.getKey(key, options).then(function (k) {\n      return _nodeScr2.default.fromJWE(k.jwk, cipherScr);\n    });\n  },\n\n  /**\n   * Decrypt text using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} ciphertext - Encrypted text\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Decrypted plaintext\n   */\n  decryptText: function decryptText(key, ciphertext, options) {\n    return this.getKey(key, options).then(function (k) {\n      return _nodeJose2.default.JWE.createDecrypt(k.jwk).decrypt(ciphertext).then(function (result) {\n        return result.plaintext.toString();\n      });\n    });\n  },\n  download: function download(scr) {\n    var _this = this;\n    /* istanbul ignore if */\n\n\n    if (!scr.loc) {\n      return _promise2.default.reject(new Error('`scr.loc` is required'));\n    }\n\n    var shunt = new _events.EventEmitter();\n\n    var promise = this._fetchDownloadUrl(scr).then(function (uri) {\n      var options = {\n        method: 'GET',\n        uri: uri,\n        responseType: 'buffer'\n      };\n\n      var ret = _this.request(options);\n\n      (0, _common.transferEvents)('progress', options.download, shunt);\n      return ret;\n    }).then(function (res) {\n      return _this.decryptBinary(scr, res.body);\n    });\n\n    (0, _common.proxyEvents)(shunt, promise);\n    return promise;\n  },\n  _fetchDownloadUrl: function _fetchDownloadUrl(scr) {\n    var _this2 = this;\n\n    this.logger.info('encryption: retrieving download url for encrypted file');\n\n    if (process.env.NODE_ENV !== 'production' && scr.loc.includes('localhost')) {\n      this.logger.info('encryption: bypassing webex files because this looks to be a test file on localhost');\n      return _promise2.default.resolve(scr.loc);\n    }\n\n    return this.request({\n      method: 'POST',\n      service: 'files',\n      resource: 'download/endpoints',\n      body: {\n        endpoints: [scr.loc]\n      }\n    }).then(function (res) {\n      var url = res.body.endpoints[scr.loc];\n\n      if (!url) {\n        _this2.logger.warn('encryption: could not determine download url for `scr.loc`; attempting to download `scr.loc` directly');\n\n        return scr.loc;\n      }\n\n      _this2.logger.info('encryption: retrieved download url for encrypted file');\n\n      return url;\n    });\n  },\n  encryptBinary: function encryptBinary(file) {\n    return (0, _ensureBuffer2.default)(file).then(function (buffer) {\n      return _nodeScr2.default.create().then(function (scr) {\n        return scr.encrypt(buffer).then(_ensureBuffer2.default) // eslint-disable-next-line max-nested-callbacks\n        .then(function (cdata) {\n          return {\n            scr: scr,\n            cdata: cdata\n          };\n        });\n      });\n    });\n  },\n\n  /**\n   * Encrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} scr - Plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted SCR\n   */\n  encryptScr: function encryptScr(key, scr, options) {\n    /* istanbul ignore if */\n    if (!scr.loc) {\n      return _promise2.default.reject(new Error('Cannot encrypt `scr` without first setting `loc`'));\n    }\n\n    return this.getKey(key, options).then(function (k) {\n      return scr.toJWE(k.jwk);\n    });\n  },\n\n  /**\n   * Encrypt plaintext using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted text\n   */\n  encryptText: function encryptText(key, plaintext, options) {\n    var _this3 = this;\n\n    return this.getKey(key, options).then(function (k) {\n      return _nodeJose2.default.JWE.createEncrypt(_this3.config.joseOptions, {\n        key: k.jwk,\n        header: {\n          alg: 'dir'\n        },\n        reference: null\n      }).final(plaintext, 'utf8');\n    });\n  },\n\n  /**\n   * Fetch the key associated with the supplied KMS uri.\n   *\n   * @param {string} uri - The uri of a key stored in KMS\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Key\n   */\n  getKey: function getKey(uri) {\n    var _this4 = this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        onBehalfOf = _ref.onBehalfOf;\n\n    if (uri.jwk) {\n      return this.kms.asKey(uri);\n    }\n\n    var storageKey = uri;\n\n    if (onBehalfOf) {\n      storageKey += '/onBehalfOf/' + onBehalfOf;\n    }\n\n    return this.unboundedStorage.get(storageKey).then(function (keyString) {\n      return JSON.parse(keyString);\n    }).then(function (keyObject) {\n      return _this4.kms.asKey(keyObject);\n    }).catch(function () {\n      return _this4.kms.fetchKey({\n        uri: uri,\n        onBehalfOf: onBehalfOf\n      }).then((0, _common.tap)(function (key) {\n        return _this4.unboundedStorage.put(storageKey, (0, _stringify2.default)(key, replacer));\n      }));\n    });\n  },\n  version: '1.69.1'\n});\n/**\n * JSON.stringify replacer that ensures private key data is serialized.\n * @param {string} k\n * @param {mixed} v\n * @returns {mixed}\n */\n\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nfunction replacer(k, v) {\n  if (k === 'jwk') {\n    // note: this[k] and v may be different representations of the same value\n    // eslint-disable-next-line no-invalid-this\n    var json = this[k].toJSON(true);\n    return json;\n  }\n\n  return v;\n}\n\nexports.default = Encryption;","map":null,"metadata":{},"sourceType":"script"}